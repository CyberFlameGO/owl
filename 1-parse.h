// -----------------------------------------------------------------------------
// This file was generated by the bluebird parsing tool.
// Make sure to #define BLUEBIRD_PARSER_IMPLEMENTATION somewhere so the parser
// is compiled properly.  Just two lines are enough -- a typical parser.c might
// look like:
//
//   #define BLUEBIRD_PARSER_IMPLEMENTATION
//   #include "bluebird-parser.h"

#ifndef _BLUEBIRD_PARSER_H_
#define _BLUEBIRD_PARSER_H_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

// The bluebird_tree struct represents an entire parse tree.  Use the
// bluebird_tree_create_...() functions to create a tree, then call
// bluebird_tree_root() to get the root bluebird_id.
struct bluebird_tree;

// Creates a bluebird_tree from a string.  The tree may directly reference
// pieces of the string -- you're responsible for keeping it around until
// bluebird_tree_destroy() is called.
struct bluebird_tree *bluebird_tree_create_from_string(const char *string);

// Creates a bluebird_tree by reading from a file.
struct bluebird_tree *bluebird_tree_create_from_file(FILE *file);

// Destroys a bluebird_tree, freeing its resources back to the system.
void bluebird_tree_destroy(struct bluebird_tree *);

// Prints a representation of the tree to standard output.
void bluebird_tree_print(struct bluebird_tree *);

// A bluebird_node represents an node in the parse tree.  Use the
// parsed_..._get() function corresponding to the element type to unpack the
// node into its appropriate type of parsed_... element struct.
struct bluebird_node {
    struct bluebird_tree *_tree;
    size_t _offset;
    uint32_t _type;
    bool empty;
};

// The bluebird_next function returns the next sibling node.
struct bluebird_node bluebird_next(struct bluebird_node);

// Returns the root bluebird_node.
struct bluebird_node bluebird_tree_root_node(struct bluebird_tree *tree);

// As a shortcut, returns the parsed_grammar struct corresponding to the root node.
struct parsed_grammar bluebird_tree_get_parsed_grammar(struct bluebird_tree *tree);

// The range of text corresponding to a tree element.
struct source_range {
    size_t start;
    size_t end;
};

enum bluebird_error {
    // No error -- everything's fine!
    ERROR_NONE,

    // The file passed to bluebird_tree_create_from_file wasn't valid because
    // - it was NULL,
    // - it doesn't support fseek/ftell, or
    // - there was an error while reading it.
    ERROR_INVALID_FILE,

    // A piece of text couldn't be matched as a token.
    ERROR_INVALID_TOKEN,

    // The parser encountered an out-of-place token that doesn't fit the grammar.
    ERROR_UNEXPECTED_TOKEN,

    // The input is valid so far, but incomplete; more tokens could be added to
    // complete it.
    ERROR_MORE_INPUT_NEEDED,
};
// Returns an error code, or ERROR_NONE if there wasn't an error.
// The error_range parameter can be null.
enum bluebird_error bluebird_tree_get_error(struct bluebird_tree *tree, struct source_range *error_range);

enum parsed_type {
    PARSED_IDENT = 1,
    PARSED_CHOICE,
    PARSED_PARENS,
    PARSED_FLAT_OP,
    PARSED_LEFT_OP,
    PARSED_LITERAL,
    PARSED_INFIX_OP,
    PARSED_OPTIONAL,
    PARSED_RIGHT_OP,
    PARSED_BRACKETED,
    PARSED_PREFIX_OP,
    PARSED_POSTFIX_OP,
    PARSED_NONASSOC_OP,
    PARSED_ONE_OR_MORE,
    PARSED_ZERO_OR_MORE,
    PARSED_CONCATENATION,
};

struct parsed_grammar {
    struct source_range range;
    struct bluebird_node rule;
    struct bluebird_node comment_token;
};

struct parsed_rule {
    struct source_range range;
    struct bluebird_node identifier;
    struct bluebird_node body;
};

struct parsed_body {
    struct source_range range;
    struct bluebird_node expr;
    struct bluebird_node identifier;
    struct bluebird_node operators;
};

struct parsed_operators {
    struct source_range range;
    struct bluebird_node fixity;
    struct bluebird_node operator;
};

struct parsed_fixity {
    struct source_range range;
    enum parsed_type type;
    struct bluebird_node assoc;
};

struct parsed_assoc {
    struct source_range range;
    enum parsed_type type;
};

struct parsed_operator {
    struct source_range range;
    struct bluebird_node expr;
    struct bluebird_node identifier;
};

struct parsed_expr {
    struct source_range range;
    enum parsed_type type;
    struct bluebird_node identifier;
    struct bluebird_node exception;
    struct bluebird_node rename;
    struct bluebird_node string;
    struct bluebird_node expr;
    struct bluebird_node begin_token;
    struct bluebird_node end_token;
    struct bluebird_node operand;
};

struct parsed_comment_token {
    struct source_range range;
    struct bluebird_node string;
};

struct parsed_identifier {
    struct source_range range;
    const char *identifier;
    size_t length;
};

struct parsed_number {
    struct source_range range;
    double number;
};

struct parsed_string {
    struct source_range range;
    const char *string;
    size_t length;
    bool has_escapes;
};

struct parsed_grammar parsed_grammar_get(struct bluebird_node);
struct parsed_rule parsed_rule_get(struct bluebird_node);
struct parsed_body parsed_body_get(struct bluebird_node);
struct parsed_operators parsed_operators_get(struct bluebird_node);
struct parsed_fixity parsed_fixity_get(struct bluebird_node);
struct parsed_assoc parsed_assoc_get(struct bluebird_node);
struct parsed_operator parsed_operator_get(struct bluebird_node);
struct parsed_expr parsed_expr_get(struct bluebird_node);
struct parsed_comment_token parsed_comment_token_get(struct bluebird_node);
struct parsed_identifier parsed_identifier_get(struct bluebird_node);
struct parsed_number parsed_number_get(struct bluebird_node);
struct parsed_string parsed_string_get(struct bluebird_node);

#endif

#ifdef BLUEBIRD_PARSER_IMPLEMENTATION
// Code implementing the parser.  This might get a bit messy!
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct bluebird_tree {
    const char *string;
    bool owns_string;
    uint8_t *parse_tree;
    size_t parse_tree_size;
    size_t next_offset;
    enum bluebird_error error;
    struct source_range error_range;
    size_t root_offset;
    struct {
        const char *identifier;
        size_t length;
        struct source_range range;
    } *identifier_tokens;
    size_t number_of_identifier_tokens;
    size_t used_identifier_tokens;
    size_t identifier_tokens_capacity;
    struct {
        double number;
        struct source_range range;
    } *number_tokens;
    size_t number_of_number_tokens;
    size_t used_number_tokens;
    size_t number_tokens_capacity;
    struct {
        const char *string;
        size_t length;
        bool has_escapes;
        struct source_range range;
    } *string_tokens;
    size_t number_of_string_tokens;
    size_t used_string_tokens;
    size_t string_tokens_capacity;
};
static void add_identifier_token(struct bluebird_tree *tree, size_t start, size_t end, const char *identifier_param, size_t length_param) {
    size_t index = tree->number_of_identifier_tokens++;
    if (tree->number_of_identifier_tokens > tree->identifier_tokens_capacity) {
        size_t capacity = (tree->identifier_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->identifier_tokens, sizeof(tree->identifier_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->identifier_tokens_capacity = capacity;
        tree->identifier_tokens = tokens;
    }
    tree->identifier_tokens[index].range.start = start;
    tree->identifier_tokens[index].range.end = end;
    tree->identifier_tokens[index].identifier = identifier_param;
    tree->identifier_tokens[index].length = length_param;
}
static void add_number_token(struct bluebird_tree *tree, size_t start, size_t end, double number_param) {
    size_t index = tree->number_of_number_tokens++;
    if (tree->number_of_number_tokens > tree->number_tokens_capacity) {
        size_t capacity = (tree->number_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->number_tokens, sizeof(tree->number_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->number_tokens_capacity = capacity;
        tree->number_tokens = tokens;
    }
    tree->number_tokens[index].range.start = start;
    tree->number_tokens[index].range.end = end;
    tree->number_tokens[index].number = number_param;
}
static void add_string_token(struct bluebird_tree *tree, size_t start, size_t end, const char *string_param, size_t length_param, bool has_escapes_param) {
    size_t index = tree->number_of_string_tokens++;
    if (tree->number_of_string_tokens > tree->string_tokens_capacity) {
        size_t capacity = (tree->string_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->string_tokens, sizeof(tree->string_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->string_tokens_capacity = capacity;
        tree->string_tokens = tokens;
    }
    tree->string_tokens[index].range.start = start;
    tree->string_tokens[index].range.end = end;
    tree->string_tokens[index].string = string_param;
    tree->string_tokens[index].length = length_param;
    tree->string_tokens[index].has_escapes = has_escapes_param;
}
// Reserve 10 bytes for each entry (the maximum encoded size of a 64-bit value).
#define RESERVATION_AMOUNT 10
static inline uint64_t read_tree(size_t *offset, struct bluebird_tree *tree) {
    uint8_t *parse_tree = tree->parse_tree;
    size_t parse_tree_size = tree->parse_tree_size;
    size_t i = *offset;
    if (i + RESERVATION_AMOUNT >= parse_tree_size)
        return 0;
    uint64_t result = 0;
    int shift_amount = 0;
    while ((parse_tree[i] & 0x80) != 0 && shift_amount < 64) {
        result |= (parse_tree[i] & 0x7f) << shift_amount;
        shift_amount += 7;
        i++;
    }
    result |= (parse_tree[i] & 0x7f) << shift_amount;
    i++;
    *offset = i;
    return result;
}
static bool grow_tree(struct bluebird_tree *tree, size_t size)
{
    size_t n = tree->parse_tree_size;
    while (n < size || n < 4096)
        n = (n + 1) * 3 / 2;
    uint8_t *parse_tree = realloc(tree->parse_tree, n);
    if (!parse_tree)
        return false;
    tree->parse_tree_size = n;
    tree->parse_tree = parse_tree;
    return true;
}
static void write_tree(struct bluebird_tree *tree, uint64_t value)
{
    size_t reserved_size = tree->next_offset + RESERVATION_AMOUNT;
    if (tree->parse_tree_size <= reserved_size && !grow_tree(tree, reserved_size))
        abort();
    while (value >> 7 != 0) {
        tree->parse_tree[tree->next_offset++] = 0x80 | (value & 0x7f);
        value >>= 7;
    }
    tree->parse_tree[tree->next_offset++] = value & 0x7f;
}
struct parsed_grammar parsed_grammar_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_grammar){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_grammar result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.rule._tree = node._tree;
    result.rule._offset = read_tree(&offset, node._tree);
    result.rule._type = 1;
    result.rule.empty = result.rule._offset == 0;
    result.comment_token._tree = node._tree;
    result.comment_token._offset = read_tree(&offset, node._tree);
    result.comment_token._type = 8;
    result.comment_token.empty = result.comment_token._offset == 0;
    return result;
}
struct parsed_rule parsed_rule_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_rule){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_rule result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.identifier._tree = node._tree;
    result.identifier._offset = read_tree(&offset, node._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    result.body._tree = node._tree;
    result.body._offset = read_tree(&offset, node._tree);
    result.body._type = 2;
    result.body.empty = result.body._offset == 0;
    return result;
}
struct parsed_body parsed_body_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_body){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_body result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.expr._tree = node._tree;
    result.expr._offset = read_tree(&offset, node._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.identifier._tree = node._tree;
    result.identifier._offset = read_tree(&offset, node._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    result.operators._tree = node._tree;
    result.operators._offset = read_tree(&offset, node._tree);
    result.operators._type = 3;
    result.operators.empty = result.operators._offset == 0;
    return result;
}
struct parsed_operators parsed_operators_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_operators){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_operators result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.fixity._tree = node._tree;
    result.fixity._offset = read_tree(&offset, node._tree);
    result.fixity._type = 4;
    result.fixity.empty = result.fixity._offset == 0;
    result.operator._tree = node._tree;
    result.operator._offset = read_tree(&offset, node._tree);
    result.operator._type = 6;
    result.operator.empty = result.operator._offset == 0;
    return result;
}
struct parsed_fixity parsed_fixity_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_fixity){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_fixity result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&offset, node._tree),
    };
    result.assoc._tree = node._tree;
    result.assoc._offset = read_tree(&offset, node._tree);
    result.assoc._type = 5;
    result.assoc.empty = result.assoc._offset == 0;
    return result;
}
struct parsed_assoc parsed_assoc_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_assoc){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_assoc result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&offset, node._tree),
    };
    return result;
}
struct parsed_operator parsed_operator_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_operator){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_operator result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.expr._tree = node._tree;
    result.expr._offset = read_tree(&offset, node._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.identifier._tree = node._tree;
    result.identifier._offset = read_tree(&offset, node._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    return result;
}
struct parsed_expr parsed_expr_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_expr){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_expr result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&offset, node._tree),
    };
    result.identifier._tree = node._tree;
    result.identifier._offset = read_tree(&offset, node._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    result.exception._tree = node._tree;
    result.exception._offset = read_tree(&offset, node._tree);
    result.exception._type = 9;
    result.exception.empty = result.exception._offset == 0;
    result.rename._tree = node._tree;
    result.rename._offset = read_tree(&offset, node._tree);
    result.rename._type = 9;
    result.rename.empty = result.rename._offset == 0;
    result.string._tree = node._tree;
    result.string._offset = read_tree(&offset, node._tree);
    result.string._type = 11;
    result.string.empty = result.string._offset == 0;
    result.expr._tree = node._tree;
    result.expr._offset = read_tree(&offset, node._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.begin_token._tree = node._tree;
    result.begin_token._offset = read_tree(&offset, node._tree);
    result.begin_token._type = 11;
    result.begin_token.empty = result.begin_token._offset == 0;
    result.end_token._tree = node._tree;
    result.end_token._offset = read_tree(&offset, node._tree);
    result.end_token._type = 11;
    result.end_token.empty = result.end_token._offset == 0;
    result.operand._tree = node._tree;
    result.operand._offset = read_tree(&offset, node._tree);
    result.operand._type = 7;
    result.operand.empty = result.operand._offset == 0;
    return result;
}
struct parsed_comment_token parsed_comment_token_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_comment_token){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_comment_token result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.string._tree = node._tree;
    result.string._offset = read_tree(&offset, node._tree);
    result.string._type = 11;
    result.string.empty = result.string._offset == 0;
    return result;
}
struct parsed_identifier parsed_identifier_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_identifier){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t token_index = read_tree(&offset, node._tree);
    struct parsed_identifier result = {
        .identifier = node._tree->identifier_tokens[token_index].identifier,
        .length = node._tree->identifier_tokens[token_index].length,
        .range = node._tree->identifier_tokens[token_index].range,
    };
    return result;
}
struct parsed_number parsed_number_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_number){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t token_index = read_tree(&offset, node._tree);
    struct parsed_number result = {
        .number = node._tree->number_tokens[token_index].number,
        .range = node._tree->number_tokens[token_index].range,
    };
    return result;
}
struct parsed_string parsed_string_get(struct bluebird_node node) {
    if (node.empty)
        return (struct parsed_string){0};
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t token_index = read_tree(&offset, node._tree);
    struct parsed_string result = {
        .string = node._tree->string_tokens[token_index].string,
        .length = node._tree->string_tokens[token_index].length,
        .has_escapes = node._tree->string_tokens[token_index].has_escapes,
        .range = node._tree->string_tokens[token_index].range,
    };
    return result;
}
static size_t finish_node(uint32_t rule, uint32_t choice, size_t next_sibling, size_t *slots, size_t start_location, size_t end_location, void *info) {
    struct bluebird_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling);
    write_tree(tree, start_location);
    write_tree(tree, end_location);
    switch (rule) {
    case 0: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 1: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 2: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        break;
    }
    case 3: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 4: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_POSTFIX_OP);
            break;
        case 1:
            write_tree(tree, PARSED_PREFIX_OP);
            break;
        case 2:
            write_tree(tree, PARSED_INFIX_OP);
            break;
        }
        write_tree(tree, slots[0]);
        break;
    }
    case 5: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_FLAT_OP);
            break;
        case 1:
            write_tree(tree, PARSED_LEFT_OP);
            break;
        case 2:
            write_tree(tree, PARSED_RIGHT_OP);
            break;
        case 3:
            write_tree(tree, PARSED_NONASSOC_OP);
            break;
        }
        break;
    }
    case 6: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 7: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_IDENT);
            break;
        case 1:
            write_tree(tree, PARSED_LITERAL);
            break;
        case 2:
            write_tree(tree, PARSED_PARENS);
            break;
        case 3:
            write_tree(tree, PARSED_BRACKETED);
            break;
        case 4:
            write_tree(tree, PARSED_ZERO_OR_MORE);
            break;
        case 5:
            write_tree(tree, PARSED_ONE_OR_MORE);
            break;
        case 6:
            write_tree(tree, PARSED_OPTIONAL);
            break;
        case 7:
            write_tree(tree, PARSED_CONCATENATION);
            break;
        case 8:
            write_tree(tree, PARSED_CHOICE);
            break;
        }
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        write_tree(tree, slots[3]);
        write_tree(tree, slots[4]);
        write_tree(tree, slots[5]);
        write_tree(tree, slots[6]);
        write_tree(tree, slots[7]);
        break;
    }
    case 8: {
        write_tree(tree, slots[0]);
        break;
    }
    default:
        break;
    }
    return offset;
}
static size_t finish_token(uint32_t rule, size_t next_sibling, void *info) {
    struct bluebird_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling);
    switch (rule) {
    case 9: {
        tree->used_identifier_tokens++;
        if (tree->used_identifier_tokens > tree->number_of_identifier_tokens)
            abort();
        size_t token_index = tree->number_of_identifier_tokens - tree->used_identifier_tokens;
        write_tree(tree, token_index);
        break;
    }
    case 10: {
        tree->used_number_tokens++;
        if (tree->used_number_tokens > tree->number_of_number_tokens)
            abort();
        size_t token_index = tree->number_of_number_tokens - tree->used_number_tokens;
        write_tree(tree, token_index);
        break;
    }
    case 11: {
        tree->used_string_tokens++;
        if (tree->used_string_tokens > tree->number_of_string_tokens)
            abort();
        size_t token_index = tree->number_of_string_tokens - tree->used_string_tokens;
        write_tree(tree, token_index);
        break;
    }
    default:
        break;
    }
    return offset;
}
static void check_for_error(struct bluebird_tree *tree) {
    if (tree->error == ERROR_NONE)
        return;
    fprintf(stderr, "parse error: ");
    switch (tree->error) {
    case ERROR_INVALID_FILE:
        fprintf(stderr, "invalid file\n");
        break;
    case ERROR_INVALID_TOKEN:
        fprintf(stderr, "invalid token\n");
        break;
    case ERROR_UNEXPECTED_TOKEN:
        fprintf(stderr, "unexpected token\n");
        break;
    case ERROR_MORE_INPUT_NEEDED:
        fprintf(stderr, "more input needed\n");
        break;
    default:
        break;
    }
    exit(-1);
}
static void parsed_grammar_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_rule_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_body_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_operators_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_fixity_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_assoc_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_operator_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_expr_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_comment_token_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_identifier_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_number_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_string_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_grammar_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_grammar it = parsed_grammar_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("grammar");
        if (strcmp("grammar", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_rule_print(tree, it.rule, "rule", indent + 1);
        parsed_comment_token_print(tree, it.comment_token, "comment_token", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_rule_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_rule it = parsed_rule_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("rule");
        if (strcmp("rule", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_body_print(tree, it.body, "body", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_body_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_body it = parsed_body_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("body");
        if (strcmp("body", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_operators_print(tree, it.operators, "operators", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_operators_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_operators it = parsed_operators_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operators");
        if (strcmp("operators", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_fixity_print(tree, it.fixity, "fixity", indent + 1);
        parsed_operator_print(tree, it.operator, "operator", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_fixity_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_fixity it = parsed_fixity_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("fixity");
        if (strcmp("fixity", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_POSTFIX_OP:
            printf(" : POSTFIX_OP");
            break;
        case PARSED_PREFIX_OP:
            printf(" : PREFIX_OP");
            break;
        case PARSED_INFIX_OP:
            printf(" : INFIX_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_assoc_print(tree, it.assoc, "assoc", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_assoc_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_assoc it = parsed_assoc_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("assoc");
        if (strcmp("assoc", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_FLAT_OP:
            printf(" : FLAT_OP");
            break;
        case PARSED_LEFT_OP:
            printf(" : LEFT_OP");
            break;
        case PARSED_RIGHT_OP:
            printf(" : RIGHT_OP");
            break;
        case PARSED_NONASSOC_OP:
            printf(" : NONASSOC_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        node = bluebird_next(node);
    }
}
static void parsed_operator_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_operator it = parsed_operator_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operator");
        if (strcmp("operator", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_expr_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_expr it = parsed_expr_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("expr");
        if (strcmp("expr", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_IDENT:
            printf(" : IDENT");
            break;
        case PARSED_LITERAL:
            printf(" : LITERAL");
            break;
        case PARSED_PARENS:
            printf(" : PARENS");
            break;
        case PARSED_BRACKETED:
            printf(" : BRACKETED");
            break;
        case PARSED_ZERO_OR_MORE:
            printf(" : ZERO_OR_MORE");
            break;
        case PARSED_ONE_OR_MORE:
            printf(" : ONE_OR_MORE");
            break;
        case PARSED_OPTIONAL:
            printf(" : OPTIONAL");
            break;
        case PARSED_CONCATENATION:
            printf(" : CONCATENATION");
            break;
        case PARSED_CHOICE:
            printf(" : CHOICE");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_identifier_print(tree, it.exception, "exception", indent + 1);
        parsed_identifier_print(tree, it.rename, "rename", indent + 1);
        parsed_string_print(tree, it.string, "string", indent + 1);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_string_print(tree, it.begin_token, "begin_token", indent + 1);
        parsed_string_print(tree, it.end_token, "end_token", indent + 1);
        parsed_expr_print(tree, it.operand, "operand", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_comment_token_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_comment_token it = parsed_comment_token_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("comment_token");
        if (strcmp("comment_token", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_string_print(tree, it.string, "string", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_identifier_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_identifier it = parsed_identifier_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("identifier");
        if (strcmp("identifier", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.identifier);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        node = bluebird_next(node);
    }
}
static void parsed_number_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_number it = parsed_number_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("number");
        if (strcmp("number", slot_name))
            printf("@%s", slot_name);
        printf(" - %f", it.number);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        node = bluebird_next(node);
    }
}
static void parsed_string_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_string it = parsed_string_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("string");
        if (strcmp("string", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.string);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        node = bluebird_next(node);
    }
}
void bluebird_tree_print(struct bluebird_tree *tree) {
    check_for_error(tree);
    parsed_grammar_print(tree, bluebird_tree_root_node(tree), "grammar", 0);
}
struct bluebird_node bluebird_next(struct bluebird_node node) {
    size_t offset = read_tree(&node._offset, node._tree);
    return (struct bluebird_node){
        ._tree = node._tree,
        ._offset = offset,
        ._type = node._type,
        .empty = offset == 0,
    };
}
struct bluebird_node bluebird_tree_root_node(struct bluebird_tree *tree) {
    check_for_error(tree);
    return (struct bluebird_node){
        ._tree = tree,
        ._offset = tree->root_offset,
        ._type = 0,
        .empty = tree->root_offset == 0,
    };
}
struct parsed_grammar bluebird_tree_get_parsed_grammar(struct bluebird_tree *tree) {
    check_for_error(tree);
    return parsed_grammar_get(bluebird_tree_root_node(tree));
}
#define IGNORE_TOKEN_WRITE(...)
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info);
static void write_identifier_token(size_t offset, size_t length, void *info) {
    struct bluebird_tree *tree = info;
    add_identifier_token(tree, offset, offset + length, tree->string + offset, length);
}
static void write_number_token(size_t offset, size_t length, double number, void *info) {
    struct bluebird_tree *tree = info;
    add_number_token(tree, offset, offset + length, number);
}
static void write_string_token(size_t offset, size_t length, const char *string, size_t string_length, bool has_escapes, void *info) {
    struct bluebird_tree *tree = info;
    add_string_token(tree, offset, offset + length, string, string_length, has_escapes);
}
struct bluebird_token_run {
    struct bluebird_token_run *prev;
    uint16_t number_of_tokens;
    uint16_t lengths_size;
    uint8_t lengths[4096 * 2];
    uint32_t tokens[4096];
    uint32_t states[4096];
};
struct bluebird_default_tokenizer {
    const char *text;
    size_t offset;
    size_t whitespace;
    uint32_t identifier_token;
    uint32_t number_token;
    uint32_t string_token;
    void *info;
};
static bool char_is_whitespace(char c) {
    switch (c) {
    case ' ':
    case '\t':
    case '\r':
    case '\n':
        return true;
    default:
        return false;
    }
}
static bool char_is_numeric(char c) {
    return c >= '0' && c <= '9';
}
static bool char_is_alphabetic(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}
static bool char_starts_identifier(char c) {
    return char_is_alphabetic(c) || c == '_';
}
static bool char_continues_identifier(char c, void *info) {
    if (true && c == '-') return true;
    return char_is_numeric(c) || char_starts_identifier(c);
}
static bool encode_length(struct bluebird_token_run *run, uint16_t *lengths_size, size_t length) {
    uint8_t mark = 0;
    while (*lengths_size < sizeof(run->lengths)) {
        run->lengths[*lengths_size] = mark | (length & 0x7f);
        mark = 0x80;
        length >>= 7;
        (*lengths_size)++;
        if (length == 0) return true;
    }
    return false;
}
static bool encode_token_length(struct bluebird_token_run *run, uint16_t *lengths_size, size_t length, size_t whitespace) {
    uint16_t size = *lengths_size;
    if (encode_length(run, lengths_size, length) && encode_length(run, lengths_size, whitespace)) return true;
    *lengths_size = size;
    return false;
}
static size_t decode_length(struct bluebird_token_run *run, uint16_t *length_offset) {
    size_t length = 0;
    while (*length_offset < sizeof(run->lengths)) {
        size_t l = run->lengths[(*length_offset)--];
        length <<= 7;
        length += l & 0x7f;
        if (!(l & 0x80)) return length;
    }
    abort();
}
static size_t decode_token_length(struct bluebird_token_run *run, uint16_t *length_offset, size_t *string_offset) {
    size_t whitespace = decode_length(run, length_offset);
    size_t length = decode_length(run, length_offset);
    *string_offset -= whitespace + length;
    return length;
}
static bool bluebird_default_tokenizer_advance(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run **previous_run) {
    struct bluebird_token_run *run = malloc(sizeof(struct bluebird_token_run));
    if (!run) return false;
    uint16_t number_of_tokens = 0;
    uint16_t lengths_size = 0;
    const char *text = tokenizer->text;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset;
    while (number_of_tokens < 4096) {
        char c = text[offset];
        if (c == '\0') break;
        if (char_is_whitespace(c)) {
            whitespace++;
            offset++;
            continue;
        }
        uint32_t token;
        bool is_token = false;
        bool end_token = false;
        bool comment = false;
        bool has_escapes = false;
        size_t token_length = read_keyword_token(&token, &end_token, text + offset, tokenizer->info);
        if (token_length > 0) {
            is_token = true;
            if (token == 0xffffffff) comment = true;
        }
        double number = 0;
        if (char_is_numeric(c) || (c == '.' && char_is_numeric(text[offset + 1]))) {
            const char *start = (const char *)text + offset;
            char *rest = 0;
            number = strtod(start, &rest);
            if (rest > start && rest - start > token_length) {
                token_length = rest - start;
                is_token = true;
                end_token = false;
                comment = false;
                token = 22;
            }
        }
        else if (c == '\'' || c == '"') {
            size_t string_offset = offset + 1;
            while (text[string_offset] != '\0') {
                if (text[string_offset] == c) {
                    token_length = string_offset + 1 - offset;
                    is_token = true;
                    end_token = false;
                    comment = false;
                    token = 23;
                    break;
                }
                if (text[string_offset] == '\\') {
                    has_escapes = true;
                    string_offset++;
                    if (text[string_offset] == '\0') break;
                }
                string_offset++;
            }
        }
        else if (char_starts_identifier(c)) {
            size_t identifier_offset = offset + 1;
            while (char_continues_identifier(text[identifier_offset], tokenizer->info)) identifier_offset++;
            if (identifier_offset - offset > token_length) {
                token_length = identifier_offset - offset;
                is_token = true;
                end_token = false;
                comment = false;
                token = 21;
            }
        }
        if (comment) {
            while (text[offset] != '\0' && text[offset] != '\n') {
                whitespace++;
                offset++;
            }
            continue;
        }
        else if (!is_token || token == 0xffffffff) {
            tokenizer->offset = offset;
            tokenizer->whitespace = whitespace;
            free(run);
            return false;
        }
        if (end_token && number_of_tokens + 1 >= 4096) break;
        if (!encode_token_length(run, &lengths_size, token_length, whitespace)) break;
        if (token == 21) {
            write_identifier_token(offset, token_length, tokenizer->info);
        }
        else if (token == 22) {
            write_number_token(offset, token_length, number, tokenizer->info);
        }
        else if (token == 23) {
            size_t content_offset = offset + 1;
            size_t content_length = token_length - 2;
            const char *string = text + content_offset;
            size_t string_length = content_length;
            if (has_escapes) {
                for (size_t i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') {
                        string_length--;
                        i++;
                    }
                }
                char *unescaped = malloc(string_length);
                size_t j = 0;
                for (size_t i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') i++;
                    unescaped[j++] = text[content_offset + i];
                }
                string = unescaped;
            }
            write_string_token(offset, token_length, string, string_length, has_escapes, tokenizer->info);
        }
        run->tokens[number_of_tokens] = token;
        whitespace = 0;
        number_of_tokens++;
        offset += token_length;
        if (end_token) {
            assert(number_of_tokens < 4096);
            run->tokens[number_of_tokens] = 4294967295U;
            number_of_tokens++;
        }
    }
    if (number_of_tokens == 0) {
        tokenizer->offset = offset;
        tokenizer->whitespace = whitespace;
        free(run);
        return false;
    }
    tokenizer->offset = offset;
    tokenizer->whitespace = whitespace;
    run->prev = *previous_run;
    run->number_of_tokens = number_of_tokens;
    run->lengths_size = lengths_size;
    *previous_run = run;
    return true;
}
static void find_token_range(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run *run, uint16_t index, size_t *start, size_t *end) {
    size_t offset = tokenizer->offset - tokenizer->whitespace;
    size_t last_offset = offset;
    size_t len = 0;
    uint16_t length_offset = run->lengths_size - 1;
    for (uint16_t j = index;
    j < run->number_of_tokens;
    ++j) {
        if (run->tokens[j] == 4294967295U) continue;
        last_offset = offset;
        len = decode_token_length(run, &length_offset, &offset);
    }
    *start = last_offset - len;
    *end = last_offset;
}
static void estimate_next_token_range(struct bluebird_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset;
    size_t i = tokenizer->offset + 1;
    while (tokenizer->text[i] != '\0' && !char_is_whitespace(tokenizer->text[i]) && !char_continues_identifier(tokenizer->text[i], tokenizer->info)) i++;
    *end = i;
}
static void find_end_range(struct bluebird_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset - tokenizer->whitespace - 1;
    *end = tokenizer->offset - tokenizer->whitespace;
    if (*start > *end) {
        *start = *end;
        *end += 1;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context);
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context);
static size_t number_of_slots_lookup(uint32_t rule, void *context);
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context);
enum construct_fixity_associativity {
CONSTRUCT_PREFIX, CONSTRUCT_POSTFIX, CONSTRUCT_INFIX_LEFT, CONSTRUCT_INFIX_RIGHT, CONSTRUCT_INFIX_FLAT, };
struct construct_node {
    struct construct_node *next;
    size_t number_of_slots;
    size_t *slots;
    uint32_t rule;
    uint16_t slot_index;
    uint16_t choice_index;
    enum construct_fixity_associativity fixity_associativity;
    int precedence;
    size_t start_location;
    size_t end_location;
};
struct construct_expression {
    struct construct_expression *parent;
    struct construct_node *first_operator;
    struct construct_node *first_value;
    uint32_t operand_slot_index;
    uint32_t left_slot_index;
    uint32_t right_slot_index;
    uint32_t rule;
    uint16_t slot_index;
};
enum construct_root_type {
CONSTRUCT_NORMAL_ROOT, CONSTRUCT_EXPRESSION_ROOT, };
struct construct_state {
    enum construct_root_type root_type;
    struct construct_node *under_construction;
    struct construct_expression *current_expression;
    struct construct_node *node_freelist;
    struct construct_expression *expression_freelist;
    void *info;
};
static struct construct_node *construct_node_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_node *node;
    size_t number_of_slots = number_of_slots_lookup(rule, s->info);
    if (s->node_freelist) {
        node = s->node_freelist;
        s->node_freelist = node->next;
        size_t *slots = node->slots;
        if (number_of_slots > node->number_of_slots) {
            slots = realloc(slots, number_of_slots * sizeof(size_t));
            if (!slots) abort();
        }
        memset(node, 0, sizeof(struct construct_node));
        memset(slots, 0, number_of_slots * sizeof(size_t));
        node->slots = slots;
    }
    else {
        node = calloc(1, sizeof(struct construct_node));
        if (!node) abort();
        node->slots = calloc(number_of_slots, sizeof(size_t));
        if (!node->slots) abort();
    }
    node->rule = rule;
    node->number_of_slots = number_of_slots;
    return node;
}
static struct construct_expression *construct_expression_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_expression *expr;
    if (s->expression_freelist) {
        expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        memset(expr, 0, sizeof(struct construct_expression));
    }
    else {
        expr = calloc(1, sizeof(struct construct_expression));
        if (!expr) abort();
    }
    (left_right_operand_slots_lookup(rule, &(expr->left_slot_index), &(expr->right_slot_index), &(expr->operand_slot_index), s->info));
    expr->rule = rule;
    return expr;
}
static void construct_node_free(struct construct_state *state, struct construct_node *node) {
    node->next = state->node_freelist;
    state->node_freelist = node;
}
static void construct_expression_free(struct construct_state *state, struct construct_expression *expr) {
    expr->parent = state->expression_freelist;
    state->expression_freelist = expr;
}
static bool construct_expression_should_reduce(struct construct_state *s, struct construct_expression *expr, struct construct_node *node) {
    if (node->fixity_associativity == CONSTRUCT_POSTFIX) return false;
    struct construct_node *top = expr->first_operator;
    if (!top) return false;
    return node->precedence < top->precedence || (node->precedence == top->precedence && node->fixity_associativity == CONSTRUCT_INFIX_RIGHT);
}
static void construct_expression_reduce(struct construct_state *s, struct construct_expression *expr) {
    struct construct_node *op = expr->first_operator;
    if (op->fixity_associativity == CONSTRUCT_INFIX_FLAT) {
        struct construct_node *first_value = expr->first_value;
        struct construct_node *last_value = first_value;
        struct construct_node *last_operator = op;
        size_t operand = op->slots[expr->operand_slot_index];
        struct construct_node *combined_op = construct_node_alloc(s, op->rule);
        combined_op->choice_index = op->choice_index;
        combined_op->slot_index = op->slot_index;
        combined_op->fixity_associativity = op->fixity_associativity;
        combined_op->precedence = op->precedence;
        struct construct_node *reversed_values = 0;
        while (last_operator && last_operator->choice_index == op->choice_index) {
            struct construct_node *next_op = last_operator->next;
            construct_node_free(s, last_operator);
            last_operator = next_op;
            assert(last_value);
            struct construct_node *next_value = last_value->next;
            last_value->next = reversed_values;
            reversed_values = last_value;
            last_value = next_value;
        }
        combined_op->start_location = first_value->start_location;
        combined_op->end_location = last_value->end_location;
        assert(last_value);
        operand = (finish_node((last_value)->rule, (last_value)->choice_index, operand, (last_value)->slots, (last_value)->start_location, (last_value)->end_location, s->info));
        combined_op->next = last_value->next;
        construct_node_free(s, last_value);
        while (reversed_values) {
            operand = (finish_node((reversed_values)->rule, (reversed_values)->choice_index, operand, (reversed_values)->slots, (reversed_values)->start_location, (reversed_values)->end_location, s->info));
            struct construct_node *next_value = reversed_values->next;
            construct_node_free(s, reversed_values);
            reversed_values = next_value;
        }
        expr->first_operator = last_operator;
        expr->first_value = combined_op;
        combined_op->slots[expr->operand_slot_index] = operand;
    }
    else if (op->fixity_associativity == CONSTRUCT_INFIX_LEFT || op->fixity_associativity == CONSTRUCT_INFIX_RIGHT) {
        expr->first_operator = op->next;
        struct construct_node *left = expr->first_value;
        struct construct_node *right = left->next;
        op->next = right->next;
        expr->first_value = op;
        op->start_location = left->start_location;
        op->end_location = right->end_location;
        op->slots[expr->left_slot_index] = (finish_node((left)->rule, (left)->choice_index, op->slots[expr->left_slot_index], (left)->slots, (left)->start_location, (left)->end_location, s->info));
        op->slots[expr->right_slot_index] = (finish_node((right)->rule, (right)->choice_index, op->slots[expr->right_slot_index], (right)->slots, (right)->start_location, (right)->end_location, s->info));
        construct_node_free(s, left);
        construct_node_free(s, right);
    }
    else {
        expr->first_operator = op->next;
        struct construct_node *value = expr->first_value;
        op->next = value->next;
        expr->first_value = op;
        if (value->start_location < op->start_location) op->start_location = value->start_location;
        if (value->end_location > op->end_location) op->end_location = value->end_location;
        op->slots[expr->operand_slot_index] = (finish_node((value)->rule, (value)->choice_index, op->slots[expr->operand_slot_index], (value)->slots, (value)->start_location, (value)->end_location, s->info));
        construct_node_free(s, value);
    }
}
static void construct_begin(struct construct_state *s, size_t offset, enum construct_root_type type) {
    s->root_type = type;
    uint32_t r = 0;
    if (type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = construct_expression_alloc(s, r);
        expr->parent = s->current_expression;
        s->current_expression = expr;
    }
    else {
        struct construct_node *node = construct_node_alloc(s, r);
        node->next = s->under_construction;
        node->end_location = offset;
        s->under_construction = node;
    }
}
static size_t construct_finish(struct construct_state *s, size_t offset) {
    size_t finished = 0;
    if (s->root_type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = s->current_expression;
        s->current_expression = expr->parent;
        while (expr->first_operator) construct_expression_reduce(s, expr);
        struct construct_node *node = expr->first_value;
        if (node) {
            finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            assert(node->next == 0);
            construct_node_free(s, node);
        }
        construct_expression_free(s, expr);
    }
    else {
        struct construct_node *node = s->under_construction;
        s->under_construction = node->next;
        node->start_location = offset;
        finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
        construct_node_free(s, node);
    }
    while (s->node_freelist) {
        struct construct_node *node = s->node_freelist;
        s->node_freelist = node->next;
        free(node->slots);
        free(node);
    }
    while (s->expression_freelist) {
        struct construct_expression *expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        free(expr);
    }
    return finished;
}
static void construct_action_apply(struct construct_state *s, uint16_t action, size_t offset) {
    switch ((((action) >> 12) & 0xf)) {
    case 8:
        {
            struct construct_node *node = construct_node_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            node->next = s->under_construction;
            node->slot_index = ((action) & 0xfff);
            node->end_location = offset;
            s->under_construction = node;
            break;
        }
    case 9:
        {
            struct construct_expression *expr = construct_expression_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            expr->parent = s->current_expression;
            s->current_expression = expr;
            expr->slot_index = ((action) & 0xfff);
            break;
        }
    case 1:
        {
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            size_t *finished;
            finished = &s->under_construction->slots[node->slot_index];
            *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            construct_node_free(s, node);
            break;
        }
    case 2:
        {
            struct construct_expression *expr = s->current_expression;
            s->current_expression = expr->parent;
            while (expr->first_operator) construct_expression_reduce(s, expr);
            size_t *finished;
            finished = &s->under_construction->slots[expr->slot_index];
            struct construct_node *node = expr->first_value;
            if (node) {
                *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
                assert(node->next == 0);
                construct_node_free(s, node);
            }
            construct_expression_free(s, expr);
            break;
        }
    case 3:
        s->under_construction->choice_index = ((action) & 0xfff);
        break;
    case 4:
        {
            uint16_t slot = ((action) & 0xfff);
            size_t *finished = &s->under_construction->slots[slot];
            *finished = finish_token(rule_lookup(s->under_construction->rule, slot, s->info), *finished, s->info);
            break;
        }
    case 10:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 11:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            enum construct_fixity_associativity fixity_associativity;
            int precedence;
            do {
                int local;
                fixity_associativity_precedence_lookup(&local, &precedence, expr->rule, ((action) & 0xfff), s->info);
                fixity_associativity = local;
            }
            while (0);
            node->fixity_associativity = fixity_associativity;
            node->precedence = precedence;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 5:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            node->next = expr->first_value;
            expr->first_value = node;
            break;
        }
    case 6:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            while (construct_expression_should_reduce(s, expr, node)) construct_expression_reduce(s, expr);
            node->next = expr->first_operator;
            expr->first_operator = node;
            if (node->fixity_associativity == CONSTRUCT_PREFIX) construct_expression_reduce(s, expr);
            break;
        }
    }
}

struct fill_run_state {
    uint32_t state;
    uint32_t reachability_mask[1];
};
struct fill_run_continuation {
    struct fill_run_state *stack;
    uint32_t depth;
    uint32_t capacity;
};
static bool fill_run_states(struct bluebird_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index);
static size_t build_parse_tree(struct bluebird_default_tokenizer *, struct bluebird_token_run *, struct bluebird_tree *);

static struct bluebird_tree *bluebird_tree_create_empty(void) {
    return calloc(1, sizeof(struct bluebird_tree));
}

struct bluebird_tree *bluebird_tree_create_from_string(const char *string) {
    struct bluebird_tree *tree = bluebird_tree_create_empty();
    tree->string = string;
    tree->next_offset = 1;
    struct bluebird_default_tokenizer tokenizer = {
        .text = string,
        .info = tree,
    };
    struct bluebird_token_run *token_run = 0;
    struct fill_run_continuation c = {
        .capacity = 8,
        .depth = 1,
    };
    c.stack = calloc(c.capacity, sizeof(struct fill_run_state));
    c.stack[0].state = 0;
    uint16_t failing_index = 0;
    while (bluebird_default_tokenizer_advance(&tokenizer, &token_run)) {
        if (!fill_run_states(token_run, &c, &failing_index)) {
            free(c.stack);
            tree->error = ERROR_UNEXPECTED_TOKEN;
            find_token_range(&tokenizer, token_run, failing_index, &tree->error_range.start, &tree->error_range.end);
            return tree;
        }
    }
    uint32_t final_state = c.stack[c.depth - 1].state;
    free(c.stack);
    if (string[tokenizer.offset] != '\0') {
        tree->error = ERROR_INVALID_TOKEN;
        estimate_next_token_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        return tree;
    }
    switch (final_state) {
    case 0:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 11:
    case 13:
    case 16:
    case 18:
    case 19:
    case 51:
    case 58:
        break;
    default:
        tree->error = ERROR_MORE_INPUT_NEEDED;
        find_end_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        return tree;
    }
    tree->root_offset = build_parse_tree(&tokenizer, token_run, tree);
    return tree;
}
static struct bluebird_tree *bluebird_tree_create_with_error(enum bluebird_error e) {
    struct bluebird_tree *tree = bluebird_tree_create_empty();
    tree->error = e;
    return tree;
}
struct bluebird_tree *bluebird_tree_create_from_file(FILE *file) {
    if (!file)
        return bluebird_tree_create_with_error(ERROR_INVALID_FILE);
    char *str = 0;
    size_t len = 32;
    size_t off = 0;
    while (true) {
        len = len * 3 / 2;
        char *s = realloc(str, len * 3 / 2);
        if (!s) {
            free(str);
            return 0;
        }
        str = s;
        off += fread(str + off, 1, len - off, file);
        if (off < len) {
            str[off] = '\0';
            break;
        }
    }
    struct bluebird_tree *tree = bluebird_tree_create_from_string(str);
    if (!tree) {
        free(str);
        return 0;
    }
    tree->owns_string = true;
    return tree;
}
enum bluebird_error bluebird_tree_get_error(struct bluebird_tree *tree, struct source_range *error_range) {
    if (error_range)
        *error_range = tree->error_range;
    return tree->error;
}
void bluebird_tree_destroy(struct bluebird_tree *tree) {
    if (tree->owns_string)
        free((void *)tree->string);
    free(tree->parse_tree);
    free(tree->identifier_tokens);
    free(tree->number_tokens);
    for (uint32_t i = 0; i < tree->number_of_string_tokens; ++i) {
        if (tree->string_tokens[i].has_escapes)
            free((void *)tree->string_tokens[i].string);
    }
    free(tree->string_tokens);
    free(tree);
}
static void grow_cont_stack(struct fill_run_continuation *cont) {
    size_t new_capacity = (cont->capacity + 2) * 3 / 2;
    if (new_capacity <= cont->capacity)
        abort();
    struct fill_run_state *new_states = realloc(cont->stack, new_capacity * sizeof(struct fill_run_state));
    if (!new_states)
        abort();
    cont->stack = new_states;
    cont->capacity = new_capacity;
}
static bool fill_run_states(struct bluebird_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index) {
    uint16_t token_index = 0;
    uint16_t number_of_tokens = run->number_of_tokens;
    struct fill_run_state top = cont->stack[cont->depth - 1];
    if (top.state == 0) {
        // This is unnecessary, but it avoids a compiler warning about unused labels.
        goto state_0;
    }
start:
    switch (top.state) {
    case 0:
state_0: {
        if (token_index >= number_of_tokens) {
            top.state = 0;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 0;
        token_index++;
        switch (token) {
        case 20: goto state_1;
        case 21: goto state_2;
        default: token_index--; break;
        }
        break;
    }
    case 1:
state_1: {
        if (token_index >= number_of_tokens) {
            top.state = 1;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 1;
        token_index++;
        switch (token) {
        case 23: goto state_58;
        default: token_index--; break;
        }
        break;
    }
    case 2:
state_2: {
        if (token_index >= number_of_tokens) {
            top.state = 2;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 2;
        token_index++;
        switch (token) {
        case 0: goto state_3;
        default: token_index--; break;
        }
        break;
    }
    case 3:
state_3: {
        if (token_index >= number_of_tokens) {
            top.state = 3;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 3;
        token_index++;
        switch (token) {
        case 21: goto state_4;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 3;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 4:
state_4: {
        if (token_index >= number_of_tokens) {
            top.state = 4;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 4;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 10: goto state_14;
        case 11: goto state_15;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_1;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 4;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 5:
state_5: {
        if (token_index >= number_of_tokens) {
            top.state = 5;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 5;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_1;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 5;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 6:
state_6: {
        if (token_index >= number_of_tokens) {
            top.state = 6;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 6;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_1;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 6;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 7:
state_7: {
        if (token_index >= number_of_tokens) {
            top.state = 7;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 7;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_1;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 7;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 8:
state_8: {
        if (token_index >= number_of_tokens) {
            top.state = 8;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 8;
        token_index++;
        switch (token) {
        case 21: goto state_19;
        default: token_index--; break;
        }
        break;
    }
    case 9:
state_9: {
        if (token_index >= number_of_tokens) {
            top.state = 9;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 9;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_1;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 9;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 10:
state_10: {
        if (token_index >= number_of_tokens) {
            top.state = 10;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 10;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_1;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 10;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 11:
state_11: {
        if (token_index >= number_of_tokens) {
            top.state = 11;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 11;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_1;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 11;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 12:
state_12: {
        if (token_index >= number_of_tokens) {
            top.state = 12;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 12;
        token_index++;
        switch (token) {
        case 21: goto state_4;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 12;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 13:
state_13: {
        if (token_index >= number_of_tokens) {
            top.state = 13;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 13;
        token_index++;
        switch (token) {
        case 0: goto state_3;
        case 1: goto state_8;
        case 10: goto state_14;
        case 11: goto state_15;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_1;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 13;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 14:
state_14: {
        if (token_index >= number_of_tokens) {
            top.state = 14;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 14;
        token_index++;
        switch (token) {
        case 1: goto state_17;
        default: token_index--; break;
        }
        break;
    }
    case 15:
state_15: {
        if (token_index >= number_of_tokens) {
            top.state = 15;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 15;
        token_index++;
        switch (token) {
        case 21: goto state_16;
        default: token_index--; break;
        }
        break;
    }
    case 16:
state_16: {
        if (token_index >= number_of_tokens) {
            top.state = 16;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 16;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_1;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 16;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 17:
state_17: {
        if (token_index >= number_of_tokens) {
            top.state = 17;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 17;
        token_index++;
        switch (token) {
        case 21: goto state_18;
        default: token_index--; break;
        }
        break;
    }
    case 18:
state_18: {
        if (token_index >= number_of_tokens) {
            top.state = 18;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 18;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 10: goto state_14;
        case 11: goto state_15;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_1;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 18;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 19:
state_19: {
        if (token_index >= number_of_tokens) {
            top.state = 19;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 19;
        token_index++;
        switch (token) {
        case 2: goto state_20;
        case 20: goto state_1;
        case 21: goto state_21;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 19;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 20:
state_20: {
        if (token_index >= number_of_tokens) {
            top.state = 20;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 20;
        token_index++;
        switch (token) {
        case 3: goto state_35;
        case 4: goto state_36;
        case 5: goto state_37;
        default: token_index--; break;
        }
        break;
    }
    case 21:
state_21: {
        if (token_index >= number_of_tokens) {
            top.state = 21;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 21;
        token_index++;
        switch (token) {
        case 0: goto state_3;
        case 1: goto state_8;
        case 10: goto state_30;
        case 11: goto state_31;
        case 16: goto state_25;
        case 17: goto state_26;
        case 18: goto state_27;
        case 19: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 21;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 22:
state_22: {
        if (token_index >= number_of_tokens) {
            top.state = 22;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 22;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_25;
        case 17: goto state_26;
        case 18: goto state_27;
        case 19: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 22;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 23:
state_23: {
        if (token_index >= number_of_tokens) {
            top.state = 23;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 23;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_25;
        case 17: goto state_26;
        case 18: goto state_27;
        case 19: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 23;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 24:
state_24: {
        if (token_index >= number_of_tokens) {
            top.state = 24;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 24;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_25;
        case 17: goto state_26;
        case 18: goto state_27;
        case 19: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 24;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 25:
state_25: {
        if (token_index >= number_of_tokens) {
            top.state = 25;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 25;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_25;
        case 17: goto state_26;
        case 18: goto state_27;
        case 19: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 25;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 26:
state_26: {
        if (token_index >= number_of_tokens) {
            top.state = 26;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 26;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_25;
        case 17: goto state_26;
        case 18: goto state_27;
        case 19: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 26;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 27:
state_27: {
        if (token_index >= number_of_tokens) {
            top.state = 27;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 27;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_25;
        case 17: goto state_26;
        case 18: goto state_27;
        case 19: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 27;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 28:
state_28: {
        if (token_index >= number_of_tokens) {
            top.state = 28;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 28;
        token_index++;
        switch (token) {
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 28;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 29:
state_29: {
        if (token_index >= number_of_tokens) {
            top.state = 29;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 29;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 10: goto state_30;
        case 11: goto state_31;
        case 16: goto state_25;
        case 17: goto state_26;
        case 18: goto state_27;
        case 19: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 29;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 30:
state_30: {
        if (token_index >= number_of_tokens) {
            top.state = 30;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 30;
        token_index++;
        switch (token) {
        case 1: goto state_33;
        default: token_index--; break;
        }
        break;
    }
    case 31:
state_31: {
        if (token_index >= number_of_tokens) {
            top.state = 31;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 31;
        token_index++;
        switch (token) {
        case 21: goto state_32;
        default: token_index--; break;
        }
        break;
    }
    case 32:
state_32: {
        if (token_index >= number_of_tokens) {
            top.state = 32;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 32;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 16: goto state_25;
        case 17: goto state_26;
        case 18: goto state_27;
        case 19: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 32;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 33:
state_33: {
        if (token_index >= number_of_tokens) {
            top.state = 33;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 33;
        token_index++;
        switch (token) {
        case 21: goto state_34;
        default: token_index--; break;
        }
        break;
    }
    case 34:
state_34: {
        if (token_index >= number_of_tokens) {
            top.state = 34;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 34;
        token_index++;
        switch (token) {
        case 1: goto state_8;
        case 10: goto state_30;
        case 11: goto state_31;
        case 16: goto state_25;
        case 17: goto state_26;
        case 18: goto state_27;
        case 19: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 34;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 35:
state_35: {
        if (token_index >= number_of_tokens) {
            top.state = 35;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 35;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 35;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 36:
state_36: {
        if (token_index >= number_of_tokens) {
            top.state = 36;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 36;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 36;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 37:
state_37: {
        if (token_index >= number_of_tokens) {
            top.state = 37;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 37;
        token_index++;
        switch (token) {
        case 6: goto state_38;
        case 7: goto state_39;
        case 8: goto state_40;
        case 9: goto state_41;
        default: token_index--; break;
        }
        break;
    }
    case 38:
state_38: {
        if (token_index >= number_of_tokens) {
            top.state = 38;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 38;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 38;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 39:
state_39: {
        if (token_index >= number_of_tokens) {
            top.state = 39;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 39;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 39;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 40:
state_40: {
        if (token_index >= number_of_tokens) {
            top.state = 40;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 40;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 40;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 41:
state_41: {
        if (token_index >= number_of_tokens) {
            top.state = 41;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 41;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 41;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 42:
state_42: {
        if (token_index >= number_of_tokens) {
            top.state = 42;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 42;
        token_index++;
        switch (token) {
        case 1: goto state_46;
        case 10: goto state_53;
        case 11: goto state_54;
        case 16: goto state_47;
        case 17: goto state_48;
        case 18: goto state_49;
        case 19: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 42;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 43:
state_43: {
        if (token_index >= number_of_tokens) {
            top.state = 43;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 43;
        token_index++;
        switch (token) {
        case 1: goto state_46;
        case 16: goto state_47;
        case 17: goto state_48;
        case 18: goto state_49;
        case 19: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 43;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 44:
state_44: {
        if (token_index >= number_of_tokens) {
            top.state = 44;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 44;
        token_index++;
        switch (token) {
        case 1: goto state_46;
        case 16: goto state_47;
        case 17: goto state_48;
        case 18: goto state_49;
        case 19: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 44;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 45:
state_45: {
        if (token_index >= number_of_tokens) {
            top.state = 45;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 45;
        token_index++;
        switch (token) {
        case 1: goto state_46;
        case 16: goto state_47;
        case 17: goto state_48;
        case 18: goto state_49;
        case 19: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 45;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 46:
state_46: {
        if (token_index >= number_of_tokens) {
            top.state = 46;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 46;
        token_index++;
        switch (token) {
        case 21: goto state_51;
        default: token_index--; break;
        }
        break;
    }
    case 47:
state_47: {
        if (token_index >= number_of_tokens) {
            top.state = 47;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 47;
        token_index++;
        switch (token) {
        case 1: goto state_46;
        case 16: goto state_47;
        case 17: goto state_48;
        case 18: goto state_49;
        case 19: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 47;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 48:
state_48: {
        if (token_index >= number_of_tokens) {
            top.state = 48;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 48;
        token_index++;
        switch (token) {
        case 1: goto state_46;
        case 16: goto state_47;
        case 17: goto state_48;
        case 18: goto state_49;
        case 19: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 48;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 49:
state_49: {
        if (token_index >= number_of_tokens) {
            top.state = 49;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 49;
        token_index++;
        switch (token) {
        case 1: goto state_46;
        case 16: goto state_47;
        case 17: goto state_48;
        case 18: goto state_49;
        case 19: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 49;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 50:
state_50: {
        if (token_index >= number_of_tokens) {
            top.state = 50;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 50;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 50;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 51:
state_51: {
        if (token_index >= number_of_tokens) {
            top.state = 51;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 51;
        token_index++;
        switch (token) {
        case 2: goto state_20;
        case 20: goto state_1;
        case 21: goto state_52;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 51;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 52:
state_52: {
        if (token_index >= number_of_tokens) {
            top.state = 52;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 52;
        token_index++;
        switch (token) {
        case 0: goto state_3;
        case 1: goto state_46;
        case 10: goto state_53;
        case 11: goto state_54;
        case 16: goto state_47;
        case 17: goto state_48;
        case 18: goto state_49;
        case 19: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 52;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 53:
state_53: {
        if (token_index >= number_of_tokens) {
            top.state = 53;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 53;
        token_index++;
        switch (token) {
        case 1: goto state_56;
        default: token_index--; break;
        }
        break;
    }
    case 54:
state_54: {
        if (token_index >= number_of_tokens) {
            top.state = 54;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 54;
        token_index++;
        switch (token) {
        case 21: goto state_55;
        default: token_index--; break;
        }
        break;
    }
    case 55:
state_55: {
        if (token_index >= number_of_tokens) {
            top.state = 55;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 55;
        token_index++;
        switch (token) {
        case 1: goto state_46;
        case 16: goto state_47;
        case 17: goto state_48;
        case 18: goto state_49;
        case 19: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 55;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 56:
state_56: {
        if (token_index >= number_of_tokens) {
            top.state = 56;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 56;
        token_index++;
        switch (token) {
        case 21: goto state_57;
        default: token_index--; break;
        }
        break;
    }
    case 57:
state_57: {
        if (token_index >= number_of_tokens) {
            top.state = 57;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 57;
        token_index++;
        switch (token) {
        case 1: goto state_46;
        case 10: goto state_53;
        case 11: goto state_54;
        case 16: goto state_47;
        case 17: goto state_48;
        case 18: goto state_49;
        case 19: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 57;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 58:
state_58: {
        if (token_index >= number_of_tokens) {
            top.state = 58;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 58;
        token_index++;
        switch (token) {
        case 20: goto state_1;
        case 21: goto state_2;
        default: token_index--; break;
        }
        break;
    }
    case 59:
state_59: {
        if (!(3 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 59;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 59;
        token_index++;
        switch (token) {
        case 12: goto state_60;
        case 14: goto state_61;
        default: token_index--; break;
        }
        break;
    }
    case 60:
state_60: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 60;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 60;
        token_index++;
        switch (token) {
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 60;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 61:
state_61: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 61;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 61;
        token_index++;
        switch (token) {
        case 23: goto state_62;
        default: token_index--; break;
        }
        break;
    }
    case 62:
state_62: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 62;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 62;
        token_index++;
        switch (token) {
        case 21: goto state_63;
        case 23: goto state_64;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 62;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 63:
state_63: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 63;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 63;
        token_index++;
        switch (token) {
        case 10: goto state_74;
        case 11: goto state_75;
        case 16: goto state_67;
        case 17: goto state_68;
        case 18: goto state_69;
        case 19: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 63;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 64:
state_64: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 64;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 64;
        token_index++;
        switch (token) {
        case 15: goto state_72;
        case 16: goto state_67;
        case 17: goto state_68;
        case 18: goto state_69;
        case 19: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 64;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 65:
state_65: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 65;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 65;
        token_index++;
        switch (token) {
        case 16: goto state_67;
        case 17: goto state_68;
        case 18: goto state_69;
        case 19: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 65;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 66:
state_66: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 66;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 66;
        token_index++;
        switch (token) {
        case 16: goto state_67;
        case 17: goto state_68;
        case 18: goto state_69;
        case 19: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 66;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 67:
state_67: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 67;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 67;
        token_index++;
        switch (token) {
        case 16: goto state_67;
        case 17: goto state_68;
        case 18: goto state_69;
        case 19: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 67;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 68:
state_68: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 68;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 68;
        token_index++;
        switch (token) {
        case 16: goto state_67;
        case 17: goto state_68;
        case 18: goto state_69;
        case 19: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 68;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 69:
state_69: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 69;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 69;
        token_index++;
        switch (token) {
        case 16: goto state_67;
        case 17: goto state_68;
        case 18: goto state_69;
        case 19: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 69;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 70:
state_70: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 70;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 70;
        token_index++;
        switch (token) {
        case 21: goto state_63;
        case 23: goto state_73;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 70;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 71:
state_71: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 71;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 71;
        token_index++;
        switch (token) {
        case 15: goto state_72;
        case 16: goto state_67;
        case 17: goto state_68;
        case 18: goto state_69;
        case 19: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 71;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 72:
state_72: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (cont->depth == 0)
            break;
        cont->depth--;
        top = cont->stack[cont->depth - 1];
        run->tokens[token_index] = 25;
        goto start;
    }
    case 73:
state_73: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 73;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 73;
        token_index++;
        switch (token) {
        case 16: goto state_67;
        case 17: goto state_68;
        case 18: goto state_69;
        case 19: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 73;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 74:
state_74: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 74;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 74;
        token_index++;
        switch (token) {
        case 1: goto state_77;
        default: token_index--; break;
        }
        break;
    }
    case 75:
state_75: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 75;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 75;
        token_index++;
        switch (token) {
        case 21: goto state_76;
        default: token_index--; break;
        }
        break;
    }
    case 76:
state_76: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 76;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 76;
        token_index++;
        switch (token) {
        case 16: goto state_67;
        case 17: goto state_68;
        case 18: goto state_69;
        case 19: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 76;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 77:
state_77: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 77;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 77;
        token_index++;
        switch (token) {
        case 21: goto state_78;
        default: token_index--; break;
        }
        break;
    }
    case 78:
state_78: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 78;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 78;
        token_index++;
        switch (token) {
        case 10: goto state_74;
        case 11: goto state_75;
        case 16: goto state_67;
        case 17: goto state_68;
        case 18: goto state_69;
        case 19: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 78;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 79:
state_79: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 79;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 79;
        token_index++;
        switch (token) {
        case 10: goto state_88;
        case 11: goto state_89;
        case 13: goto state_83;
        case 16: goto state_84;
        case 17: goto state_85;
        case 18: goto state_86;
        case 19: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 79;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 80:
state_80: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 80;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 80;
        token_index++;
        switch (token) {
        case 13: goto state_83;
        case 16: goto state_84;
        case 17: goto state_85;
        case 18: goto state_86;
        case 19: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 80;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 81:
state_81: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 81;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 81;
        token_index++;
        switch (token) {
        case 13: goto state_83;
        case 16: goto state_84;
        case 17: goto state_85;
        case 18: goto state_86;
        case 19: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 81;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 82:
state_82: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 82;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 82;
        token_index++;
        switch (token) {
        case 13: goto state_83;
        case 16: goto state_84;
        case 17: goto state_85;
        case 18: goto state_86;
        case 19: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 82;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 83:
state_83: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (cont->depth == 0)
            break;
        cont->depth--;
        top = cont->stack[cont->depth - 1];
        run->tokens[token_index] = 24;
        goto start;
    }
    case 84:
state_84: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 84;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 84;
        token_index++;
        switch (token) {
        case 13: goto state_83;
        case 16: goto state_84;
        case 17: goto state_85;
        case 18: goto state_86;
        case 19: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 84;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 85:
state_85: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 85;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 85;
        token_index++;
        switch (token) {
        case 13: goto state_83;
        case 16: goto state_84;
        case 17: goto state_85;
        case 18: goto state_86;
        case 19: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 85;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 86:
state_86: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 86;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 86;
        token_index++;
        switch (token) {
        case 13: goto state_83;
        case 16: goto state_84;
        case 17: goto state_85;
        case 18: goto state_86;
        case 19: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 86;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 87:
state_87: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 87;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 87;
        token_index++;
        switch (token) {
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 87;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 88:
state_88: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 88;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 88;
        token_index++;
        switch (token) {
        case 1: goto state_91;
        default: token_index--; break;
        }
        break;
    }
    case 89:
state_89: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 89;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 89;
        token_index++;
        switch (token) {
        case 21: goto state_90;
        default: token_index--; break;
        }
        break;
    }
    case 90:
state_90: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 90;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 90;
        token_index++;
        switch (token) {
        case 13: goto state_83;
        case 16: goto state_84;
        case 17: goto state_85;
        case 18: goto state_86;
        case 19: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 90;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 91:
state_91: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 91;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 91;
        token_index++;
        switch (token) {
        case 21: goto state_92;
        default: token_index--; break;
        }
        break;
    }
    case 92:
state_92: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 92;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 92;
        token_index++;
        switch (token) {
        case 10: goto state_88;
        case 11: goto state_89;
        case 13: goto state_83;
        case 16: goto state_84;
        case 17: goto state_85;
        case 18: goto state_86;
        case 19: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 92;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    }
    *failing_index = token_index;
    return false;
}
static const uint16_t actions[] = {
0,0,4096,0,4096,16385,0,4096,32768,32769,16385,0,4096,32768,32769,32770,32769,16385,0,4096,32768,32769,36864,40960,16384,0,4096,32768,32769,36864,
40960,16385,0,4096,32768,32769,36864,40960,16386,0,4096,32768,32769,36864,40961,16387,0,4096,32768,32769,36864,40962,0,4096,32768,32769,36864,40963,0,4096,
32768,32769,36864,45060,0,4096,32768,32769,36864,45061,0,4096,32768,32769,36864,45062,0,4096,32769,16384,0,4096,32770,32769,16385,0,16384,0,16385,0,
16389,0,16390,0,20480,8192,0,20480,8192,4096,0,20480,8192,4096,32768,12288,0,20480,8192,4096,32768,12289,0,20480,8192,4096,32768,12290,32768,12288,
0,20480,8192,4096,32768,12290,32768,12289,0,20480,8192,4096,32768,12290,32768,12290,0,20480,8192,4096,32768,12290,32768,12291,0,20480,8192,4096,32769,16385,
0,20480,8192,16385,0,20480,8192,16389,0,20480,45063,24576,40960,16384,0,20480,45063,24576,40960,16385,0,20480,45063,24576,40960,16386,0,20480,45063,24576,
40961,16387,0,20480,45063,24576,40962,0,20480,45063,24576,40963,0,20480,45063,24576,45060,0,20480,45063,24576,45061,0,20480,45063,24576,45062,0,20480,45064,
0,24576,40960,16384,0,24576,40960,16385,0,24576,40960,16386,0,24576,40961,16387,0,24576,40962,0,24576,40963,0,24576,45060,0,24576,45061,0,24576,
45062,0,32768,32769,16385,0,32768,32769,32770,32769,16385,0,32768,32769,36864,40960,16384,0,32768,32769,36864,40960,16385,0,32768,32769,36864,40960,16386,0,
32768,32769,36864,40961,16387,0,32768,32769,36864,40962,0,32768,32769,36864,40963,0,32768,32769,36864,45060,0,32768,32769,36864,45061,0,32768,32769,36864,45062,
0,32769,16384,0,36864,40960,16384,0,36864,40960,16385,0,36864,40960,16386,0,36864,40961,16387,0,36864,40962,0,36864,40963,0,36864,45060,0,36864,
45061,0,36864,45062,0,36868,40960,16384,0,36868,40960,16385,0,36868,40960,16386,0,36868,40961,16387,0,36868,40962,0,36868,40963,0,36868,45060,0,
36868,45061,0,36868,45062,0,};
struct action_table_entry {
    uint32_t target_nfa_state;
    uint32_t dfa_state;
    uint32_t dfa_symbol;
    uint32_t nfa_state;
    uint32_t actions;
    uint32_t push_nfa_state;
};
static const struct action_table_entry action_table[2048][3] = {
{{683,22,16,215,326},},{0},{{11,9,17,191,65},},{{689,87,24,703,227,132},{191,18,23,7,223},},{0},{0},{0},{0},{{31,18,24,703,276,7},},{{695,26,21,8,86},
{8,27,23,8,177},},{{3,67,19,9,208},},{{0,50,24,703,183,0},{0,39,25,711,188,0},},{{710,4,11,697,0},{31,3,25,711,281,7},},
{{1,50,23,0,316},},{{7,13,21,7,159},},{{7,13,0,693,97},},{{215,32,18,215,239},{215,23,17,215,236},},{{10,67,21,3,335},},
{{9,68,18,9,239},},{{685,11,24,703,320,7},{3,62,23,3,177},},{0},{{0,57,17,2,198},},{{9,64,18,9,239},{9,63,17,9,236},},
{0},{{31,11,21,7,252},},{{689,84,21,132,211},{10,71,25,711,354,3},},{{7,5,25,711,188,7},},{{215,24,21,8,211},},{{683,34,24,703,320,8},
{683,23,25,711,323,8},},{0},{{22,8,21,690,242},},{{690,25,1,683,0},{7,10,19,191,208},{3,68,17,9,198},},{{685,3,23,7,316},},
{0},{{1,55,21,0,304},},{{215,28,25,711,230,8},},{{11,18,16,191,59},{11,7,17,191,65},},{{689,92,25,711,230,132},},{{132,90,21,132,159},
{3,64,24,703,183,3},},{{709,29,10,695,0},{9,73,18,9,239},{1,51,24,703,320,0},},{{683,31,21,706,312},},{0},{0},{{191,4,17,191,236},},
{0},{{683,27,24,703,320,8},{0,41,25,711,188,0},},{0},{{1,42,21,0,304},},{{3,63,21,3,159},},{{8,34,18,215,203},{0,45,25,711,188,0},},
{{3,77,21,726,165},},{0},{{692,5,20,11,0},{9,65,21,3,211},},{{191,12,23,7,223},{11,11,16,191,59},},{0},{{3,73,24,703,183,3},},
{{215,25,23,8,223},{1,52,24,703,320,0},},{0},{{693,11,21,11,86},{2,56,21,721,215},},{{3,69,24,703,183,3},},{{685,4,16,191,326},},
{0},{0},{{10,73,25,711,354,3},{10,63,23,3,347},},{0},{{31,16,23,7,270},{2,47,17,2,236},},{{683,28,24,703,320,8},},{0},{{22,18,21,7,252},},
{{215,34,25,711,230,8},},{{31,4294967295U,4294967295U,22,1,22},},{0},{{3,78,24,703,183,3},},{{9,70,23,3,223},},{{0,40,23,0,177},},{0},{{132,80,21,132,159},},
{{685,16,17,191,329},{685,13,16,191,326},},{{687,85,21,132,335},},{0},{{22,10,25,711,281,7},},{{11,46,21,702,12},},{{689,86,16,689,233},},
{0},{{699,65,23,10,92},{132,92,25,711,188,132},},{0},{{689,82,16,689,233},{31,13,21,7,252},},{{697,10,21,7,86},},{0},{{132,79,23,132,177},},
{0},{{701,90,21,132,86},},{{1,49,21,0,304},},{{11,16,23,7,40},},{{191,6,18,191,239},},{{0,55,21,0,159},},{0},{{215,22,17,215,236},},
{{685,10,16,191,326},{191,10,18,191,239},},{{689,90,17,689,236},{689,79,16,689,233},},{{8,32,17,215,198},},{0},{{683,25,21,8,304},},
{0},{{22,13,18,191,296},},{{7,4,19,191,208},},{{11,13,21,7,19},},{{8,19,21,8,159},},{{22,9,18,191,296},{10,68,23,3,347},},
{{9,67,18,9,239},},{0},{0},{0},{0},{0},{{685,6,17,191,329},{11,6,23,7,40},},{{693,13,21,11,86},},{{8,27,19,215,208},},{0},{0},{0},{{1,45,24,703,320,0},},
{{7,16,16,191,193},{7,13,17,191,198},},{0},{0},{{22,16,18,191,296},{10,67,17,9,360},},{{1,41,23,0,316},},{0},{{31,7,25,711,281,7},},
{{132,86,18,689,203},{3,76,23,3,177},},{{9,63,21,3,211},},{{0,42,24,703,183,0},},{{191,15,21,710,219},{31,11,25,711,281,7},},
{{689,84,17,689,236},},{{11,10,18,191,71},},{{215,24,17,215,236},},{0},{{689,80,17,689,236},{2,57,23,0,223},},{{1,38,24,703,320,0},},
{{685,3,24,703,320,7},},{{683,19,21,8,304},},{0},{{22,4,17,191,291},{1,55,25,711,323,0},},{0},{{11,7,21,7,19},},{0},{{132,90,17,689,198},},
{0},{0},{0},{0},{{191,4,21,7,211},},{{687,80,18,689,363},},{{0,41,21,0,159},},{0},{0},{{685,12,24,703,320,7},{31,4,18,191,296},},{0},{{691,57,21,0,86},},
{{22,11,23,7,270},},{{9,65,17,9,236},},{{689,85,24,703,227,132},{2,39,25,711,230,0},},{0},{{725,30,1,709,0},},{0},{{687,79,16,689,357},},
{0},{{694,73,21,3,86},},{{191,16,18,191,239},},{{0,48,24,703,183,0},},{0},{{9,78,21,3,211},},{0},{{31,46,21,702,246},{2,47,21,0,211},},
{{0,52,23,0,177},},{{3,65,24,703,183,3},},{{22,18,17,191,291},{1,47,23,0,316},},{{685,9,24,703,320,7},},{0},{0},{{132,84,17,689,198},},
{0},{0},{{10,65,25,711,354,3},{1,43,16,2,326},},{{712,8,21,690,4},{132,80,17,689,198},{7,7,25,711,188,7},},{{191,9,18,191,239},
{11,12,23,7,40},},{{687,85,17,689,360},{215,26,18,215,239},},{{10,69,25,711,354,3},},{0},{{191,13,18,191,239},},{{31,9,17,191,291},},
{0},{{3,70,24,703,183,3},},{{683,21,18,215,332},},{{31,13,17,191,291},{2,42,23,0,223},},{0},{{691,35,21,0,86},{3,66,24,703,183,3},},
{{132,79,19,689,208},},{{8,24,19,215,208},},{0},{{1,49,17,2,329},{1,44,16,2,326},},{0},{0},{0},{0},{{215,22,21,8,211},},{0},{{689,90,21,132,211},
{31,6,23,7,270},},{{8,32,21,8,159},},{{9,62,23,3,223},},{{683,25,17,215,329},{0,43,16,2,193},},{0},{0},{{7,4,23,7,177},},
{{0,47,16,2,193},},{{691,40,21,0,86},},{0},{0},{{702,48,1,1,0},{11,9,25,711,53,7},},{{8,23,17,215,198},},{{3,71,17,9,198},},
{0},{0},{{685,6,21,7,304},},{{689,60,24,703,227,132},{31,18,16,191,286},},{{694,71,21,3,86},},{{215,19,23,8,223},},{0},{{2,45,18,2,239},},
{{701,60,21,132,86},{22,1,23,692,301},},{{191,7,23,7,223},},{{683,26,23,8,316},{215,32,25,711,230,8},},{0},{0},{{692,11,20,11,0},},
{{2,49,21,0,211},},{0},{{3,76,19,9,208},},{{9,63,25,711,230,3},},{0},{{685,18,18,191,332},},{0},{{132,82,25,711,188,132},},{0},{{683,34,16,215,326},
{683,23,17,215,329},},{{689,80,21,132,211},},{0},{{704,57,11,691,0},},{{0,49,16,2,193},},{0},{{22,4,21,7,252},},{0},{0},{0},{{3,64,16,9,193},},
{0},{0},{0},{0},{{191,4,25,711,230,7},{132,85,23,132,177},},{0},{{683,27,16,215,326},},{{1,42,24,703,320,0},},{0},{{2,48,23,0,223},},{{0,45,17,2,198},},
{0},{{687,84,17,689,360},},{0},{{701,84,21,132,86},},{{8,21,18,215,203},},{{3,73,16,9,193},},{{1,52,16,2,326},},{{2,43,21,0,211},},
{{22,7,18,191,296},{1,39,21,0,304},},{{690,13,1,685,0},{7,11,18,191,203},{3,69,16,9,193},},{{685,4,24,703,320,7},},
{{687,92,23,132,347},{215,29,18,215,239},},{0},{{9,78,17,9,236},{1,35,24,703,320,0},},{{11,4,18,191,71},},{{2,47,25,711,230,0},},
{{695,33,21,725,88},{0,52,19,2,208},},{{1,47,24,703,320,0},},{0},{0},{0},{0},{{132,84,21,132,159},{3,78,16,9,193},},{{0,40,24,703,183,0},},
{{31,5,25,711,281,7},},{{10,65,21,3,335},},{{7,7,21,7,159},},{{685,16,25,711,323,7},{685,13,24,703,320,7},},{0},{{22,10,18,191,296},},
{{1,36,24,703,320,0},},{0},{{689,86,24,703,227,132},{31,9,21,7,252},},{{132,92,18,689,203},{3,70,23,3,177},},{0},{{683,32,23,8,316},},
{{689,82,24,703,227,132},{685,5,23,7,316},},{0},{0},{0},{{8,24,23,8,177},{0,51,24,703,183,0},},{0},{{697,17,21,720,88},},{0},{{683,29,25,711,323,8},
{0,55,24,703,183,0},},{{7,12,21,7,159},},{0},{{215,22,25,711,230,8},},{{685,10,24,703,320,7},},{{716,92,10,701,0},{691,44,21,0,86},},
{0},{{1,57,24,703,320,0},},{{687,86,18,689,363},},{0},{{10,64,23,3,347},},{0},{{687,90,18,689,363},},{{683,22,23,8,316},},{0},{0},{0},{{8,23,21,8,159},
{0,35,25,711,188,0},},{{132,60,21,132,159},{3,71,21,3,159},},{{22,5,23,7,270},{10,75,21,715,343},},{{9,76,18,9,239},},
{{689,60,23,132,223},},{{7,9,19,191,208},},{{3,67,24,703,183,3},},{0},{{0,39,21,0,159},},{{31,3,21,7,252},},{{702,43,1,1,0},},
{0},{{703,80,13,687,0},{215,32,21,8,211},},{0},{{10,67,25,711,354,3},},{{685,11,17,191,329},},{{31,7,18,191,296},{2,49,17,2,236},},
{{0,57,24,703,183,0},},{{0,20,4,713,107},},{0},{{31,11,18,191,296},},{{10,71,16,9,357},},{{7,5,18,191,203},},{{132,82,21,132,159},},
{{215,24,25,711,230,8},},{{683,23,21,8,304},},{{1,38,23,0,316},},{{3,68,24,703,183,3},},{0},{{704,42,11,691,0},},{{8,22,18,215,203},},
{0},{{685,7,16,191,326},},{{689,92,16,689,233},},{{8,26,18,215,203},},{{132,90,25,711,188,132},},{0},{{2,44,23,0,223},},{{10,78,16,9,357},},
{0},{{132,85,19,689,208},},{0},{{701,80,21,132,86},{10,66,16,9,357},},{{692,51,20,11,0},{9,69,23,3,223},},{{132,81,19,689,208},
{3,63,18,9,203},},{0},{{0,45,21,0,159},},{0},{{687,84,21,132,335},},{{11,11,25,711,53,7},},{{689,85,16,689,233},},{0},{{215,25,16,215,233},},
{0},{{689,81,16,689,233},{2,43,17,2,236},},{{1,39,25,711,323,0},},{0},{0},{{8,25,21,8,159},},{{10,73,16,9,357},},{0},{0},{0},{{3,65,21,3,159},},
{0},{{215,34,16,215,233},},{{685,9,16,191,326},},{0},{0},{{215,21,23,8,223},},{0},{{31,5,21,7,252},{2,55,18,2,239},},{{10,65,17,9,360},
{1,43,24,703,320,0},},{{132,80,25,711,188,132},{7,7,17,191,198},},{0},{0},{{10,69,17,9,360},},{{9,66,18,9,239},},{0},{0},{0},{0},{0},{{31,13,25,711,281,7},},
{{3,66,19,9,208},},{{703,79,13,687,0},},{0},{{0,36,23,0,177},},{0},{{1,49,25,711,323,0},{1,44,24,703,320,0},},{{191,6,25,711,230,7},},
{{695,25,21,8,86},},{{7,12,25,711,188,7},},{{10,76,23,3,347},{1,40,24,703,320,0},},{0},{{689,90,24,703,227,132},{689,79,25,711,230,132},},
{0},{0},{{9,71,18,9,239},},{{683,25,25,711,323,8},{0,43,24,703,183,0},},{{22,13,21,7,252},{10,64,24,703,351,3},},{{3,75,21,715,171},},
{0},{{0,47,24,703,183,0},},{{8,19,25,711,188,8},},{0},{0},{{689,87,21,132,211},},{{719,58,4294967295U,719,0,22},{8,23,25,711,188,8},{0,35,21,0,159},},
{{691,51,21,0,86},{132,60,25,711,188,132},{3,71,25,711,188,3},},{0},{{685,6,24,703,320,7},},{{2,41,25,711,230,0},},{{7,9,23,7,177},},
{0},{0},{{2,45,25,711,230,0},},{{1,45,17,2,329},},{{694,67,21,3,86},},{{11,17,21,720,26},},{{215,32,17,215,236},{215,23,18,215,239},},
{0},{{9,68,21,3,211},},{{685,11,21,7,304},{191,11,23,7,223},},{0},{0},{0},{{687,87,23,132,347},{0,42,17,2,198},},{{693,6,21,11,86},
{685,18,25,711,323,7},},{{689,84,24,703,227,132},{22,12,23,7,270},},{0},{{132,82,17,689,198},},{0},{{689,80,24,703,227,132},},{0},{0},{0},{{683,19,25,711,323,8},
{0,49,24,703,183,0},},{{697,4,21,7,86},{1,55,18,2,332},},{0},{{11,7,18,191,71},},{0},{0},{{9,73,23,3,223},},{0},{0},{0},{{7,17,21,720,165},},
{{687,80,21,132,335},},{0},{{2,35,25,711,230,0},},{{1,42,16,2,326},},{{132,81,23,132,177},},{0},{{699,68,23,10,92},{7,6,17,191,198},},
{0},{{687,84,25,711,354,132},},{{11,11,21,7,19},},{{2,52,18,2,239},{2,39,21,0,211},},{0},{0},{{687,79,25,711,354,132},},{0},{0},{{191,16,21,7,211},},
{{0,48,17,2,198},},{{8,25,17,215,198},},{{10,63,18,9,363},},{{9,78,25,711,230,3},{1,48,23,0,316},},{0},{{703,82,13,687,0},
{8,29,17,215,198},},{{705,52,10,691,0},{7,18,18,191,203},{3,65,17,9,198},},{{1,47,16,2,326},},{0},{{191,5,18,191,239},},
{0},{0},{{687,81,23,132,347},},{0},{{31,5,17,191,291},},{0},{{685,13,21,7,304},},{{215,26,25,711,230,8},{0,44,16,2,193},},{0},{{10,69,21,3,335},},
{0},{{689,86,23,132,223},},{0},{0},{0},{0},{0},{{3,66,23,3,177},},{0},{0},{0},{{1,44,23,0,316},},{{11,16,18,191,71},},{0},{{683,29,17,215,329},{0,55,16,2,193},},
{0},{0},{{685,10,23,7,316},{191,10,21,7,211},},{0},{{8,32,18,215,203},},{0},{{1,57,16,2,326},},{0},{{22,13,17,191,291},},{{690,22,1,683,0},
{3,61,23,724,155},},{{11,13,18,191,71},},{{215,27,23,8,223},},{{22,9,17,191,291},},{{9,67,23,3,223},},{{11,9,18,191,71},},
{{689,87,25,711,230,132},},{0},{0},{0},{0},{{31,18,23,7,270},{2,41,21,0,211},},{0},{{3,67,16,9,193},},{{0,50,25,711,188,0},{0,39,24,703,183,0},},
{0},{{1,45,21,0,304},},{{7,16,23,7,177},},{0},{0},{{22,16,23,7,270},},{{9,68,17,9,236},{1,41,24,703,320,0},},{{685,11,25,711,323,7},},
{{2,49,25,711,230,0},},{{0,57,16,2,193},},{{9,64,17,9,236},{9,63,18,9,239},},{{0,42,21,0,159},},{{685,18,21,7,304},},
{{10,71,24,703,351,3},},{0},{0},{0},{0},{0},{{7,10,18,191,203},{3,68,16,9,193},},{{687,60,25,711,354,132},{0,49,23,0,177},},{0},{0},{{215,28,24,703,227,8},},
{{685,7,24,703,320,7},{11,18,23,7,40},},{{689,92,24,703,227,132},{2,40,23,0,223},},{0},{{1,51,25,711,323,0},},{0},{0},{{701,92,21,132,86},
{10,78,24,703,351,3},},{{191,4,16,191,233},{11,3,23,7,40},},{{687,80,17,689,360},},{{683,27,25,711,323,8},{0,41,24,703,183,0},},
{{693,16,21,11,86},{10,66,24,703,351,3},{2,35,21,0,211},},{0},{{690,5,1,685,0},{31,4,17,191,291},{2,48,16,2,233},},
{{8,34,19,215,208},{0,45,24,703,183,0},},{{713,51,2,712,2},{7,6,21,7,159},},{{22,11,18,191,296},{10,70,23,3,347},},
{{9,65,18,9,239},},{{11,11,17,191,65},},{{691,38,21,0,86},{8,21,25,711,188,8},},{{3,73,25,711,188,3},},{{215,25,24,703,227,8},
{1,52,23,0,316},},{{687,79,21,132,335},},{{689,81,24,703,227,132},{31,12,23,7,270},{2,43,25,711,230,0},},{{3,69,25,711,188,3},},
{{685,4,23,7,316},{191,16,17,191,236},},{{0,48,21,0,159},},{{0,37,9,722,137},},{{10,73,24,703,351,3},},{{11,4,21,7,19},},
{{2,47,16,2,233},},{{708,18,10,697,0},{8,29,21,8,159},{0,52,24,703,183,0},},{0},{{22,18,18,191,296},},{{215,34,24,703,227,8},},
{0},{{699,63,23,10,92},{7,3,23,7,177},},{{132,84,18,689,203},{3,78,23,3,177},},{0},{{683,24,23,8,316},},{{1,43,21,0,304},},
{{132,80,18,689,203},},{{685,16,16,191,326},{685,13,17,191,329},},{{703,90,13,687,0},{215,26,21,8,211},},{0},{{9,66,25,711,230,3},},
{{191,13,23,7,223},},{{690,27,1,683,0},},{{7,52,0,693,97},},{0},{0},{{2,42,16,2,233},},{{22,6,23,7,270},},{0},{0},{0},{{10,62,23,3,347},},
{{1,49,18,2,332},},{{11,5,23,7,40},},{{191,6,17,191,236},},{{687,82,18,689,363},{683,29,21,8,304},},{0},{{215,22,16,215,233},},
{{191,10,17,191,236},},{{689,90,16,689,233},{689,79,17,689,236},{31,6,18,191,296},},{0},{0},{{687,86,25,711,354,132},{0,43,23,0,177},},
{{31,10,18,191,296},},{{701,82,21,132,86},{10,64,16,9,357},},{{7,4,18,191,203},},{0},{0},{{22,9,21,7,252},{10,68,16,9,357},},
{0},{0},{{191,18,18,191,239},},{{699,78,23,10,92},{3,71,18,9,203},},{0},{{9,76,25,711,230,3},},{{685,6,16,191,326},},{0},{{8,27,18,215,203},},
{0},{0},{{2,45,17,2,236},},{{1,45,25,711,323,0},},{{7,16,19,191,208},{7,13,18,191,203},},{{683,26,18,215,332},{0,54,21,704,171},},
{0},{{10,67,16,9,357},},{0},{0},{0},{{132,86,19,689,208},},{{9,64,21,3,211},},{{0,42,25,711,188,0},},{{685,18,17,191,329},},{{689,84,16,689,233},},
{{11,10,17,191,65},},{{215,24,16,215,233},},{{683,23,18,215,332},},{{689,80,16,689,233},{31,15,21,710,264},{2,36,23,0,223},},
{0},{{685,3,25,711,323,7},},{{703,92,13,687,0},{0,49,19,2,208},},{0},{{22,4,18,191,296},},{0},{{689,92,23,132,223},{2,40,24,703,227,0},},
{0},{{132,90,18,689,203},},{{1,51,21,0,304},},{{0,38,24,703,183,0},},{0},{0},{0},{0},{{683,27,21,8,304},},{0},{0},{{31,4,21,7,252},},{{695,19,21,8,86},
{8,34,23,8,177},},{{7,6,25,711,188,7},},{0},{{191,12,25,711,230,7},},{{689,85,25,711,230,132},{2,39,24,703,227,0},},{{699,64,23,10,92},},
{{3,73,21,3,159},},{0},{{687,79,17,689,360},},{{22,7,21,7,252},},{0},{0},{{687,92,18,689,363},{215,29,23,8,223},{0,48,25,711,188,0},},
{{8,25,25,711,188,8},},{0},{{11,4,17,191,65},},{{31,16,18,191,296},},{{683,28,23,8,316},{8,29,25,711,188,8},},{{3,65,25,711,188,3},},
{{215,34,23,8,223},},{{685,9,25,711,323,7},},{{2,51,25,711,230,0},},{0},{{694,65,21,3,86},{3,78,19,9,208},},{0},{{2,55,25,711,230,0},},
{{10,65,24,703,351,3},{1,43,17,2,329},},{0},{0},{{687,85,18,689,363},{215,26,17,215,236},{0,44,24,703,183,0},},{{22,10,23,7,270},
{10,69,24,703,351,3},},{0},{0},{{31,9,18,191,296},},{0},{{692,58,20,11,0},},{{683,32,18,215,332},},{{689,82,23,132,223},{685,5,24,703,320,7},
{31,13,18,191,296},},{0},{0},{{132,79,18,689,203},},{{695,34,21,8,86},{8,24,16,215,193},},{{710,18,11,697,0},},{{697,6,21,7,86},},
{0},{{191,6,21,7,211},},{0},{{10,76,24,703,351,3},{1,40,23,0,316},},{0},{0},{{689,79,21,132,211},{11,4294967295U,4294967295U,22,2,22},{2,50,23,0,223},},
{{132,87,21,132,159},},{0},{{683,25,18,215,332},{0,43,19,2,208},},{0},{{22,13,25,711,281,7},},{0},{{687,90,21,132,335},{215,27,24,703,227,8},
{0,47,19,2,208},},{0},{{22,9,25,711,281,7},},{0},{0},{{695,21,21,8,86},{8,23,16,215,193},},{{705,57,10,691,0},},{0},{{9,76,21,3,211},},
{{191,3,23,7,223},{11,6,18,191,71},},{{7,9,16,191,193},},{0},{0},{0},{{2,45,21,0,211},},{{22,46,21,702,246},},{0},{{215,32,24,703,227,8},},
{0},{0},{{9,68,25,711,230,3},},{{689,91,21,718,215},{31,7,23,7,270},},{{691,56,21,721,88},},{{132,86,23,132,177},{3,76,18,9,203},},
{{697,12,21,7,86},{9,64,25,711,230,3},},{0},{0},{{690,10,1,685,0},{7,5,23,7,177},},{{11,10,21,7,19},},{0},{{709,21,10,695,0},
{683,34,23,8,316},},{{2,57,18,2,239},},{0},{0},{0},{{8,22,23,8,177},},{0},{{685,7,21,7,304},},{0},{0},{{3,64,19,9,208},},{0},{0},{{10,78,21,3,335},},
{0},{{191,4,24,703,227,7},},{{687,80,25,711,354,132},},{{683,27,17,215,329},},{{9,69,16,9,233},},{0},{{31,4,25,711,281,7},{2,48,24,703,227,0},},
{{721,53,1,705,0},{0,45,16,2,193},},{{691,42,21,0,86},},{{687,84,16,689,357},},{0},{0},{{8,21,17,215,198},},{{3,73,17,9,198},},
{0},{{689,81,21,132,211},},{{22,7,17,191,291},},{{690,24,1,683,0},{7,11,19,191,208},{3,69,17,9,198},},{{191,16,25,711,230,7},},
{0},{{10,73,23,3,347},{10,63,25,711,354,3},},{{9,78,16,9,233},{1,35,25,711,323,0},},{{694,69,21,3,86},},{{2,47,24,703,227,0},},
{{0,52,16,2,193},},{{1,47,25,711,323,0},},{0},{{31,1,23,692,301},},{{693,0,21,11,86},{2,51,21,0,211},},{0},{{687,81,16,689,357},},
{{0,40,25,711,188,0},},{0},{0},{{7,7,18,191,203},},{{685,16,24,703,320,7},{685,13,25,711,323,7},{191,9,23,7,223},},{0},{0},{{9,66,17,9,236},
{1,36,23,0,316},},{0},{{2,38,24,703,227,0},},{{132,92,19,689,208},},{0},{{683,21,23,8,316},},{{2,42,24,703,227,0},},{0},{{708,4,10,697,0},},
{0},{{0,36,24,703,183,0},},{0},{0},{0},{0},{0},{0},{{215,22,24,703,227,8},},{{191,10,25,711,230,7},},{0},{0},{{1,57,25,711,323,0},},{{687,86,17,689,360},},{0},{{7,4,25,711,188,7},},
{0},{{687,90,17,689,360},{0,47,23,0,177},},{0},{{701,86,21,132,86},{10,68,24,703,351,3},},{0},{0},{{0,35,24,703,183,0},},{{691,36,21,0,86},},
{0},{{9,76,17,9,236},},{0},{{8,27,25,711,188,8},},{{3,67,25,711,188,3},},{{215,19,24,703,227,8},},{{0,50,21,0,159},},{{1,45,18,2,332},},
{0},{{191,7,16,191,233},},{{215,23,23,8,223},},{{8,31,21,706,171},},{{10,67,24,703,351,3},},{{711,64,15,699,0},{685,11,18,191,332},
{191,11,16,191,233},},{{2,49,16,2,233},},{{0,57,23,0,177},},{0},{0},{0},{{10,71,23,3,347},},{{7,5,19,191,208},},{{11,10,25,711,53,7},},
{{215,24,24,703,227,8},},{0},{0},{{7,10,25,711,188,7},},{0},{{687,60,21,132,335},},{{8,22,19,215,208},},{0},{{685,7,17,191,329},},{{690,29,1,683,0},},
{{8,26,19,215,208},},{{3,64,23,3,177},},{{0,38,21,0,159},},{{2,44,16,2,233},},{{10,78,17,9,360},},{0},{{132,85,18,689,203},},
{0},{{10,66,17,9,360},},{0},{{132,81,18,689,203},{3,63,19,9,208},},{{685,12,23,7,316},},{{0,56,21,721,165},},{{22,11,25,711,281,7},},
{0},{0},{{689,85,17,689,236},{2,52,23,0,223},},{{8,21,21,8,159},},{{215,25,17,215,236},},{0},{{689,81,17,689,236},{2,43,16,2,233},},
{0},{{7,11,23,7,177},{3,69,21,3,159},},{{687,92,25,711,354,132},{0,48,18,2,203},},{0},{{697,16,21,7,86},{22,3,21,7,252},},
{{1,48,18,2,332},{1,35,21,0,304},},{{702,45,1,1,0},{11,4,25,711,53,7},},{0},{{7,18,21,7,159},},{0},{0},{{685,9,17,191,329},
{191,5,23,7,223},},{0},{0},{{215,21,16,215,233},{9,70,25,711,230,3},},{{726,74,1,714,0},},{{2,55,17,2,236},},{{10,65,16,9,357},
{1,43,25,711,323,0},},{{685,16,23,7,316},{191,9,24,703,227,7},},{{0,44,21,0,159},},{0},{{10,69,16,9,357},},{{9,66,21,3,211},},
{{694,62,21,3,86},},{0},{{694,76,21,3,86},{132,92,23,132,177},},{0},{0},{{685,5,16,191,326},},{{3,66,18,9,203},},{{132,79,25,711,188,132},},
{0},{{8,24,24,703,183,8},{0,51,23,0,177},},{0},{{11,16,17,191,65},{11,5,16,191,59},},{{191,6,24,703,227,7},},{{687,82,25,711,354,132},},
{{722,20,5,713,2},{8,28,23,8,177},{7,12,24,703,183,7},},{{22,17,21,720,258},{10,76,16,9,357},},{0},{{31,6,25,711,281,7},
{2,50,24,703,227,0},},{0},{0},{{1,57,21,0,304},},{{687,86,21,132,335},},{{711,71,15,699,0},{10,64,25,711,354,3},},{0},{{685,17,21,720,308},},
{{215,27,16,215,233},},{{683,22,18,215,332},{8,19,24,703,183,8},},{0},{{11,9,23,7,40},},{{191,18,25,711,230,7},},{{683,33,21,725,308},
{8,23,24,703,183,8},},{0},{{22,5,18,191,296},},{{191,3,24,703,227,7},},{{2,41,24,703,227,0},},{{8,27,21,8,159},{7,9,24,703,183,7},},
{{3,67,21,3,159},},{0},{{2,45,24,703,227,0},},{{1,50,21,0,304},},{0},{0},{{215,32,16,215,233},},{{10,67,23,3,347},},{0},{{3,62,25,711,188,3},},
{0},{{0,57,19,2,208},},{0},{{0,42,18,2,203},},{{693,19,21,11,86},{685,18,24,703,320,7},{31,11,23,7,270},},{{689,84,23,132,223},
{22,12,24,703,276,7},},{0},{{132,82,18,689,203},},{0},{{2,57,25,711,230,0},{2,36,24,703,227,0},},{0},{{7,10,21,7,159},{3,68,23,3,177},},
{{685,3,21,7,304},},{0},{0},{{215,28,23,8,223},},{{715,63,11,694,0},{11,18,18,191,71},},{0},{{695,27,21,8,86},{8,26,23,8,177},},
{0},{{718,88,1,716,0},},{0},{0},{0},{0},{0},{{10,66,21,3,335},{2,35,24,703,227,0},},{{22,15,21,710,264},{9,69,24,703,227,3},},{{3,63,23,3,177},},
{{8,34,16,215,193},},{{7,6,16,191,193},},{{10,70,24,703,351,3},},{{687,84,24,703,351,132},{9,65,23,3,223},},{{191,12,21,7,211},
{11,11,18,191,71},},{{689,85,21,132,211},},{0},{{215,25,21,8,211},},{0},{0},{{22,7,25,711,281,7},},{{685,4,18,191,332},},{{215,29,24,703,227,8},},
{{8,25,16,215,193},},{{22,3,25,711,281,7},{10,63,17,9,360},},{{9,78,24,703,227,3},},{{31,16,21,7,252},},{{8,29,16,215,193},},
{{7,18,17,191,198},{3,65,18,9,203},},{{22,18,23,7,270},{1,47,17,2,329},},{0},{{685,9,21,7,304},},{0},{0},{{687,81,24,703,351,132},
{9,70,21,3,211},},{{683,24,18,215,332},},{{693,4,21,11,86},{31,5,18,191,296},{2,55,21,0,211},},{{712,46,21,702,81},
{132,80,23,132,177},},{{685,13,18,191,332},{11,12,25,711,53,7},},{{215,26,24,703,227,8},{0,44,17,2,198},},{0},{0},{0},{{2,38,21,0,211},},
{{691,50,21,0,86},},{0},{0},{0},{{22,6,16,191,286},},{0},{{132,79,21,132,159},},{0},{0},{{1,49,23,0,316},},{{11,16,21,7,19},},{0},{{687,82,21,132,335},
{683,29,18,215,332},{0,55,19,2,208},},{0},{0},{0},{0},{{695,29,21,8,86},{8,32,19,215,208},},{{132,87,25,711,188,132},},{{9,71,23,3,223},
{1,57,17,2,329},},{{31,10,21,7,252},},{{22,13,16,191,286},},{{7,4,17,191,198},},{0},{{687,90,25,711,354,132},},{{22,9,16,191,286},
{10,68,21,3,335},},{{9,67,16,9,233},},{0},{{191,18,21,7,211},},{0},{{1,54,21,704,312},},{{215,31,21,706,219},},{{11,6,25,711,53,7},},
{0},{{8,27,17,215,198},},{{3,67,17,9,198},},{0},{{701,91,21,718,88},},{{1,50,25,711,323,0},},{{7,13,23,7,177},},{{191,7,24,703,227,7},},
{0},{{22,16,16,191,286},},{{9,68,16,9,233},{1,41,25,711,323,0},},{{191,11,24,703,227,7},{3,62,21,3,159},},{{2,49,24,703,227,0},},
{{717,92,11,701,0},{132,86,16,689,193},{3,76,21,3,159},},{{9,64,16,9,233},},{0},{{685,15,21,710,312},},{0},{0},{{215,24,23,8,223},},
{0},{{693,10,21,11,86},{2,57,21,0,211},},{0},{{7,10,17,191,198},{3,68,19,9,208},},{{687,60,24,703,351,132},{683,19,23,8,316},},
{{8,22,24,703,183,8},},{{1,55,23,0,316},},{0},{{685,7,25,711,323,7},{11,7,23,7,40},},{{8,26,24,703,183,8},},{{132,90,23,132,177},},
{{9,73,16,9,233},},{0},{{2,44,24,703,227,0},},{{702,42,1,1,0},{10,78,25,711,354,3},},{0},{{687,80,16,689,357},},{{0,41,23,0,177},},
{{10,66,25,711,354,3},},{{1,42,23,0,316},},{{690,16,1,685,0},{31,4,16,191,286},{2,48,17,2,236},},{{7,21,0,693,97},},
{0},{{22,11,17,191,291},},{0},{0},{{8,21,24,703,183,8},},{0},{{215,25,25,711,230,8},},{{687,79,18,689,363},},{{689,81,25,711,230,132},{2,43,24,703,227,0},},
{{7,11,24,703,183,7},},{{191,16,16,191,233},},{{687,92,17,689,360},},{{0,37,8,722,129},},{{10,63,21,3,335},},{0},{{31,16,17,191,291},
{2,47,23,0,223},},{{8,8,21,690,151},{0,52,25,711,188,0},},{0},{{1,47,21,0,304},},{{22,4294967295U,4294967295U,22,0,22},},{0},{0},{{132,84,19,689,208},},
{{215,21,24,703,227,8},},{{0,40,21,0,159},},{0},{{132,80,19,689,208},},{{191,9,16,191,233},{11,12,21,7,19},},{{687,85,23,132,347},},
{0},{{9,66,24,703,227,3},},{{191,13,16,191,233},},{{724,59,14,719,0},{689,86,18,689,239},},{0},{0},{{683,32,17,215,329},{683,21,16,215,326},},
{{689,82,18,689,239},{31,13,23,7,270},{2,42,17,2,236},},{0},{0},{{132,79,17,689,198},},{0},{{706,29,11,695,0},},{{692,19,20,11,0},
{1,44,18,2,332},},{{702,57,1,1,0},{11,16,25,711,53,7},{11,5,24,703,47,7},},{{191,6,16,191,233},},{{687,82,17,689,360},
{0,55,23,0,177},},{0},{{215,22,23,8,223},},{{685,10,18,191,332},{191,10,16,191,233},},{{690,7,1,685,0},{689,79,18,689,239},
{31,6,17,191,291},},{{8,32,23,8,177},},{{9,71,24,703,227,3},{9,62,21,3,211},},{{687,86,24,703,351,132},{683,25,23,8,316},},
{{31,10,17,191,291},},{{10,64,17,9,360},},{{699,66,23,10,92},{7,4,21,7,159},},{{716,79,10,701,0},{11,13,23,7,40},},
{{8,19,23,8,177},},{{10,68,17,9,360},},{0},{0},{{191,18,17,191,236},},{{3,71,19,9,208},},{{22,5,25,711,281,7},},{{9,76,24,703,227,3},},
{{11,6,21,7,19},},{{31,18,18,191,296},},{0},{0},{0},{{2,45,16,2,233},},{{715,78,11,694,0},{697,18,21,7,86},},{{7,16,18,191,203},
{7,13,19,191,208},},{{683,26,17,215,329},},{0},{0},{{1,41,21,0,304},},{{702,55,1,1,0},},{0},{{3,76,17,9,198},},{{9,63,23,3,223},},
{0},{{685,18,16,191,326},},{{690,21,1,683,0},},{{11,10,16,191,59},},{0},{{683,34,18,215,332},{0,46,21,702,145},},{{689,80,23,132,223},
{2,57,17,2,236},},{0},{0},{{0,49,18,2,203},},{0},{0},{0},{{2,40,25,711,230,0},},{0},{{694,70,21,3,86},{132,90,19,689,208},},{0},{{0,38,25,711,188,0},},
{0},{0},{{191,4,23,7,223},{132,85,25,711,188,132},},{0},{{683,27,18,215,332},},{0},{{132,81,25,711,188,132},{3,63,24,703,183,3},},{{2,48,21,0,211},},
{{8,34,24,703,183,8},{0,45,19,2,208},},{{7,6,24,703,183,7},},{{22,11,21,7,252},},{{191,12,24,703,227,7},},{{2,52,24,703,227,0},},
{0},{0},{{1,52,18,2,332},},{{31,12,25,711,281,7},{2,43,23,0,223},},{{697,9,21,7,86},},{{132,89,21,717,171},},{0},{{687,92,21,132,335},
{215,29,16,215,233},},{{8,25,24,703,183,8},},{{692,16,20,11,0},{9,78,23,3,223},{1,48,25,711,323,0},},{{11,4,16,191,59},},
{0},{{8,29,24,703,183,8},{0,52,21,0,159},},{{7,18,25,711,188,7},},{0},{{191,5,24,703,227,7},},{{723,61,23,724,90},{2,51,24,703,227,0},},
{{8,33,21,725,165},{7,3,24,703,183,7},},{{708,13,10,697,0},{132,84,23,132,177},{3,78,18,9,203},},{{683,24,25,711,323,8},},
{{2,55,24,703,227,0},},{{1,56,21,721,308},{1,43,18,2,332},},{{7,7,23,7,177},},{0},{{215,26,16,215,233},{0,44,25,711,188,0},},
{0},{0},{0},{0},{0},{0},{{683,32,21,8,304},},{{685,5,25,711,323,7},{2,42,21,0,211},},{{22,6,24,703,276,7},},{0},{0},{{8,24,17,215,198},},{0},{0},{0},{0},{0},{{10,76,25,711,354,3},},
{0},{{11,1,23,692,77},},{{689,90,23,132,223},{31,6,21,7,252},},{{694,64,21,3,86},},{0},{{0,43,18,2,203},},{0},{{22,13,24,703,276,7},
{10,64,21,3,335},},{{11,13,24,703,47,7},},{{215,27,25,711,230,8},{0,47,18,2,203},},{{683,22,25,711,323,8},},{{22,9,24,703,276,7},},
{{9,67,24,703,227,3},},{0},{{8,23,19,215,208},},{{132,60,23,132,177},{3,71,23,3,177},},{{22,5,21,7,252},},{0},{{685,6,23,7,316},
{11,6,17,191,65},},{{690,32,1,683,0},{7,9,17,191,198},},{0},{{215,19,21,8,211},},{0},{{31,3,23,7,270},},{0},{{191,7,21,7,211},},
{{683,26,21,8,304},{215,23,24,703,227,8},},{0},{{714,78,10,694,0},{22,16,24,703,276,7},},{{9,68,24,703,227,3},},{{2,49,23,0,223},},
{{691,45,21,0,86},},{{132,86,24,703,183,132},},{{9,64,24,703,227,3},},{{687,87,24,703,351,132},},{{10,71,18,9,363},},{{7,5,16,191,193},},
{0},{0},{{683,23,23,8,316},},{{1,38,21,0,304},},{0},{0},{0},{{691,48,21,0,86},{8,22,16,215,193},},{{22,4,23,7,270},},{{11,18,25,711,53,7},
{11,7,24,703,47,7},},{{689,92,18,689,239},},{{695,32,21,8,86},{8,26,16,215,193},},{{3,64,18,9,203},},{{9,73,24,703,227,3},},
{{2,44,21,0,211},},{{10,78,18,9,363},},{0},{{132,85,21,132,159},},{{703,81,13,687,0},{687,80,24,703,351,132},{215,33,21,725,215},},
{{10,66,18,9,363},},{{9,69,17,9,236},},{0},{{31,4,24,703,276,7},{2,48,25,711,230,0},},{{0,45,23,0,177},},{0},{0},{0},{{693,58,21,11,86},
{689,85,18,689,239},{31,8,21,690,242},},{{695,23,21,8,86},{8,21,16,215,193},},{{3,73,18,9,203},},{0},{{689,81,18,689,239},},
{{22,7,16,191,286},{1,39,23,0,316},},{{699,76,23,10,92},{7,11,16,191,193},{3,69,18,9,203},},{{191,16,24,703,227,7},},
{{8,25,23,8,177},},{{10,63,24,703,351,3},},{0},{0},{{31,16,25,711,281,7},},{{0,52,17,2,198},},{0},{{215,34,18,215,239},},{{685,9,18,191,332},},
{{689,89,21,717,219},},{0},{{687,81,17,689,360},{215,21,21,8,211},},{{695,28,21,8,86},},{{701,81,21,132,86},},{{10,65,23,3,347},},
{{690,4,1,685,0},{7,7,19,191,208},},{0},{{691,43,21,0,86},},{{22,10,16,191,286},},{{9,66,16,9,233},},{{191,13,24,703,227,7},
{11,8,21,690,7},},{{31,9,23,7,270},{2,38,25,711,230,0},},{{132,92,16,689,193},{3,70,21,3,159},},{0},{{683,32,25,711,323,8},
{683,21,24,703,320,8},},{{685,5,21,7,304},{2,42,25,711,230,0},},{0},{0},{0},{{8,24,21,8,159},{0,36,25,711,188,0},},{0},{0},{0},{0},{{8,28,24,703,183,8},
{7,12,23,7,177},},{{10,76,21,3,335},},{0},{{191,10,24,703,227,7},},{{8,32,24,703,183,8},},{0},{{9,71,16,9,233},},{{687,86,16,689,357},},
{{31,10,25,711,281,7},},{{702,52,1,1,0},{7,4,24,703,183,7},},{0},{{687,90,16,689,357},},{{683,22,21,8,304},},{{10,68,25,711,354,3},},
{0},{{690,26,1,683,0},},{{8,23,23,8,177},},{0},{{22,5,17,191,291},},{{9,76,16,9,233},},{{689,60,21,132,211},},{{8,27,24,703,183,8},
{7,9,21,7,159},},{0},{{215,19,25,711,230,8},},{{0,39,23,0,177},},{0},{{7,16,25,711,188,7},{7,13,24,703,183,7},},{{191,7,17,191,236},},
{{683,26,25,711,323,8},{215,32,23,8,223},},{0},{{9,68,23,3,223},},{{191,11,17,191,236},},{{31,7,16,191,286},},{0},{{703,84,13,687,0},
{3,76,25,711,188,3},},{0},{{31,11,16,191,286},},{{22,12,21,7,252},},{{691,52,21,0,86},},{{132,82,23,132,177},{11,10,24,703,47,7},},
{0},{{701,87,21,132,86},},{{692,6,20,11,0},},{{7,10,24,703,183,7},},{0},{0},{{22,4,24,703,276,7},{1,55,16,2,326},},{0},{{685,7,18,191,332},},
{0},{0},{0},{0},{{2,44,17,2,236},},{0},{0},{{132,85,17,689,198},{11,3,24,703,47,7},},{0},{0},{{9,69,21,3,211},},{{132,81,17,689,198},{3,63,16,9,193},},
{0},{{7,6,19,191,208},},{{22,11,24,703,276,7},},{{687,84,23,132,347},{9,65,24,703,227,3},},{{11,11,23,7,40},},{{690,9,1,685,0},
{2,52,16,2,233},{2,39,23,0,223},},{0},{{215,25,18,215,239},},{0},{0},{0},{0},{{687,92,24,703,351,132},{0,48,19,2,208},},{{8,25,19,215,208},
{0,37,7,722,121},},{{697,5,21,7,86},{10,73,18,9,363},},{{1,48,17,2,329},},{{11,4,24,703,47,7},},{{695,24,21,8,86},
{8,29,19,215,208},},{{7,15,21,710,171},{3,65,23,3,177},},{{22,18,24,703,276,7},},{0},{{191,5,16,191,233},},{0},{{132,84,24,703,183,132},},
{{687,81,21,132,335},{215,21,17,215,236},{9,70,24,703,227,3},},{{683,24,17,215,329},},{{31,5,23,7,270},{2,55,16,2,233},},
{0},{{685,13,23,7,316},{191,9,25,711,230,7},},{{687,85,24,703,351,132},{0,44,18,2,203},},{{699,69,23,10,92},},{0},{0},{{702,49,1,1,0},
{689,86,21,132,211},{31,9,24,703,276,7},},{0},{0},{0},{0},{{685,5,17,191,329},},{{3,66,17,9,198},},{{191,17,21,720,215},{132,79,24,703,183,132},},
{0},{{8,24,25,711,188,8},{0,36,21,0,159},},{{10,62,24,703,351,3},},{{11,16,16,191,59},{11,5,17,191,65},},{0},{{687,82,24,703,351,132},},
{0},{{10,76,17,9,360},},{{685,10,21,7,304},{191,10,23,7,223},},{{31,6,24,703,276,7},{2,50,25,711,230,0},},{0},{0},{{9,62,25,711,230,3},
{1,57,18,2,332},},{0},{{22,13,23,7,270},},{0},{{11,13,16,191,59},},{{215,27,17,215,236},},{{683,22,17,215,329},},{{692,7,20,11,0},
{9,67,21,3,211},},{{11,9,16,191,59},},{{693,9,21,11,86},{689,87,23,132,223},{191,18,24,703,227,7},},{{0,35,23,0,177},},
{0},{0},{{191,3,25,711,230,7},},{{702,47,1,1,0},{31,18,25,711,281,7},},{{7,9,25,711,188,7},},{{132,91,21,718,165},{3,67,18,9,203},},
{0},{{31,3,24,703,276,7},},{{1,45,23,0,316},},{{7,16,21,7,159},},{0},{{215,23,16,215,233},},{{697,3,21,7,86},{22,16,21,7,252},},
{0},{{685,11,23,7,316},{191,11,21,7,211},{3,62,24,703,183,3},},{0},{{0,57,18,2,203},},{{9,63,16,9,233},},{{687,87,21,132,335},
{0,42,19,2,208},},{0},{{22,12,25,711,281,7},},{{7,5,24,703,183,7},},{{694,78,21,3,86},{132,82,19,689,208},},{{683,34,25,711,323,8},
{683,23,24,703,320,8},},{{2,57,24,703,227,0},{2,36,25,711,230,0},},{0},{0},{0},{0},{0},{0},{{11,18,17,191,65},{11,7,16,191,59},},{{2,40,21,0,211},},
{{3,64,25,711,188,3},},{{9,73,21,3,211},},{0},{0},{0},{0},{{687,80,23,132,347},},{0},{{2,35,23,0,223},},{{9,69,25,711,230,3},{1,42,18,2,332},},
{{132,81,21,132,159},},{{703,85,13,687,0},{8,34,17,215,198},},{{7,6,23,7,177},},{{10,70,25,711,354,3},},{0},{0},{0},{0},{{1,52,25,711,323,0},},
{{687,79,23,132,347},},{{31,12,21,7,252},},{{22,7,24,703,276,7},},{{685,4,17,191,329},{191,16,23,7,223},},{{215,29,25,711,230,8},
{0,48,23,0,177},},{0},{{22,3,24,703,276,7},{10,63,16,9,357},},{{1,48,21,0,304},},{{2,47,18,2,239},},{{683,28,25,711,323,8},
{8,29,23,8,177},},{{7,18,16,191,193},{3,65,19,9,208},},{{1,47,18,2,332},},{0},{0},{0},{{703,86,13,687,0},{3,78,25,711,188,3},},
{{687,81,25,711,354,132},},{{683,24,21,8,304},},{0},{0},{{704,52,11,691,0},{685,16,18,191,332},{11,12,24,703,47,7},},{{215,26,23,8,223},},
{0},{{22,10,24,703,276,7},{10,69,23,3,347},},{{191,13,21,7,211},},{{689,86,17,689,236},},{{691,39,21,0,86},},{{132,92,24,703,183,132},},
{0},{{689,82,17,689,236},{2,42,18,2,239},},{{22,6,17,191,291},},{{3,66,21,3,159},},{0},{0},{{709,34,10,695,0},},{{1,44,21,0,304},},
{{11,5,21,7,19},},{0},{{0,55,18,2,203},},{0},{{215,22,18,215,239},},{{685,10,17,191,329},},{0},{{8,32,16,215,193},},{{132,87,24,703,183,132},},
{{0,43,21,0,159},},{{693,5,21,11,86},{2,54,21,704,219},},{0},{{7,4,16,191,193},},{0},{{687,90,24,703,351,132},{215,27,21,8,211},},
{0},{{9,67,17,9,236},},{0},{0},{0},{0},{0},{{11,6,24,703,47,7},},{{31,18,21,7,252},{2,41,23,0,223},},{{8,27,16,215,193},},{0},{0},{0},{{1,50,24,703,320,0},},
{{7,16,17,191,198},{7,13,16,191,193},},{{191,7,25,711,230,7},},{0},{{22,16,17,191,291},{10,67,18,9,363},},{0},{{191,11,25,711,230,7},},
{{31,7,24,703,276,7},},{{132,86,17,689,198},},{{9,64,23,3,223},},{{0,42,23,0,177},},{{685,18,23,7,316},{31,11,24,703,276,7},},
{{720,14,1,708,0},{689,84,18,689,239},},{0},{0},{{695,22,21,8,86},},{{689,80,18,689,239},{2,36,21,0,211},},{{1,38,25,711,323,0},},
{{7,10,16,191,193},{3,68,18,9,203},},{{0,49,21,0,159},},{{8,22,25,711,188,8},},{{22,4,16,191,286},{1,55,24,703,320,0},},
{0},{{11,18,21,7,19},},{{8,26,25,711,188,8},},{{132,90,16,689,193},},{{9,73,17,9,236},},{0},{{2,44,25,711,230,0},},{{699,62,23,723,92},},
{{191,4,18,191,239},{11,3,21,7,19},},{0},{{683,27,23,8,316},},{0},{0},{{685,12,25,711,323,7},{2,48,18,2,239},},{{8,34,21,8,159},},
{0},{{22,11,16,191,286},{10,70,21,3,335},},{{9,65,16,9,233},},{0},{0},{0},{{1,52,21,0,304},},{0},{{22,7,23,7,270},},{{7,11,25,711,188,7},},
{{685,4,21,7,304},},{{687,92,16,689,357},{215,29,21,8,211},},{0},{0},{{11,4,23,7,40},},{{31,16,16,191,286},},{{683,28,21,8,304},},
{0},{{22,18,16,191,286},},{0},{{10,77,21,726,339},},{{7,3,21,7,159},},{{132,84,16,689,193},{3,78,21,3,159},},{{215,21,25,711,230,8},},
{0},{{1,43,23,0,316},},{{132,80,16,689,193},{7,7,24,703,183,7},},{{191,9,17,191,236},},{{687,85,16,689,357},},{0},{0},{{191,13,17,191,236},},
{{31,9,16,191,286},},{0},{{3,70,25,711,188,3},},{{706,34,11,695,0},{683,32,16,215,326},{683,21,17,215,329},},{{689,82,21,132,211},
{31,13,16,191,286},},{{22,6,21,7,252},},{{3,66,25,711,188,3},},{{132,79,16,689,193},},{{8,24,18,215,203},},{{10,62,21,3,335},},
{{1,49,16,2,326},{1,44,17,2,329},},{{702,44,1,1,0},{11,16,24,703,47,7},{11,5,25,711,53,7},},{{191,6,23,7,223},},
{{687,82,16,689,357},{683,29,23,8,316},},{0},{0},{0},{{690,18,1,685,0},{689,90,18,689,239},{31,6,16,191,286},},{0},{{9,71,25,711,230,3},},
{{683,25,16,215,326},{0,43,17,2,198},},{{31,10,16,191,286},},{{10,64,18,9,363},},{0},{{687,90,23,132,347},{0,47,17,2,198},},
{0},{{22,9,23,7,270},{10,68,18,9,363},},{0},{{11,9,24,703,47,7},},{{191,18,16,191,233},},{{3,71,16,9,193},},{{22,5,24,703,276,7},},
{{9,76,23,3,223},},{{685,6,18,191,332},},{{689,60,25,711,230,132},{31,18,17,191,291},},{0},{0},{0},{0},{{697,7,21,7,86},},{0},{{683,26,16,215,326},},
{0},{0},{0},{0},{0},{{132,86,21,132,159},{3,76,16,9,193},},{{9,63,24,703,227,3},},{0},{0},{{699,67,23,10,92},{7,5,21,7,159},},{{132,82,24,703,183,132},
{11,10,23,7,40},},{{687,91,21,718,339},{215,24,18,215,239},},{{683,34,17,215,329},{683,23,16,215,326},},{{2,57,16,2,233},},
{0},{0},{{0,49,17,2,198},},{{8,22,21,8,159},},{0},{{9,77,21,726,215},},{{689,92,21,132,211},},{{132,59,12,719,94},},{{3,64,17,9,198},},
{{1,51,23,0,316},},{0},{{10,78,23,3,347},},{0},{{132,85,24,703,183,132},{7,2,0,693,97},},{0},{0},{{692,10,20,11,0},{9,69,18,9,239},
{1,42,25,711,323,0},},{{132,81,24,703,183,132},{3,63,25,711,188,3},},{{31,4,23,7,270},},{{8,34,25,711,188,8},{0,45,18,2,203},},
{0},{{697,13,21,7,86},},{0},{{2,52,25,711,230,0},},{{8,21,19,215,208},},{{3,73,23,3,177},},{{1,52,17,2,329},},{{689,81,23,132,223},
{31,12,24,703,276,7},},{0},{0},{{685,4,25,711,323,7},},{{215,29,17,215,236},},{{10,73,21,3,335},},{{692,13,20,11,0},{1,48,24,703,320,0},},
{0},{0},{{0,52,18,2,203},},{{7,18,24,703,183,7},},{{215,34,21,8,211},},{{693,51,21,11,86},{191,5,25,711,230,7},},{{2,51,23,0,223},},
{{7,3,25,711,188,7},},{{3,78,17,9,198},},{{714,63,10,694,0},{683,24,24,703,320,8},},{{31,5,24,703,276,7},},{0},{{690,23,1,683,0},},
{{191,9,21,7,211},},{0},{{22,10,21,7,252},},{{1,36,25,711,323,0},},{0},{{689,86,25,711,230,132},},{0},{{692,0,20,11,0},},{{683,21,21,8,304},},
{{689,82,25,711,230,132},},{{22,6,25,711,281,7},},{0},{0},{{0,51,25,711,188,0},},{0},{0},{{694,68,21,3,86},},{{683,29,24,703,320,8},{0,55,25,711,188,0},},
{{699,73,23,10,92},},{{1,40,21,0,304},},{{9,75,21,715,219},},{{685,10,25,711,323,7},},{{689,79,23,132,223},{2,50,21,0,211},},
{{132,87,23,132,177},},{0},{0},{0},{0},{{11,13,25,711,53,7},},{{0,47,21,0,159},},{{691,55,21,0,86},{683,22,24,703,320,8},},{0},{{9,67,25,711,230,3},},
{0},{{8,23,18,215,203},},{{713,19,2,712,2},},{{697,11,21,7,86},},{0},{{191,3,21,7,211},{11,6,16,191,59},},{{7,9,18,191,203},},
{0},{{692,18,20,11,0},},{0},{{2,45,23,0,223},},{0},{{191,7,18,191,239},},{{215,23,25,711,230,8},},{0},{{22,16,25,711,281,7},},{{685,11,16,191,326},
{191,11,18,191,239},},{{31,7,21,7,252},},{{0,57,25,711,188,0},},{{132,86,25,711,188,132},},{0},{{687,87,25,711,354,132},},{{10,71,17,9,360},},
{{7,5,17,191,198},},{0},{0},{{683,34,21,8,304},},{0},{{3,68,25,711,188,3},},{0},{0},{{8,22,17,215,198},},{0},{{685,7,23,7,316},{11,18,24,703,47,7},
{11,7,25,711,53,7},},{{689,92,17,689,236},},{{8,26,17,215,198},},{{132,90,24,703,183,132},{3,64,21,3,159},},{{9,73,25,711,230,3},},
{0},{0},{0},{{694,66,21,3,86},},{0},{0},{0},{{11,15,21,710,33},},{0},{0},{0},{{687,84,18,689,363},},{{11,11,24,703,47,7},},{{693,7,21,11,86},{2,52,21,0,211},},
{{8,21,23,8,177},},{{3,73,19,9,208},},{0},{{2,43,18,2,239},},{{1,39,24,703,320,0},},{{690,34,1,683,0},{7,11,17,191,198},
{3,69,19,9,208},},{0},{{691,49,21,0,86},},{{22,3,23,7,270},{10,73,17,9,360},},{{9,78,18,9,239},},{0},{{31,16,24,703,276,7},},
{{7,18,23,7,177},},{0},{{215,34,17,215,236},},{{191,5,21,7,211},},{0},{{691,47,21,0,86},},{{687,81,18,689,363},},{0},{0},{0},{{132,80,24,703,183,132},
{7,7,16,191,193},},{{0,44,23,0,177},},{0},{{22,10,17,191,291},},{{706,21,11,695,0},{1,36,21,0,304},},{{191,13,25,711,230,7},},
{0},{{132,92,17,689,198},},{0},{{683,32,24,703,320,8},{683,21,25,711,323,8},},{{685,5,18,191,332},{31,13,24,703,276,7},},{0},{0},{0},{{0,51,21,0,159},},
{0},{{1,49,24,703,320,0},{1,44,25,711,323,0},},{0},{0},{{8,28,25,711,188,8},},{{1,40,25,711,323,0},},{0},{{689,90,25,711,230,132},{689,79,24,703,227,132},},
{{8,32,25,711,188,8},},{0},{{9,71,17,9,236},{1,57,23,0,316},},{{687,86,23,132,347},{683,25,24,703,320,8},{0,43,25,711,188,0},},
{{31,10,24,703,276,7},},{0},{0},{{215,27,18,215,239},{0,47,25,711,188,0},},{0},{0},{{11,9,21,7,19},},{0},{0},{{132,60,24,703,183,132},{3,71,24,703,183,3},},
{{22,5,16,191,286},},{{685,6,25,711,323,7},},{0},{0},{{3,67,23,3,177},},{0},{{0,50,23,0,177},},{{1,45,16,2,326},},{{7,16,24,703,183,7},
{7,13,25,711,188,7},},{0},{{683,26,24,703,320,8},{215,23,21,8,211},},{0},{0},{0},{{690,6,1,685,0},{31,7,17,191,291},{2,49,18,2,239},},
{{0,57,21,0,159},},{{699,71,23,10,92},{3,76,24,703,183,3},{0,20,3,713,101},},{{0,42,16,2,193},},{{31,11,17,191,291},},
{{689,84,25,711,230,132},{10,71,21,3,335},},{{691,41,21,0,86},},{{132,82,16,689,193},},{0},{{689,80,25,711,230,132},},{0},{{7,10,23,7,177},
{3,68,21,3,159},},{0},{{687,60,23,132,347},{683,19,24,703,320,8},{0,49,25,711,188,0},},{{22,4,25,711,281,7},{1,55,17,2,329},},
{{215,28,21,8,211},},{0},{0},{{8,26,21,8,159},},{0},{{0,38,23,0,177},},{{2,44,18,2,239},},{{701,79,21,132,86},},{0},{{132,85,16,689,193},
{11,3,25,711,53,7},},{0},{{10,66,23,3,347},},{{1,42,17,2,329},},{{132,81,16,689,193},{3,63,17,9,198},},{{685,12,21,7,304},},
{{7,6,18,191,203},},{0},{{9,65,25,711,230,3},},{{694,63,21,3,86},},{{689,85,23,132,223},{2,52,17,2,236},},{{694,77,21,726,88},},
{{705,42,10,691,0},},{{687,79,24,703,351,132},},{0},{0},{{7,11,21,7,159},{3,69,23,3,177},},{{0,48,16,2,193},},{{8,25,18,215,203},
{0,37,6,722,113},},{0},{{1,48,16,2,326},{1,35,23,0,316},},{0},{{8,29,18,215,203},},{{7,18,19,191,208},{3,65,16,9,193},},
{{692,9,20,11,0},{22,18,25,711,281,7},},{0},{{685,9,23,7,316},{191,5,17,191,236},},{0},{{132,84,25,711,188,132},},{{215,21,18,215,239},},
{{683,24,16,215,326},},{{31,5,16,191,286},{2,55,23,0,223},},{{10,65,18,9,363},},{{685,16,21,7,304},},{{687,85,25,711,354,132},
{0,44,19,2,208},},{0},{{701,85,21,132,86},{10,69,18,9,363},},{{710,13,11,697,0},{692,4,20,11,0},{9,66,23,3,223},},
{{31,9,25,711,281,7},{2,38,23,0,223},},{0},{{717,79,11,701,0},{132,92,21,132,159},},{0},{{687,89,21,717,343},},{{22,6,18,191,296},},
{{3,66,16,9,193},},{0},{0},{0},{{10,62,25,711,354,3},},{{11,5,18,191,71},},{{31,17,21,720,258},},{{687,82,23,132,347},{683,29,16,215,326},
{0,55,17,2,198},},{{8,28,21,8,159},},{{10,76,18,9,363},},{0},{0},{0},{0},{{9,71,21,3,211},{9,62,24,703,227,3},},{{693,18,21,11,86},
{31,10,23,7,270},},{0},{{690,11,1,685,0},},{{11,13,17,191,65},},{0},};

static const struct action_table_entry *action_table_lookup(uint32_t nfa_state, uint32_t dfa_state, uint32_t token) {
    uint32_t index = ((((((0xe5aa55e5 ^ (nfa_state)) * 0xe5aa55e5) ^ (dfa_state)) * 0xe5aa55e5) ^ (token)) * 0xe5aa55e5) & 2047;
    uint32_t j = 0;
    const struct action_table_entry *entry = 0;
    for (; j < 3; ++j) {
        entry = &action_table[index][j];
        if (entry->target_nfa_state == nfa_state && entry->dfa_state == dfa_state && entry->dfa_symbol == token)
            break;
    }
    if (j >= 3)
        return 0;
    return entry;
}
static void apply_actions(struct construct_state *state, uint32_t index, size_t start, size_t end) {
    size_t offset = end;
    for (uint32_t i = index; actions[i]; ++i) {
        if (((((actions[i]) >> 12) & 0xf) & 8))
            offset = start;
        construct_action_apply(state, actions[i], offset);
    }
}
static size_t build_parse_tree(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run *run, struct bluebird_tree *tree) {
    struct construct_state construct_state = { .info = tree };
    uint32_t *state_stack = 0;
    uint32_t stack_depth = 0;
    size_t stack_capacity = 0;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset - whitespace;
    construct_begin(&construct_state, offset, CONSTRUCT_NORMAL_ROOT);
    uint32_t nfa_state = 31;
    while (run) {
        uint16_t length_offset = run->lengths_size - 1;
        uint16_t n = run->number_of_tokens;
        for (uint16_t i = n - 1; i < n; i--) {
            size_t end = offset;
            size_t len = 0;
            const struct action_table_entry *entry = action_table_lookup(nfa_state, run->states[i], run->tokens[i]);
            if (!entry)
                abort();
            if (entry->dfa_symbol < 24)
                len = decode_token_length(run, &length_offset, &offset);
            else {
                if (stack_depth >= stack_capacity) {
                    size_t new_capacity = (stack_capacity + 2) * 3 / 2;
                    if (new_capacity <= stack_capacity)
                        abort();
                    uint32_t *new_stack = realloc(state_stack, new_capacity * sizeof(uint32_t));
                    if (!new_stack)
                        abort();
                    state_stack = new_stack;
                    stack_capacity = new_capacity;
                }
                state_stack[stack_depth++] = entry->push_nfa_state;
            }
            apply_actions(&construct_state, entry->actions, end, end + whitespace);
            if (entry->dfa_state == 59) {
                if (stack_depth == 0)
                    abort();
                nfa_state = state_stack[--stack_depth];
            } else
                nfa_state = entry->nfa_state;
            whitespace = end - offset - len;
        }
        struct bluebird_token_run *old = run;
        run = run->prev;
        free(old);
    }
    const struct action_table_entry *entry = action_table_lookup(nfa_state, UINT32_MAX, UINT32_MAX);
    if (!entry)
        abort();
    apply_actions(&construct_state, entry->actions, offset, offset + whitespace);
    free(state_stack);
    return construct_finish(&construct_state, offset);
}
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info) {
    switch (text[0]) {
    case 35:
        *end_token = false;
        *token = 4294967295U;
        return 1;
    case 40:
        *end_token = false;
        *token = 12;
        return 1;
    case 41:
        *end_token = true;
        *token = 13;
        return 1;
    case 42:
        *end_token = false;
        *token = 16;
        return 1;
    case 43:
        *end_token = false;
        *token = 17;
        return 1;
    case 46:
        if (text[1] == 111 && text[2] == 112 && text[3] == 101 && text[4] == 114 && text[5] == 97 && text[6] == 116 && text[7] == 111 && text[8] == 114 && text[9] == 115) {
            *end_token = false;
            *token = 2;
            return 10;
        } else {
            return 0;
        }
    case 58:
        *end_token = false;
        *token = 1;
        return 1;
    case 61:
        *end_token = false;
        *token = 0;
        return 1;
    case 63:
        *end_token = false;
        *token = 18;
        return 1;
    case 64:
        *end_token = false;
        *token = 11;
        return 1;
    case 91:
        *end_token = false;
        *token = 14;
        return 1;
    case 92:
        *end_token = false;
        *token = 10;
        return 1;
    case 93:
        *end_token = true;
        *token = 15;
        return 1;
    case 102:
        if (text[1] == 108 && text[2] == 97 && text[3] == 116) {
            *end_token = false;
            *token = 6;
            return 4;
        } else {
            return 0;
        }
    case 105:
        if (text[1] == 110 && text[2] == 102 && text[3] == 105 && text[4] == 120) {
            *end_token = false;
            *token = 5;
            return 5;
        } else {
            return 0;
        }
    case 108:
        switch (text[1]) {
        case 101:
            if (text[2] == 102 && text[3] == 116) {
                *end_token = false;
                *token = 7;
                return 4;
            } else {
                return 0;
            }
        case 105:
            if (text[2] == 110 && text[3] == 101 && text[4] == 45 && text[5] == 99 && text[6] == 111 && text[7] == 109 && text[8] == 109 && text[9] == 101 && text[10] == 110 && text[11] == 116 && text[12] == 45 && text[13] == 116 && text[14] == 111 && text[15] == 107 && text[16] == 101 && text[17] == 110) {
                *end_token = false;
                *token = 20;
                return 18;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 110:
        if (text[1] == 111 && text[2] == 110 && text[3] == 97 && text[4] == 115 && text[5] == 115 && text[6] == 111 && text[7] == 99) {
            *end_token = false;
            *token = 9;
            return 8;
        } else {
            return 0;
        }
    case 112:
        switch (text[1]) {
        case 111:
            if (text[2] == 115 && text[3] == 116 && text[4] == 102 && text[5] == 105 && text[6] == 120) {
                *end_token = false;
                *token = 3;
                return 7;
            } else {
                return 0;
            }
        case 114:
            if (text[2] == 101 && text[3] == 102 && text[4] == 105 && text[5] == 120) {
                *end_token = false;
                *token = 4;
                return 6;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 114:
        if (text[1] == 105 && text[2] == 103 && text[3] == 104 && text[4] == 116) {
            *end_token = false;
            *token = 8;
            return 5;
        } else {
            return 0;
        }
    case 124:
        *end_token = false;
        *token = 19;
        return 1;
    default:
        return 0;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context) {
    switch (parent) {
    case 0:
        switch (slot) {
        case 0: return 1;
        case 1: return 8;
        default: break;
        }
        break;
    case 1:
        switch (slot) {
        case 0: return 9;
        case 1: return 2;
        default: break;
        }
        break;
    case 2:
        switch (slot) {
        case 0: return 7;
        case 1: return 9;
        case 2: return 3;
        default: break;
        }
        break;
    case 3:
        switch (slot) {
        case 0: return 4;
        case 1: return 6;
        default: break;
        }
        break;
    case 4:
        switch (slot) {
        case 0: return 5;
        default: break;
        }
        break;
    case 6:
        switch (slot) {
        case 0: return 7;
        case 1: return 9;
        default: break;
        }
        break;
    case 7:
        switch (slot) {
        case 0: return 9;
        case 1: return 9;
        case 2: return 9;
        case 3: return 11;
        case 4: return 7;
        case 5: return 11;
        case 6: return 11;
        case 7: return 7;
        default: break;
        }
        break;
    case 8:
        switch (slot) {
        case 0: return 11;
        default: break;
        }
        break;
    default: break;
    }
    return UINT32_MAX;
}
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context) {
    switch (rule) {
    case 7:
        switch (choice) {
        case 4:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 5:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 6:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 7:
            *precedence = -2;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        case 8:
            *precedence = -3;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        default: return;
        }
    default: return;
    }
}
static size_t number_of_slots_lookup(uint32_t rule, void *context) {
    switch (rule) {
    case 0: return 2;
    case 1: return 2;
    case 2: return 3;
    case 3: return 2;
    case 4: return 1;
    case 5: return 0;
    case 6: return 2;
    case 7: return 8;
    case 8: return 1;
    case 9: return 0;
    case 10: return 0;
    case 11: return 0;
    default: return 0;
    }
}
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context) {
    switch (rule) {
    case 0:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 1:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 2:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 3:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 4:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 5:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 6:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 7:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 7;
        break;
    case 8:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 9:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 10:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 11:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    }
}
#endif

