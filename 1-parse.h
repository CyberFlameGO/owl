// -----------------------------------------------------------------------------
// This file was generated by the bluebird parsing tool.
// Make sure to #define BLUEBIRD_PARSER_IMPLEMENTATION somewhere so the parser
// is compiled properly.  Just two lines are enough -- a typical parser.c might
// look like:
//
//   #define BLUEBIRD_PARSER_IMPLEMENTATION
//   #include "bluebird-parser.h"

#ifndef _BLUEBIRD_PARSER_H_
#define _BLUEBIRD_PARSER_H_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

// A parsed_id represents an element in the parse tree.  Use the
// parsed_..._get() function corresponding to the element type to unpack the
// element into its appropriate type of parsed_... element struct.
typedef size_t parsed_id;

// The bluebird_tree struct represents an entire parse tree.  Use the
// bluebird_tree_create_...() functions to create a tree, then call
// bluebird_tree_root() to get the root bluebird_id.
struct bluebird_tree;

// Creates a bluebird_tree from a string.  The tree may directly reference
// pieces of the string -- you're responsible for keeping it around until
// bluebird_tree_destroy() is called.
struct bluebird_tree *bluebird_tree_create_from_string(const char *string);

// Creates a bluebird_tree by reading from a file.
struct bluebird_tree *bluebird_tree_create_from_file(FILE *file);

// Destroys a bluebird_tree, freeing its resources back to the system.
void bluebird_tree_destroy(struct bluebird_tree *);

// Prints a representation of the tree to standard output.
void bluebird_tree_print(struct bluebird_tree *);

// Returns the root parsed_id.
parsed_id bluebird_tree_root_id(struct bluebird_tree *tree);

// As a shortcut, returns the parsed_grammar struct corresponding to the root parsed_id.
struct parsed_grammar bluebird_tree_get_parsed_grammar(struct bluebird_tree *tree);

// The range of text corresponding to a tree element.
struct source_range {
    size_t start;
    size_t end;
};

enum bluebird_error {
    // No error -- everything's fine!
    ERROR_NONE,

    // The file passed to bluebird_tree_create_from_file wasn't valid because
    // - it was NULL,
    // - it doesn't support fseek/ftell, or
    // - there was an error while reading it.
    ERROR_INVALID_FILE,

    // A piece of text couldn't be matched as a token.
    ERROR_INVALID_TOKEN,

    // The parser encountered an out-of-place token that doesn't fit the grammar.
    ERROR_UNEXPECTED_TOKEN,

    // The input is valid so far, but incomplete; more tokens could be added to
    // complete it.
    ERROR_MORE_INPUT_NEEDED,
};
// Returns an error code, or ERROR_NONE if there wasn't an error.
// The error_range parameter can be null.
enum bluebird_error bluebird_tree_get_error(struct bluebird_tree *tree, struct source_range *error_range);

enum parsed_type {
    PARSED_IDENT = 1,
    PARSED_CHOICE,
    PARSED_PARENS,
    PARSED_FLAT_OP,
    PARSED_LEFT_OP,
    PARSED_LITERAL,
    PARSED_INFIX_OP,
    PARSED_OPTIONAL,
    PARSED_RIGHT_OP,
    PARSED_BRACKETED,
    PARSED_PREFIX_OP,
    PARSED_POSTFIX_OP,
    PARSED_NONASSOC_OP,
    PARSED_ONE_OR_MORE,
    PARSED_ZERO_OR_MORE,
    PARSED_CONCATENATION,
};

struct parsed_grammar {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id comment_token;
    parsed_id rule;
};

struct parsed_comment_token {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id string;
};

struct parsed_rule {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id identifier;
    parsed_id body;
};

struct parsed_body {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id expr;
    parsed_id identifier;
    parsed_id operators;
};

struct parsed_operators {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id fixity;
    parsed_id operator;
};

struct parsed_operator {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id expr;
    parsed_id identifier;
};

struct parsed_fixity {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    enum parsed_type type;
    parsed_id assoc;
};

struct parsed_assoc {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    enum parsed_type type;
};

struct parsed_expr {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    enum parsed_type type;
    parsed_id identifier;
    parsed_id rename;
    parsed_id string;
    parsed_id expr;
    parsed_id begin_token;
    parsed_id end_token;
    parsed_id operand;
};

struct parsed_identifier {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    const char *identifier;
    size_t length;
};

struct parsed_number {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    double number;
};

struct parsed_string {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    const char *string;
    size_t length;
};

struct parsed_grammar parsed_grammar_get(struct bluebird_tree *, parsed_id);
struct parsed_comment_token parsed_comment_token_get(struct bluebird_tree *, parsed_id);
struct parsed_rule parsed_rule_get(struct bluebird_tree *, parsed_id);
struct parsed_body parsed_body_get(struct bluebird_tree *, parsed_id);
struct parsed_operators parsed_operators_get(struct bluebird_tree *, parsed_id);
struct parsed_operator parsed_operator_get(struct bluebird_tree *, parsed_id);
struct parsed_fixity parsed_fixity_get(struct bluebird_tree *, parsed_id);
struct parsed_assoc parsed_assoc_get(struct bluebird_tree *, parsed_id);
struct parsed_expr parsed_expr_get(struct bluebird_tree *, parsed_id);
struct parsed_identifier parsed_identifier_get(struct bluebird_tree *, parsed_id);
struct parsed_number parsed_number_get(struct bluebird_tree *, parsed_id);
struct parsed_string parsed_string_get(struct bluebird_tree *, parsed_id);

static inline struct parsed_grammar parsed_grammar_next(struct parsed_grammar parsed)
{
    return parsed_grammar_get(parsed._tree, parsed._next);
}
static inline struct parsed_comment_token parsed_comment_token_next(struct parsed_comment_token parsed)
{
    return parsed_comment_token_get(parsed._tree, parsed._next);
}
static inline struct parsed_rule parsed_rule_next(struct parsed_rule parsed)
{
    return parsed_rule_get(parsed._tree, parsed._next);
}
static inline struct parsed_body parsed_body_next(struct parsed_body parsed)
{
    return parsed_body_get(parsed._tree, parsed._next);
}
static inline struct parsed_operators parsed_operators_next(struct parsed_operators parsed)
{
    return parsed_operators_get(parsed._tree, parsed._next);
}
static inline struct parsed_operator parsed_operator_next(struct parsed_operator parsed)
{
    return parsed_operator_get(parsed._tree, parsed._next);
}
static inline struct parsed_fixity parsed_fixity_next(struct parsed_fixity parsed)
{
    return parsed_fixity_get(parsed._tree, parsed._next);
}
static inline struct parsed_assoc parsed_assoc_next(struct parsed_assoc parsed)
{
    return parsed_assoc_get(parsed._tree, parsed._next);
}
static inline struct parsed_expr parsed_expr_next(struct parsed_expr parsed)
{
    return parsed_expr_get(parsed._tree, parsed._next);
}
static inline struct parsed_identifier parsed_identifier_next(struct parsed_identifier parsed)
{
    return parsed_identifier_get(parsed._tree, parsed._next);
}
static inline struct parsed_number parsed_number_next(struct parsed_number parsed)
{
    return parsed_number_get(parsed._tree, parsed._next);
}
static inline struct parsed_string parsed_string_next(struct parsed_string parsed)
{
    return parsed_string_get(parsed._tree, parsed._next);
}

#endif

#ifdef BLUEBIRD_PARSER_IMPLEMENTATION
// Code implementing the parser.  This might get a bit messy!
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct bluebird_tree {
    const char *string;
    bool owns_string;
    uint8_t *parse_tree;
    size_t parse_tree_size;
    enum bluebird_error error;
    struct source_range error_range;
    parsed_id next_id;
    parsed_id root_id;
    struct {
        const char *identifier;
        size_t length;
        struct source_range range;
    } *identifier_tokens;
    size_t number_of_identifier_tokens;
    size_t used_identifier_tokens;
    size_t identifier_tokens_capacity;
    struct {
        double number;
        struct source_range range;
    } *number_tokens;
    size_t number_of_number_tokens;
    size_t used_number_tokens;
    size_t number_tokens_capacity;
    struct {
        const char *string;
        size_t length;
        struct source_range range;
    } *string_tokens;
    size_t number_of_string_tokens;
    size_t used_string_tokens;
    size_t string_tokens_capacity;
};
static void add_identifier_token(struct bluebird_tree *tree, size_t start, size_t end, const char *identifier_param, size_t length_param) {
    size_t index = tree->number_of_identifier_tokens++;
    if (tree->number_of_identifier_tokens > tree->identifier_tokens_capacity) {
        size_t capacity = (tree->identifier_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->identifier_tokens, sizeof(tree->identifier_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->identifier_tokens_capacity = capacity;
        tree->identifier_tokens = tokens;
    }
    tree->identifier_tokens[index].range.start = start;
    tree->identifier_tokens[index].range.end = end;
    tree->identifier_tokens[index].identifier = identifier_param;
    tree->identifier_tokens[index].length = length_param;
}
static void add_number_token(struct bluebird_tree *tree, size_t start, size_t end, double number_param) {
    size_t index = tree->number_of_number_tokens++;
    if (tree->number_of_number_tokens > tree->number_tokens_capacity) {
        size_t capacity = (tree->number_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->number_tokens, sizeof(tree->number_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->number_tokens_capacity = capacity;
        tree->number_tokens = tokens;
    }
    tree->number_tokens[index].range.start = start;
    tree->number_tokens[index].range.end = end;
    tree->number_tokens[index].number = number_param;
}
static void add_string_token(struct bluebird_tree *tree, size_t start, size_t end, const char *string_param, size_t length_param) {
    size_t index = tree->number_of_string_tokens++;
    if (tree->number_of_string_tokens > tree->string_tokens_capacity) {
        size_t capacity = (tree->string_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->string_tokens, sizeof(tree->string_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->string_tokens_capacity = capacity;
        tree->string_tokens = tokens;
    }
    tree->string_tokens[index].range.start = start;
    tree->string_tokens[index].range.end = end;
    tree->string_tokens[index].string = string_param;
    tree->string_tokens[index].length = length_param;
}
// Reserve 10 bytes for each entry (the maximum encoded size of a 64-bit value).
#define RESERVATION_AMOUNT 10
static inline parsed_id read_tree(parsed_id *id, struct bluebird_tree *tree) {
    uint8_t *parse_tree = tree->parse_tree;
    size_t parse_tree_size = tree->parse_tree_size;
    parsed_id i = *id;
    if (i + RESERVATION_AMOUNT >= parse_tree_size)
        return 0;
    parsed_id result = 0;
    int shift_amount = 0;
    while ((parse_tree[i] & 0x80) != 0 && shift_amount < 64) {
        result |= (parse_tree[i] & 0x7f) << shift_amount;
        shift_amount += 7;
        i++;
    }
    result |= (parse_tree[i] & 0x7f) << shift_amount;
    i++;
    *id = i;
    return result;
}
static bool grow_tree(struct bluebird_tree *tree, size_t size)
{
    size_t n = tree->parse_tree_size;
    while (n < size || n < 4096)
        n = (n + 1) * 3 / 2;
    uint8_t *parse_tree = realloc(tree->parse_tree, n);
    if (!parse_tree)
        return false;
    tree->parse_tree_size = n;
    tree->parse_tree = parse_tree;
    return true;
}
static void write_tree(struct bluebird_tree *tree, parsed_id value)
{
    size_t reserved_size = tree->next_id + RESERVATION_AMOUNT;
    if (tree->parse_tree_size <= reserved_size && !grow_tree(tree, reserved_size))
        abort();
    while (value >> 7 != 0) {
        tree->parse_tree[tree->next_id++] = 0x80 | (value & 0x7f);
        value >>= 7;
    }
    tree->parse_tree[tree->next_id++] = value & 0x7f;
}
struct parsed_grammar parsed_grammar_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_grammar){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_grammar){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .comment_token = read_tree(&id, tree),
        .rule = read_tree(&id, tree),
    };
}
struct parsed_comment_token parsed_comment_token_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_comment_token){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_comment_token){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .string = read_tree(&id, tree),
    };
}
struct parsed_rule parsed_rule_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_rule){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_rule){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .identifier = read_tree(&id, tree),
        .body = read_tree(&id, tree),
    };
}
struct parsed_body parsed_body_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_body){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_body){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .expr = read_tree(&id, tree),
        .identifier = read_tree(&id, tree),
        .operators = read_tree(&id, tree),
    };
}
struct parsed_operators parsed_operators_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_operators){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_operators){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .fixity = read_tree(&id, tree),
        .operator = read_tree(&id, tree),
    };
}
struct parsed_operator parsed_operator_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_operator){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_operator){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .expr = read_tree(&id, tree),
        .identifier = read_tree(&id, tree),
    };
}
struct parsed_fixity parsed_fixity_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_fixity){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_fixity){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&id, tree),
        .assoc = read_tree(&id, tree),
    };
}
struct parsed_assoc parsed_assoc_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_assoc){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_assoc){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&id, tree),
    };
}
struct parsed_expr parsed_expr_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_expr){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_expr){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&id, tree),
        .identifier = read_tree(&id, tree),
        .rename = read_tree(&id, tree),
        .string = read_tree(&id, tree),
        .expr = read_tree(&id, tree),
        .begin_token = read_tree(&id, tree),
        .end_token = read_tree(&id, tree),
        .operand = read_tree(&id, tree),
    };
}
struct parsed_identifier parsed_identifier_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_identifier){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t token_index = read_tree(&id, tree);
    return (struct parsed_identifier){
        ._tree = tree,
        ._next = next,
        .identifier = tree->identifier_tokens[token_index].identifier,
        .length = tree->identifier_tokens[token_index].length,
        .range = tree->identifier_tokens[token_index].range,
    };
}
struct parsed_number parsed_number_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_number){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t token_index = read_tree(&id, tree);
    return (struct parsed_number){
        ._tree = tree,
        ._next = next,
        .number = tree->number_tokens[token_index].number,
        .range = tree->number_tokens[token_index].range,
    };
}
struct parsed_string parsed_string_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_string){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t token_index = read_tree(&id, tree);
    return (struct parsed_string){
        ._tree = tree,
        ._next = next,
        .string = tree->string_tokens[token_index].string,
        .length = tree->string_tokens[token_index].length,
        .range = tree->string_tokens[token_index].range,
    };
}
static parsed_id finish_node(uint32_t rule, uint32_t choice, parsed_id next_sibling, parsed_id *slots, size_t start_location, size_t end_location, void *info) {
    struct bluebird_tree *tree = info;
    parsed_id id = tree->next_id;
    write_tree(tree, next_sibling);
    write_tree(tree, (parsed_id)start_location);
    write_tree(tree, (parsed_id)end_location);
    switch (rule) {
    case 0: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 1: {
        write_tree(tree, slots[0]);
        break;
    }
    case 2: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 3: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        break;
    }
    case 4: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 5: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 6: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_POSTFIX_OP);
            break;
        case 1:
            write_tree(tree, PARSED_PREFIX_OP);
            break;
        case 2:
            write_tree(tree, PARSED_INFIX_OP);
            break;
        }
        write_tree(tree, slots[0]);
        break;
    }
    case 7: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_FLAT_OP);
            break;
        case 1:
            write_tree(tree, PARSED_LEFT_OP);
            break;
        case 2:
            write_tree(tree, PARSED_RIGHT_OP);
            break;
        case 3:
            write_tree(tree, PARSED_NONASSOC_OP);
            break;
        }
        break;
    }
    case 8: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_IDENT);
            break;
        case 1:
            write_tree(tree, PARSED_LITERAL);
            break;
        case 2:
            write_tree(tree, PARSED_PARENS);
            break;
        case 3:
            write_tree(tree, PARSED_BRACKETED);
            break;
        case 4:
            write_tree(tree, PARSED_ZERO_OR_MORE);
            break;
        case 5:
            write_tree(tree, PARSED_ONE_OR_MORE);
            break;
        case 6:
            write_tree(tree, PARSED_OPTIONAL);
            break;
        case 7:
            write_tree(tree, PARSED_CONCATENATION);
            break;
        case 8:
            write_tree(tree, PARSED_CHOICE);
            break;
        }
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        write_tree(tree, slots[3]);
        write_tree(tree, slots[4]);
        write_tree(tree, slots[5]);
        write_tree(tree, slots[6]);
        break;
    }
    default:
        break;
    }
    return id;
}
static parsed_id finish_token(uint32_t rule, parsed_id next_sibling, void *info) {
    struct bluebird_tree *tree = info;
    parsed_id id = tree->next_id;
    write_tree(tree, next_sibling);
    switch (rule) {
    case 9: {
        tree->used_identifier_tokens++;
        if (tree->used_identifier_tokens > tree->number_of_identifier_tokens)
            abort();
        size_t token_index = tree->number_of_identifier_tokens - tree->used_identifier_tokens;
        write_tree(tree, (parsed_id)token_index);
        break;
    }
    case 10: {
        tree->used_number_tokens++;
        if (tree->used_number_tokens > tree->number_of_number_tokens)
            abort();
        size_t token_index = tree->number_of_number_tokens - tree->used_number_tokens;
        write_tree(tree, (parsed_id)token_index);
        break;
    }
    case 11: {
        tree->used_string_tokens++;
        if (tree->used_string_tokens > tree->number_of_string_tokens)
            abort();
        size_t token_index = tree->number_of_string_tokens - tree->used_string_tokens;
        write_tree(tree, (parsed_id)token_index);
        break;
    }
    default:
        break;
    }
    return id;
}
static void check_for_error(struct bluebird_tree *tree) {
    if (tree->error == ERROR_NONE)
        return;
    fprintf(stderr, "parse error: ");
    switch (tree->error) {
    case ERROR_INVALID_FILE:
        fprintf(stderr, "invalid file\n");
        break;
    case ERROR_INVALID_TOKEN:
        fprintf(stderr, "invalid token\n");
        break;
    case ERROR_UNEXPECTED_TOKEN:
        fprintf(stderr, "unexpected token\n");
        break;
    case ERROR_MORE_INPUT_NEEDED:
        fprintf(stderr, "more input needed\n");
        break;
    default:
        break;
    }
    exit(-1);
}
static void parsed_grammar_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_comment_token_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_rule_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_body_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_operators_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_operator_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_fixity_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_assoc_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_expr_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_identifier_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_number_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_string_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_grammar_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_grammar it = parsed_grammar_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("grammar");
        if (strcmp("grammar", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_comment_token_print(tree, it.comment_token, "comment_token", indent + 1);
        parsed_rule_print(tree, it.rule, "rule", indent + 1);
        it = parsed_grammar_next(it);
    }
}
static void parsed_comment_token_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_comment_token it = parsed_comment_token_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("comment_token");
        if (strcmp("comment_token", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_string_print(tree, it.string, "string", indent + 1);
        it = parsed_comment_token_next(it);
    }
}
static void parsed_rule_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_rule it = parsed_rule_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("rule");
        if (strcmp("rule", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_body_print(tree, it.body, "body", indent + 1);
        it = parsed_rule_next(it);
    }
}
static void parsed_body_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_body it = parsed_body_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("body");
        if (strcmp("body", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_operators_print(tree, it.operators, "operators", indent + 1);
        it = parsed_body_next(it);
    }
}
static void parsed_operators_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_operators it = parsed_operators_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operators");
        if (strcmp("operators", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_fixity_print(tree, it.fixity, "fixity", indent + 1);
        parsed_operator_print(tree, it.operator, "operator", indent + 1);
        it = parsed_operators_next(it);
    }
}
static void parsed_operator_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_operator it = parsed_operator_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operator");
        if (strcmp("operator", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        it = parsed_operator_next(it);
    }
}
static void parsed_fixity_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_fixity it = parsed_fixity_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("fixity");
        if (strcmp("fixity", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_POSTFIX_OP:
            printf(" : POSTFIX_OP");
            break;
        case PARSED_PREFIX_OP:
            printf(" : PREFIX_OP");
            break;
        case PARSED_INFIX_OP:
            printf(" : INFIX_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_assoc_print(tree, it.assoc, "assoc", indent + 1);
        it = parsed_fixity_next(it);
    }
}
static void parsed_assoc_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_assoc it = parsed_assoc_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("assoc");
        if (strcmp("assoc", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_FLAT_OP:
            printf(" : FLAT_OP");
            break;
        case PARSED_LEFT_OP:
            printf(" : LEFT_OP");
            break;
        case PARSED_RIGHT_OP:
            printf(" : RIGHT_OP");
            break;
        case PARSED_NONASSOC_OP:
            printf(" : NONASSOC_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        it = parsed_assoc_next(it);
    }
}
static void parsed_expr_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_expr it = parsed_expr_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("expr");
        if (strcmp("expr", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_IDENT:
            printf(" : IDENT");
            break;
        case PARSED_LITERAL:
            printf(" : LITERAL");
            break;
        case PARSED_PARENS:
            printf(" : PARENS");
            break;
        case PARSED_BRACKETED:
            printf(" : BRACKETED");
            break;
        case PARSED_ZERO_OR_MORE:
            printf(" : ZERO_OR_MORE");
            break;
        case PARSED_ONE_OR_MORE:
            printf(" : ONE_OR_MORE");
            break;
        case PARSED_OPTIONAL:
            printf(" : OPTIONAL");
            break;
        case PARSED_CONCATENATION:
            printf(" : CONCATENATION");
            break;
        case PARSED_CHOICE:
            printf(" : CHOICE");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_identifier_print(tree, it.rename, "rename", indent + 1);
        parsed_string_print(tree, it.string, "string", indent + 1);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_string_print(tree, it.begin_token, "begin_token", indent + 1);
        parsed_string_print(tree, it.end_token, "end_token", indent + 1);
        parsed_expr_print(tree, it.operand, "operand", indent + 1);
        it = parsed_expr_next(it);
    }
}
static void parsed_identifier_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_identifier it = parsed_identifier_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("identifier");
        if (strcmp("identifier", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.identifier);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        it = parsed_identifier_next(it);
    }
}
static void parsed_number_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_number it = parsed_number_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("number");
        if (strcmp("number", slot_name))
            printf("@%s", slot_name);
        printf(" - %f", it.number);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        it = parsed_number_next(it);
    }
}
static void parsed_string_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_string it = parsed_string_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("string");
        if (strcmp("string", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.string);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        it = parsed_string_next(it);
    }
}
void bluebird_tree_print(struct bluebird_tree *tree) {
    check_for_error(tree);
    parsed_grammar_print(tree, tree->root_id, "grammar", 0);
}
parsed_id bluebird_tree_root_id(struct bluebird_tree *tree) {
    check_for_error(tree);
    return tree->root_id;
}
struct parsed_grammar bluebird_tree_get_parsed_grammar(struct bluebird_tree *tree) {
    check_for_error(tree);
    return parsed_grammar_get(tree, tree->root_id);
}
#define IGNORE_TOKEN_WRITE(...)
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info);
static void write_identifier_token(size_t offset, size_t length, void *info) {
    struct bluebird_tree *tree = info;
    add_identifier_token(tree, offset, offset + length, tree->string + offset, length);
}
static void write_number_token(size_t offset, size_t length, double number, void *info) {
    struct bluebird_tree *tree = info;
    add_number_token(tree, offset, offset + length, number);
}
static void write_string_token(size_t offset, size_t length, size_t content_offset, size_t content_length, void *info) {
    struct bluebird_tree *tree = info;
    // Apply escape sequences.
    size_t escaped_length = content_length;
    for (size_t i = 0; i < content_length; ++i) {
        if (tree->string[content_offset + i] == '\\') {
            escaped_length--;
            i++;
        }
    }
    char *escaped = malloc(escaped_length);
    size_t j = 0;
    for (size_t i = 0; i < content_length; ++i) {
        if (tree->string[content_offset + i] == '\\')
            i++;
        escaped[j++] = tree->string[content_offset + i];
    }
    add_string_token(tree, offset, offset + length, escaped, escaped_length);
}
struct bluebird_token_run {
    struct bluebird_token_run *prev;
    uint16_t number_of_tokens;
    uint16_t lengths_size;
    uint8_t lengths[4096 * 2];
    uint32_t tokens[4096];
    uint32_t states[4096];
};
struct bluebird_default_tokenizer {
    const char *text;
    size_t offset;
    size_t whitespace;
    uint32_t identifier_token;
    uint32_t number_token;
    uint32_t string_token;
    void *info;
};
static bool char_is_whitespace(char c) {
    switch (c) {
    case ' ':
    case '\t':
    case '\r':
    case '\n':
        return true;
    default:
        return false;
    }
}
static bool char_is_numeric(char c) {
    return c >= '0' && c <= '9';
}
static bool char_is_alphabetic(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}
static bool char_starts_identifier(char c) {
    return char_is_alphabetic(c) || c == '_';
}
static bool char_continues_identifier(char c, void *info) {
    if (true && c == '-') return true;
    return char_is_numeric(c) || char_starts_identifier(c);
}
static bool encode_length(struct bluebird_token_run *run, uint16_t *lengths_size, size_t length) {
    uint8_t mark = 0;
    while (*lengths_size < sizeof(run->lengths)) {
        run->lengths[*lengths_size] = mark | (length & 0x7f);
        mark = 0x80;
        length >>= 7;
        (*lengths_size)++;
        if (length == 0) return true;
    }
    return false;
}
static bool encode_token_length(struct bluebird_token_run *run, uint16_t *lengths_size, size_t length, size_t whitespace) {
    uint16_t size = *lengths_size;
    if (encode_length(run, lengths_size, length) && encode_length(run, lengths_size, whitespace)) return true;
    *lengths_size = size;
    return false;
}
static size_t decode_length(struct bluebird_token_run *run, uint16_t *length_offset) {
    size_t length = 0;
    while (*length_offset < sizeof(run->lengths)) {
        size_t l = run->lengths[(*length_offset)--];
        length <<= 7;
        length += l & 0x7f;
        if (!(l & 0x80)) return length;
    }
    abort();
}
static size_t decode_token_length(struct bluebird_token_run *run, uint16_t *length_offset, size_t *string_offset) {
    size_t whitespace = decode_length(run, length_offset);
    size_t length = decode_length(run, length_offset);
    *string_offset -= whitespace + length;
    return length;
}
static bool bluebird_default_tokenizer_advance(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run **previous_run) {
    struct bluebird_token_run *run = malloc(sizeof(struct bluebird_token_run));
    if (!run) return false;
    uint16_t number_of_tokens = 0;
    uint16_t lengths_size = 0;
    const char *text = tokenizer->text;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset;
    while (number_of_tokens < 4096) {
        char c = text[offset];
        if (c == '\0') break;
        if (char_is_whitespace(c)) {
            whitespace++;
            offset++;
            continue;
        }
        uint32_t token;
        bool is_token = false;
        bool end_token = false;
        bool comment = false;
        size_t token_length = read_keyword_token(&token, &end_token, text + offset, tokenizer->info);
        if (token_length > 0) {
            is_token = true;
            if (token == 0xffffffff) comment = true;
        }
        double number = 0;
        if (char_is_numeric(c) || (c == '.' && char_is_numeric(text[offset + 1]))) {
            const char *start = (const char *)text + offset;
            char *rest = 0;
            number = strtod(start, &rest);
            if (rest > start && rest - start > token_length) {
                token_length = rest - start;
                is_token = true;
                end_token = false;
                comment = false;
                token = 21;
            }
        }
        else if (c == '\'' || c == '"') {
            size_t string_offset = offset + 1;
            while (text[string_offset] != '\0') {
                if (text[string_offset] == c) {
                    token_length = string_offset + 1 - offset;
                    is_token = true;
                    end_token = false;
                    comment = false;
                    token = 22;
                    break;
                }
                if (text[string_offset] == '\\') {
                    string_offset++;
                    if (text[string_offset] == '\0') break;
                }
                string_offset++;
            }
        }
        else if (char_starts_identifier(c)) {
            size_t identifier_offset = offset + 1;
            while (char_continues_identifier(text[identifier_offset], tokenizer->info)) identifier_offset++;
            if (identifier_offset - offset > token_length) {
                token_length = identifier_offset - offset;
                is_token = true;
                end_token = false;
                comment = false;
                token = 20;
            }
        }
        if (comment) {
            while (text[offset] != '\0' && text[offset] != '\n') {
                whitespace++;
                offset++;
            }
            continue;
        }
        else if (!is_token || token == 0xffffffff) {
            tokenizer->offset = offset;
            tokenizer->whitespace = whitespace;
            free(run);
            return false;
        }
        if (end_token && number_of_tokens + 1 >= 4096) break;
        if (!encode_token_length(run, &lengths_size, token_length, whitespace)) break;
        if (token == 20) {
            write_identifier_token(offset, token_length, tokenizer->info);
        }
        else if (token == 21) {
            write_number_token(offset, token_length, number, tokenizer->info);
        }
        else if (token == 22) {
            write_string_token(offset, token_length, offset + 1, token_length - 2, tokenizer->info);
        }
        run->tokens[number_of_tokens] = token;
        whitespace = 0;
        number_of_tokens++;
        offset += token_length;
        if (end_token) {
            assert(number_of_tokens < 4096);
            run->tokens[number_of_tokens] = 4294967295U;
            number_of_tokens++;
        }
    }
    if (number_of_tokens == 0) {
        tokenizer->offset = offset;
        tokenizer->whitespace = whitespace;
        free(run);
        return false;
    }
    tokenizer->offset = offset;
    tokenizer->whitespace = whitespace;
    run->prev = *previous_run;
    run->number_of_tokens = number_of_tokens;
    run->lengths_size = lengths_size;
    *previous_run = run;
    return true;
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context);
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context);
static size_t number_of_slots_lookup(uint32_t rule, void *context);
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context);
enum construct_fixity_associativity {
CONSTRUCT_PREFIX, CONSTRUCT_POSTFIX, CONSTRUCT_INFIX_LEFT, CONSTRUCT_INFIX_RIGHT, CONSTRUCT_INFIX_FLAT, };
struct construct_node {
    struct construct_node *next;
    size_t number_of_slots;
    parsed_id *slots;
    uint32_t rule;
    uint16_t slot_index;
    uint16_t choice_index;
    enum construct_fixity_associativity fixity_associativity;
    int precedence;
    size_t start_location;
    size_t end_location;
};
struct construct_expression {
    struct construct_expression *parent;
    struct construct_node *first_operator;
    struct construct_node *first_value;
    uint32_t operand_slot_index;
    uint32_t left_slot_index;
    uint32_t right_slot_index;
    uint32_t rule;
    uint16_t slot_index;
};
enum construct_root_type {
CONSTRUCT_NORMAL_ROOT, CONSTRUCT_EXPRESSION_ROOT, };
struct construct_state {
    enum construct_root_type root_type;
    struct construct_node *under_construction;
    struct construct_expression *current_expression;
    struct construct_node *node_freelist;
    struct construct_expression *expression_freelist;
    void *info;
};
static struct construct_node *construct_node_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_node *node;
    size_t number_of_slots = number_of_slots_lookup(rule, s->info);
    if (s->node_freelist) {
        node = s->node_freelist;
        s->node_freelist = node->next;
        parsed_id *slots = node->slots;
        if (number_of_slots > node->number_of_slots) {
            slots = realloc(slots, number_of_slots * sizeof(parsed_id));
            if (!slots) abort();
        }
        memset(node, 0, sizeof(struct construct_node));
        memset(slots, 0, number_of_slots * sizeof(parsed_id));
        node->slots = slots;
    }
    else {
        node = calloc(1, sizeof(struct construct_node));
        if (!node) abort();
        node->slots = calloc(number_of_slots, sizeof(parsed_id));
        if (!node->slots) abort();
    }
    node->rule = rule;
    node->number_of_slots = number_of_slots;
    return node;
}
static struct construct_expression *construct_expression_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_expression *expr;
    if (s->expression_freelist) {
        expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        memset(expr, 0, sizeof(struct construct_expression));
    }
    else {
        expr = calloc(1, sizeof(struct construct_expression));
        if (!expr) abort();
    }
    (left_right_operand_slots_lookup(rule, &(expr->left_slot_index), &(expr->right_slot_index), &(expr->operand_slot_index), s->info));
    expr->rule = rule;
    return expr;
}
static void construct_node_free(struct construct_state *state, struct construct_node *node) {
    node->next = state->node_freelist;
    state->node_freelist = node;
}
static void construct_expression_free(struct construct_state *state, struct construct_expression *expr) {
    expr->parent = state->expression_freelist;
    state->expression_freelist = expr;
}
static bool construct_expression_should_reduce(struct construct_state *s, struct construct_expression *expr, struct construct_node *node) {
    if (node->fixity_associativity == CONSTRUCT_POSTFIX) return false;
    struct construct_node *top = expr->first_operator;
    if (!top) return false;
    return node->precedence < top->precedence || (node->precedence == top->precedence && node->fixity_associativity == CONSTRUCT_INFIX_RIGHT);
}
static void construct_expression_reduce(struct construct_state *s, struct construct_expression *expr) {
    struct construct_node *op = expr->first_operator;
    if (op->fixity_associativity == CONSTRUCT_INFIX_FLAT) {
        struct construct_node *first_value = expr->first_value;
        struct construct_node *last_value = first_value;
        struct construct_node *last_operator = op;
        parsed_id operand = op->slots[expr->operand_slot_index];
        struct construct_node *combined_op = construct_node_alloc(s, op->rule);
        combined_op->choice_index = op->choice_index;
        combined_op->slot_index = op->slot_index;
        combined_op->fixity_associativity = op->fixity_associativity;
        combined_op->precedence = op->precedence;
        struct construct_node *reversed_values = 0;
        while (last_operator && last_operator->choice_index == op->choice_index) {
            struct construct_node *next_op = last_operator->next;
            construct_node_free(s, last_operator);
            last_operator = next_op;
            assert(last_value);
            struct construct_node *next_value = last_value->next;
            last_value->next = reversed_values;
            reversed_values = last_value;
            last_value = next_value;
        }
        combined_op->start_location = first_value->start_location;
        combined_op->end_location = last_value->end_location;
        assert(last_value);
        operand = (finish_node((last_value)->rule, (last_value)->choice_index, operand, (last_value)->slots, (last_value)->start_location, (last_value)->end_location, s->info));
        combined_op->next = last_value->next;
        construct_node_free(s, last_value);
        while (reversed_values) {
            operand = (finish_node((reversed_values)->rule, (reversed_values)->choice_index, operand, (reversed_values)->slots, (reversed_values)->start_location, (reversed_values)->end_location, s->info));
            struct construct_node *next_value = reversed_values->next;
            construct_node_free(s, reversed_values);
            reversed_values = next_value;
        }
        expr->first_operator = last_operator;
        expr->first_value = combined_op;
        combined_op->slots[expr->operand_slot_index] = operand;
    }
    else if (op->fixity_associativity == CONSTRUCT_INFIX_LEFT || op->fixity_associativity == CONSTRUCT_INFIX_RIGHT) {
        expr->first_operator = op->next;
        struct construct_node *left = expr->first_value;
        struct construct_node *right = left->next;
        op->next = right->next;
        expr->first_value = op;
        op->start_location = left->start_location;
        op->end_location = right->end_location;
        op->slots[expr->left_slot_index] = (finish_node((left)->rule, (left)->choice_index, op->slots[expr->left_slot_index], (left)->slots, (left)->start_location, (left)->end_location, s->info));
        op->slots[expr->right_slot_index] = (finish_node((right)->rule, (right)->choice_index, op->slots[expr->right_slot_index], (right)->slots, (right)->start_location, (right)->end_location, s->info));
        construct_node_free(s, left);
        construct_node_free(s, right);
    }
    else {
        expr->first_operator = op->next;
        struct construct_node *value = expr->first_value;
        op->next = value->next;
        expr->first_value = op;
        if (value->start_location < op->start_location) op->start_location = value->start_location;
        if (value->end_location > op->end_location) op->end_location = value->end_location;
        op->slots[expr->operand_slot_index] = (finish_node((value)->rule, (value)->choice_index, op->slots[expr->operand_slot_index], (value)->slots, (value)->start_location, (value)->end_location, s->info));
        construct_node_free(s, value);
    }
}
static void construct_begin(struct construct_state *s, size_t offset, enum construct_root_type type) {
    s->root_type = type;
    uint32_t r = 0;
    if (type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = construct_expression_alloc(s, r);
        expr->parent = s->current_expression;
        s->current_expression = expr;
    }
    else {
        struct construct_node *node = construct_node_alloc(s, r);
        node->next = s->under_construction;
        node->end_location = offset;
        s->under_construction = node;
    }
}
static parsed_id construct_finish(struct construct_state *s, size_t offset) {
    parsed_id finished = 0;
    if (s->root_type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = s->current_expression;
        s->current_expression = expr->parent;
        while (expr->first_operator) construct_expression_reduce(s, expr);
        struct construct_node *node = expr->first_value;
        if (node) {
            finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            assert(node->next == 0);
            construct_node_free(s, node);
        }
        construct_expression_free(s, expr);
    }
    else {
        struct construct_node *node = s->under_construction;
        s->under_construction = node->next;
        node->start_location = offset;
        finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
        construct_node_free(s, node);
    }
    while (s->node_freelist) {
        struct construct_node *node = s->node_freelist;
        s->node_freelist = node->next;
        free(node->slots);
        free(node);
    }
    while (s->expression_freelist) {
        struct construct_expression *expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        free(expr);
    }
    return finished;
}
static void construct_action_apply(struct construct_state *s, uint16_t action, size_t offset) {
    switch ((((action) >> 12) & 0xf)) {
    case 8:
        {
            struct construct_node *node = construct_node_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            node->next = s->under_construction;
            node->slot_index = ((action) & 0xfff);
            node->end_location = offset;
            s->under_construction = node;
            break;
        }
    case 9:
        {
            struct construct_expression *expr = construct_expression_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            expr->parent = s->current_expression;
            s->current_expression = expr;
            expr->slot_index = ((action) & 0xfff);
            break;
        }
    case 1:
        {
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            parsed_id *finished;
            finished = &s->under_construction->slots[node->slot_index];
            *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            construct_node_free(s, node);
            break;
        }
    case 2:
        {
            struct construct_expression *expr = s->current_expression;
            s->current_expression = expr->parent;
            while (expr->first_operator) construct_expression_reduce(s, expr);
            parsed_id *finished;
            finished = &s->under_construction->slots[expr->slot_index];
            struct construct_node *node = expr->first_value;
            if (node) {
                *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
                assert(node->next == 0);
                construct_node_free(s, node);
            }
            construct_expression_free(s, expr);
            break;
        }
    case 3:
        s->under_construction->choice_index = ((action) & 0xfff);
        break;
    case 4:
        {
            uint16_t slot = ((action) & 0xfff);
            parsed_id *finished = &s->under_construction->slots[slot];
            *finished = finish_token(rule_lookup(s->under_construction->rule, slot, s->info), *finished, s->info);
            break;
        }
    case 10:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 11:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            enum construct_fixity_associativity fixity_associativity;
            int precedence;
            do {
                int local;
                fixity_associativity_precedence_lookup(&local, &precedence, expr->rule, ((action) & 0xfff), s->info);
                fixity_associativity = local;
            }
            while (0);
            node->fixity_associativity = fixity_associativity;
            node->precedence = precedence;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 5:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            node->next = expr->first_value;
            expr->first_value = node;
            break;
        }
    case 6:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            while (construct_expression_should_reduce(s, expr, node)) construct_expression_reduce(s, expr);
            node->next = expr->first_operator;
            expr->first_operator = node;
            if (node->fixity_associativity == CONSTRUCT_PREFIX) construct_expression_reduce(s, expr);
            break;
        }
    }
}

struct state_stack {
    uint32_t *states;
    size_t capacity;
    size_t depth;
};
struct fill_run_continuation {
    uint32_t state;
    struct state_stack stack;
};
static bool fill_run_states(struct bluebird_token_run *, struct fill_run_continuation *);
static parsed_id build_parse_tree(struct bluebird_default_tokenizer *, struct bluebird_token_run *, struct bluebird_tree *);

static struct bluebird_tree *bluebird_tree_create_empty(void) {
    return calloc(1, sizeof(struct bluebird_tree));
}

struct bluebird_tree *bluebird_tree_create_from_string(const char *string) {
    struct bluebird_tree *tree = bluebird_tree_create_empty();
    tree->string = string;
    tree->next_id = 1;
    struct bluebird_default_tokenizer tokenizer = {
        .text = string,
        .info = tree,
    };
    struct bluebird_token_run *token_run = 0;
    struct fill_run_continuation c = {
        .state = 0,
    };
    while (bluebird_default_tokenizer_advance(&tokenizer, &token_run)) {
        if (!fill_run_states(token_run, &c)) {
            free(c.stack.states);
            tree->error = ERROR_UNEXPECTED_TOKEN;
            return tree;
        }
    }
    free(c.stack.states);
    if (string[tokenizer.offset] != '\0') {
        tree->error = ERROR_INVALID_TOKEN;
        tree->error_range.start = tokenizer.offset;
        tree->error_range.end = tokenizer.offset + 1;
        while (string[tree->error_range.end] != '\0' &&
         !char_is_whitespace(string[tree->error_range.end]) &&
         !char_continues_identifier(string[tree->error_range.end], tree))
            tree->error_range.end++;
        return tree;
    }
    switch (c.state) {
    case 0:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 11:
    case 13:
    case 15:
    case 16:
    case 45:
    case 49:
        break;
    default:
        tree->error = ERROR_MORE_INPUT_NEEDED;
        tree->error_range.start = tokenizer.offset - tokenizer.whitespace - 1;
        tree->error_range.end = tokenizer.offset - tokenizer.whitespace;
        if (tree->error_range.start > tree->error_range.end) {
            tree->error_range.start = tree->error_range.end;
            tree->error_range.end++;
        }
        return tree;
    }
    tree->root_id = build_parse_tree(&tokenizer, token_run, tree);
    return tree;
}
static struct bluebird_tree *bluebird_tree_create_with_error(enum bluebird_error e) {
    struct bluebird_tree *tree = bluebird_tree_create_empty();
    tree->error = e;
    return tree;
}
struct bluebird_tree *bluebird_tree_create_from_file(FILE *file) {
    if (!file)
        return bluebird_tree_create_with_error(ERROR_INVALID_FILE);
    char *str = 0;
    size_t len = 32;
    size_t off = 0;
    while (true) {
        len = len * 3 / 2;
        char *s = realloc(str, len * 3 / 2);
        if (!s) {
            free(str);
            return 0;
        }
        str = s;
        off += fread(str + off, 1, len - off, file);
        if (off < len) {
            str[off] = '\0';
            break;
        }
    }
    struct bluebird_tree *tree = bluebird_tree_create_from_string(str);
    if (!tree) {
        free(str);
        return 0;
    }
    tree->owns_string = true;
    return tree;
}
enum bluebird_error bluebird_tree_get_error(struct bluebird_tree *tree, struct source_range *error_range) {
    if (error_range)
        *error_range = tree->error_range;
    return tree->error;
}
void bluebird_tree_destroy(struct bluebird_tree *tree) {
    if (tree->owns_string)
        free((void *)tree->string);
    free(tree->parse_tree);
    free(tree->identifier_tokens);
    free(tree->number_tokens);
    for (uint32_t i = 0; i < tree->number_of_string_tokens; ++i)
        free((void *)tree->string_tokens[i].string);
    free(tree->string_tokens);
    free(tree);
}
static void grow_state_stack(struct state_stack *stack) {
    size_t new_capacity = (stack->capacity + 2) * 3 / 2;
    if (new_capacity <= stack->capacity)
        abort();
    uint32_t *new_states = realloc(stack->states, new_capacity * sizeof(uint32_t));
    if (!new_states)
        abort();
    stack->states = new_states;
    stack->capacity = new_capacity;
}
static bool fill_run_states(struct bluebird_token_run *run, struct fill_run_continuation *cont) {
    uint16_t token_index = 0;
    uint16_t number_of_tokens = run->number_of_tokens;
    uint32_t start_state = cont->state;
    if (start_state == 0) {
        // This is unnecessary, but it avoids a compiler warning about unused labels.
        goto state_0;
    }
start:
    switch (start_state) {
    case 0:
state_0: {
        if (token_index >= number_of_tokens) {
            cont->state = 0;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 0;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 20: goto state_2;
        default: break;
        }
        break;
    }
    case 1:
state_1: {
        if (token_index >= number_of_tokens) {
            cont->state = 1;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 1;
        token_index++;
        switch (token) {
        case 22: goto state_49;
        default: break;
        }
        break;
    }
    case 2:
state_2: {
        if (token_index >= number_of_tokens) {
            cont->state = 2;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 2;
        token_index++;
        switch (token) {
        case 1: goto state_3;
        default: break;
        }
        break;
    }
    case 3:
state_3: {
        if (token_index >= number_of_tokens) {
            cont->state = 3;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 3;
        token_index++;
        switch (token) {
        case 20: goto state_4;
        case 22: goto state_5;
        case 24: goto state_6;
        case 23: goto state_7;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 3;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 4:
state_4: {
        if (token_index >= number_of_tokens) {
            cont->state = 4;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 4;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 11: goto state_14;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_13;
        case 22: goto state_5;
        case 24: goto state_6;
        case 23: goto state_7;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 4;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 5:
state_5: {
        if (token_index >= number_of_tokens) {
            cont->state = 5;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 5;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_13;
        case 22: goto state_5;
        case 24: goto state_6;
        case 23: goto state_7;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 5;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 6:
state_6: {
        if (token_index >= number_of_tokens) {
            cont->state = 6;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 6;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_13;
        case 22: goto state_5;
        case 24: goto state_6;
        case 23: goto state_7;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 6;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 7:
state_7: {
        if (token_index >= number_of_tokens) {
            cont->state = 7;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 7;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_13;
        case 22: goto state_5;
        case 24: goto state_6;
        case 23: goto state_7;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 7;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 8:
state_8: {
        if (token_index >= number_of_tokens) {
            cont->state = 8;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 8;
        token_index++;
        switch (token) {
        case 20: goto state_16;
        default: break;
        }
        break;
    }
    case 9:
state_9: {
        if (token_index >= number_of_tokens) {
            cont->state = 9;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 9;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_13;
        case 22: goto state_5;
        case 24: goto state_6;
        case 23: goto state_7;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 9;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 10:
state_10: {
        if (token_index >= number_of_tokens) {
            cont->state = 10;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 10;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_13;
        case 22: goto state_5;
        case 24: goto state_6;
        case 23: goto state_7;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 10;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 11:
state_11: {
        if (token_index >= number_of_tokens) {
            cont->state = 11;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 11;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_13;
        case 22: goto state_5;
        case 24: goto state_6;
        case 23: goto state_7;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 11;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 12:
state_12: {
        if (token_index >= number_of_tokens) {
            cont->state = 12;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 12;
        token_index++;
        switch (token) {
        case 20: goto state_4;
        case 22: goto state_5;
        case 24: goto state_6;
        case 23: goto state_7;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 12;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 13:
state_13: {
        if (token_index >= number_of_tokens) {
            cont->state = 13;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 13;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 1: goto state_3;
        case 2: goto state_8;
        case 11: goto state_14;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_13;
        case 22: goto state_5;
        case 24: goto state_6;
        case 23: goto state_7;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 13;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 14:
state_14: {
        if (token_index >= number_of_tokens) {
            cont->state = 14;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 14;
        token_index++;
        switch (token) {
        case 20: goto state_15;
        default: break;
        }
        break;
    }
    case 15:
state_15: {
        if (token_index >= number_of_tokens) {
            cont->state = 15;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 15;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 16: goto state_9;
        case 17: goto state_10;
        case 18: goto state_11;
        case 19: goto state_12;
        case 20: goto state_13;
        case 22: goto state_5;
        case 24: goto state_6;
        case 23: goto state_7;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 15;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 16:
state_16: {
        if (token_index >= number_of_tokens) {
            cont->state = 16;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 16;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 3: goto state_17;
        case 20: goto state_18;
        case 22: goto state_19;
        case 24: goto state_20;
        case 23: goto state_21;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 16;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 17:
state_17: {
        if (token_index >= number_of_tokens) {
            cont->state = 17;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 17;
        token_index++;
        switch (token) {
        case 4: goto state_29;
        case 5: goto state_30;
        case 6: goto state_31;
        default: break;
        }
        break;
    }
    case 18:
state_18: {
        if (token_index >= number_of_tokens) {
            cont->state = 18;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 18;
        token_index++;
        switch (token) {
        case 1: goto state_3;
        case 2: goto state_8;
        case 11: goto state_27;
        case 16: goto state_22;
        case 17: goto state_23;
        case 18: goto state_24;
        case 19: goto state_25;
        case 20: goto state_26;
        case 22: goto state_19;
        case 24: goto state_20;
        case 23: goto state_21;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 18;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 19:
state_19: {
        if (token_index >= number_of_tokens) {
            cont->state = 19;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 19;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 16: goto state_22;
        case 17: goto state_23;
        case 18: goto state_24;
        case 19: goto state_25;
        case 20: goto state_26;
        case 22: goto state_19;
        case 24: goto state_20;
        case 23: goto state_21;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 19;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 20:
state_20: {
        if (token_index >= number_of_tokens) {
            cont->state = 20;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 20;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 16: goto state_22;
        case 17: goto state_23;
        case 18: goto state_24;
        case 19: goto state_25;
        case 20: goto state_26;
        case 22: goto state_19;
        case 24: goto state_20;
        case 23: goto state_21;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 20;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 21:
state_21: {
        if (token_index >= number_of_tokens) {
            cont->state = 21;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 21;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 16: goto state_22;
        case 17: goto state_23;
        case 18: goto state_24;
        case 19: goto state_25;
        case 20: goto state_26;
        case 22: goto state_19;
        case 24: goto state_20;
        case 23: goto state_21;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 21;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 22:
state_22: {
        if (token_index >= number_of_tokens) {
            cont->state = 22;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 22;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 16: goto state_22;
        case 17: goto state_23;
        case 18: goto state_24;
        case 19: goto state_25;
        case 20: goto state_26;
        case 22: goto state_19;
        case 24: goto state_20;
        case 23: goto state_21;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 22;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 23:
state_23: {
        if (token_index >= number_of_tokens) {
            cont->state = 23;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 23;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 16: goto state_22;
        case 17: goto state_23;
        case 18: goto state_24;
        case 19: goto state_25;
        case 20: goto state_26;
        case 22: goto state_19;
        case 24: goto state_20;
        case 23: goto state_21;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 23;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 24:
state_24: {
        if (token_index >= number_of_tokens) {
            cont->state = 24;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 24;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 16: goto state_22;
        case 17: goto state_23;
        case 18: goto state_24;
        case 19: goto state_25;
        case 20: goto state_26;
        case 22: goto state_19;
        case 24: goto state_20;
        case 23: goto state_21;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 24;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 25:
state_25: {
        if (token_index >= number_of_tokens) {
            cont->state = 25;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 25;
        token_index++;
        switch (token) {
        case 20: goto state_26;
        case 22: goto state_19;
        case 24: goto state_20;
        case 23: goto state_21;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 25;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 26:
state_26: {
        if (token_index >= number_of_tokens) {
            cont->state = 26;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 26;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 11: goto state_27;
        case 16: goto state_22;
        case 17: goto state_23;
        case 18: goto state_24;
        case 19: goto state_25;
        case 20: goto state_26;
        case 22: goto state_19;
        case 24: goto state_20;
        case 23: goto state_21;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 26;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 27:
state_27: {
        if (token_index >= number_of_tokens) {
            cont->state = 27;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 27;
        token_index++;
        switch (token) {
        case 20: goto state_28;
        default: break;
        }
        break;
    }
    case 28:
state_28: {
        if (token_index >= number_of_tokens) {
            cont->state = 28;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 28;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 16: goto state_22;
        case 17: goto state_23;
        case 18: goto state_24;
        case 19: goto state_25;
        case 20: goto state_26;
        case 22: goto state_19;
        case 24: goto state_20;
        case 23: goto state_21;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 28;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 29:
state_29: {
        if (token_index >= number_of_tokens) {
            cont->state = 29;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 29;
        token_index++;
        switch (token) {
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 29;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 30:
state_30: {
        if (token_index >= number_of_tokens) {
            cont->state = 30;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 30;
        token_index++;
        switch (token) {
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 30;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 31:
state_31: {
        if (token_index >= number_of_tokens) {
            cont->state = 31;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 31;
        token_index++;
        switch (token) {
        case 7: goto state_32;
        case 8: goto state_33;
        case 9: goto state_34;
        case 10: goto state_35;
        default: break;
        }
        break;
    }
    case 32:
state_32: {
        if (token_index >= number_of_tokens) {
            cont->state = 32;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 32;
        token_index++;
        switch (token) {
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 32;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 33:
state_33: {
        if (token_index >= number_of_tokens) {
            cont->state = 33;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 33;
        token_index++;
        switch (token) {
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 33;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 34:
state_34: {
        if (token_index >= number_of_tokens) {
            cont->state = 34;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 34;
        token_index++;
        switch (token) {
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 34;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 35:
state_35: {
        if (token_index >= number_of_tokens) {
            cont->state = 35;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 35;
        token_index++;
        switch (token) {
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 35;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 36:
state_36: {
        if (token_index >= number_of_tokens) {
            cont->state = 36;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 36;
        token_index++;
        switch (token) {
        case 2: goto state_40;
        case 11: goto state_47;
        case 16: goto state_41;
        case 17: goto state_42;
        case 18: goto state_43;
        case 19: goto state_44;
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 36;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 37:
state_37: {
        if (token_index >= number_of_tokens) {
            cont->state = 37;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 37;
        token_index++;
        switch (token) {
        case 2: goto state_40;
        case 16: goto state_41;
        case 17: goto state_42;
        case 18: goto state_43;
        case 19: goto state_44;
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 37;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 38:
state_38: {
        if (token_index >= number_of_tokens) {
            cont->state = 38;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 38;
        token_index++;
        switch (token) {
        case 2: goto state_40;
        case 16: goto state_41;
        case 17: goto state_42;
        case 18: goto state_43;
        case 19: goto state_44;
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 38;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 39:
state_39: {
        if (token_index >= number_of_tokens) {
            cont->state = 39;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 39;
        token_index++;
        switch (token) {
        case 2: goto state_40;
        case 16: goto state_41;
        case 17: goto state_42;
        case 18: goto state_43;
        case 19: goto state_44;
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 39;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 40:
state_40: {
        if (token_index >= number_of_tokens) {
            cont->state = 40;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 40;
        token_index++;
        switch (token) {
        case 20: goto state_45;
        default: break;
        }
        break;
    }
    case 41:
state_41: {
        if (token_index >= number_of_tokens) {
            cont->state = 41;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 41;
        token_index++;
        switch (token) {
        case 2: goto state_40;
        case 16: goto state_41;
        case 17: goto state_42;
        case 18: goto state_43;
        case 19: goto state_44;
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 41;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 42:
state_42: {
        if (token_index >= number_of_tokens) {
            cont->state = 42;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 42;
        token_index++;
        switch (token) {
        case 2: goto state_40;
        case 16: goto state_41;
        case 17: goto state_42;
        case 18: goto state_43;
        case 19: goto state_44;
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 42;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 43:
state_43: {
        if (token_index >= number_of_tokens) {
            cont->state = 43;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 43;
        token_index++;
        switch (token) {
        case 2: goto state_40;
        case 16: goto state_41;
        case 17: goto state_42;
        case 18: goto state_43;
        case 19: goto state_44;
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 43;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 44:
state_44: {
        if (token_index >= number_of_tokens) {
            cont->state = 44;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 44;
        token_index++;
        switch (token) {
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 44;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 45:
state_45: {
        if (token_index >= number_of_tokens) {
            cont->state = 45;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 45;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 3: goto state_17;
        case 20: goto state_46;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 45;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 46:
state_46: {
        if (token_index >= number_of_tokens) {
            cont->state = 46;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 46;
        token_index++;
        switch (token) {
        case 1: goto state_3;
        case 2: goto state_40;
        case 11: goto state_47;
        case 16: goto state_41;
        case 17: goto state_42;
        case 18: goto state_43;
        case 19: goto state_44;
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 46;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 47:
state_47: {
        if (token_index >= number_of_tokens) {
            cont->state = 47;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 47;
        token_index++;
        switch (token) {
        case 20: goto state_48;
        default: break;
        }
        break;
    }
    case 48:
state_48: {
        if (token_index >= number_of_tokens) {
            cont->state = 48;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 48;
        token_index++;
        switch (token) {
        case 2: goto state_40;
        case 16: goto state_41;
        case 17: goto state_42;
        case 18: goto state_43;
        case 19: goto state_44;
        case 20: goto state_36;
        case 22: goto state_37;
        case 24: goto state_38;
        case 23: goto state_39;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 48;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 49:
state_49: {
        if (token_index >= number_of_tokens) {
            cont->state = 49;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 49;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 20: goto state_2;
        default: break;
        }
        break;
    }
    case 50:
state_50: {
        if (token_index >= number_of_tokens) {
            cont->state = 50;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 50;
        token_index++;
        switch (token) {
        case 12: goto state_51;
        case 14: goto state_52;
        default: break;
        }
        break;
    }
    case 51:
state_51: {
        if (token_index >= number_of_tokens) {
            cont->state = 51;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 51;
        token_index++;
        switch (token) {
        case 20: goto state_67;
        case 22: goto state_68;
        case 24: goto state_69;
        case 23: goto state_70;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 51;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 52:
state_52: {
        if (token_index >= number_of_tokens) {
            cont->state = 52;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 52;
        token_index++;
        switch (token) {
        case 22: goto state_53;
        default: break;
        }
        break;
    }
    case 53:
state_53: {
        if (token_index >= number_of_tokens) {
            cont->state = 53;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 53;
        token_index++;
        switch (token) {
        case 20: goto state_54;
        case 22: goto state_55;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 53;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 54:
state_54: {
        if (token_index >= number_of_tokens) {
            cont->state = 54;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 54;
        token_index++;
        switch (token) {
        case 11: goto state_65;
        case 16: goto state_58;
        case 17: goto state_59;
        case 18: goto state_60;
        case 19: goto state_61;
        case 20: goto state_54;
        case 22: goto state_62;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 54;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 55:
state_55: {
        if (token_index >= number_of_tokens) {
            cont->state = 55;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 55;
        token_index++;
        switch (token) {
        case 15: goto state_63;
        case 16: goto state_58;
        case 17: goto state_59;
        case 18: goto state_60;
        case 19: goto state_61;
        case 20: goto state_54;
        case 22: goto state_62;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 55;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 56:
state_56: {
        if (token_index >= number_of_tokens) {
            cont->state = 56;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 56;
        token_index++;
        switch (token) {
        case 16: goto state_58;
        case 17: goto state_59;
        case 18: goto state_60;
        case 19: goto state_61;
        case 20: goto state_54;
        case 22: goto state_62;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 56;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 57:
state_57: {
        if (token_index >= number_of_tokens) {
            cont->state = 57;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 57;
        token_index++;
        switch (token) {
        case 16: goto state_58;
        case 17: goto state_59;
        case 18: goto state_60;
        case 19: goto state_61;
        case 20: goto state_54;
        case 22: goto state_62;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 57;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 58:
state_58: {
        if (token_index >= number_of_tokens) {
            cont->state = 58;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 58;
        token_index++;
        switch (token) {
        case 16: goto state_58;
        case 17: goto state_59;
        case 18: goto state_60;
        case 19: goto state_61;
        case 20: goto state_54;
        case 22: goto state_62;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 58;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 59:
state_59: {
        if (token_index >= number_of_tokens) {
            cont->state = 59;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 59;
        token_index++;
        switch (token) {
        case 16: goto state_58;
        case 17: goto state_59;
        case 18: goto state_60;
        case 19: goto state_61;
        case 20: goto state_54;
        case 22: goto state_62;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 59;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 60:
state_60: {
        if (token_index >= number_of_tokens) {
            cont->state = 60;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 60;
        token_index++;
        switch (token) {
        case 16: goto state_58;
        case 17: goto state_59;
        case 18: goto state_60;
        case 19: goto state_61;
        case 20: goto state_54;
        case 22: goto state_62;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 60;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 61:
state_61: {
        if (token_index >= number_of_tokens) {
            cont->state = 61;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 61;
        token_index++;
        switch (token) {
        case 20: goto state_54;
        case 22: goto state_64;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 61;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 62:
state_62: {
        if (token_index >= number_of_tokens) {
            cont->state = 62;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 62;
        token_index++;
        switch (token) {
        case 15: goto state_63;
        case 16: goto state_58;
        case 17: goto state_59;
        case 18: goto state_60;
        case 19: goto state_61;
        case 20: goto state_54;
        case 22: goto state_62;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 62;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 63:
state_63: {
        if (cont->stack.depth == 0)
            break;
        start_state = cont->stack.states[--cont->stack.depth];
        run->tokens[token_index] = 23;
        goto start;
    }
    case 64:
state_64: {
        if (token_index >= number_of_tokens) {
            cont->state = 64;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 64;
        token_index++;
        switch (token) {
        case 16: goto state_58;
        case 17: goto state_59;
        case 18: goto state_60;
        case 19: goto state_61;
        case 20: goto state_54;
        case 22: goto state_62;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 64;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 65:
state_65: {
        if (token_index >= number_of_tokens) {
            cont->state = 65;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 65;
        token_index++;
        switch (token) {
        case 20: goto state_66;
        default: break;
        }
        break;
    }
    case 66:
state_66: {
        if (token_index >= number_of_tokens) {
            cont->state = 66;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 66;
        token_index++;
        switch (token) {
        case 16: goto state_58;
        case 17: goto state_59;
        case 18: goto state_60;
        case 19: goto state_61;
        case 20: goto state_54;
        case 22: goto state_62;
        case 24: goto state_56;
        case 23: goto state_57;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 66;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 67:
state_67: {
        if (token_index >= number_of_tokens) {
            cont->state = 67;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 67;
        token_index++;
        switch (token) {
        case 11: goto state_76;
        case 13: goto state_71;
        case 16: goto state_72;
        case 17: goto state_73;
        case 18: goto state_74;
        case 19: goto state_75;
        case 20: goto state_67;
        case 22: goto state_68;
        case 24: goto state_69;
        case 23: goto state_70;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 67;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 68:
state_68: {
        if (token_index >= number_of_tokens) {
            cont->state = 68;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 68;
        token_index++;
        switch (token) {
        case 13: goto state_71;
        case 16: goto state_72;
        case 17: goto state_73;
        case 18: goto state_74;
        case 19: goto state_75;
        case 20: goto state_67;
        case 22: goto state_68;
        case 24: goto state_69;
        case 23: goto state_70;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 68;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 69:
state_69: {
        if (token_index >= number_of_tokens) {
            cont->state = 69;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 69;
        token_index++;
        switch (token) {
        case 13: goto state_71;
        case 16: goto state_72;
        case 17: goto state_73;
        case 18: goto state_74;
        case 19: goto state_75;
        case 20: goto state_67;
        case 22: goto state_68;
        case 24: goto state_69;
        case 23: goto state_70;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 69;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 70:
state_70: {
        if (token_index >= number_of_tokens) {
            cont->state = 70;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 70;
        token_index++;
        switch (token) {
        case 13: goto state_71;
        case 16: goto state_72;
        case 17: goto state_73;
        case 18: goto state_74;
        case 19: goto state_75;
        case 20: goto state_67;
        case 22: goto state_68;
        case 24: goto state_69;
        case 23: goto state_70;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 70;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 71:
state_71: {
        if (cont->stack.depth == 0)
            break;
        start_state = cont->stack.states[--cont->stack.depth];
        run->tokens[token_index] = 24;
        goto start;
    }
    case 72:
state_72: {
        if (token_index >= number_of_tokens) {
            cont->state = 72;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 72;
        token_index++;
        switch (token) {
        case 13: goto state_71;
        case 16: goto state_72;
        case 17: goto state_73;
        case 18: goto state_74;
        case 19: goto state_75;
        case 20: goto state_67;
        case 22: goto state_68;
        case 24: goto state_69;
        case 23: goto state_70;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 72;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 73:
state_73: {
        if (token_index >= number_of_tokens) {
            cont->state = 73;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 73;
        token_index++;
        switch (token) {
        case 13: goto state_71;
        case 16: goto state_72;
        case 17: goto state_73;
        case 18: goto state_74;
        case 19: goto state_75;
        case 20: goto state_67;
        case 22: goto state_68;
        case 24: goto state_69;
        case 23: goto state_70;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 73;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 74:
state_74: {
        if (token_index >= number_of_tokens) {
            cont->state = 74;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 74;
        token_index++;
        switch (token) {
        case 13: goto state_71;
        case 16: goto state_72;
        case 17: goto state_73;
        case 18: goto state_74;
        case 19: goto state_75;
        case 20: goto state_67;
        case 22: goto state_68;
        case 24: goto state_69;
        case 23: goto state_70;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 74;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 75:
state_75: {
        if (token_index >= number_of_tokens) {
            cont->state = 75;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 75;
        token_index++;
        switch (token) {
        case 20: goto state_67;
        case 22: goto state_68;
        case 24: goto state_69;
        case 23: goto state_70;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 75;
            token_index--;
            goto state_50;
        }
        break;
    }
    case 76:
state_76: {
        if (token_index >= number_of_tokens) {
            cont->state = 76;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 76;
        token_index++;
        switch (token) {
        case 20: goto state_77;
        default: break;
        }
        break;
    }
    case 77:
state_77: {
        if (token_index >= number_of_tokens) {
            cont->state = 77;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 77;
        token_index++;
        switch (token) {
        case 13: goto state_71;
        case 16: goto state_72;
        case 17: goto state_73;
        case 18: goto state_74;
        case 19: goto state_75;
        case 20: goto state_67;
        case 22: goto state_68;
        case 24: goto state_69;
        case 23: goto state_70;
        default:
            if (cont->stack.depth >= cont->stack.capacity)
                grow_state_stack(&cont->stack);
            cont->stack.states[cont->stack.depth++] = 77;
            token_index--;
            goto state_50;
        }
        break;
    }
    }
    return false;
}
static const uint16_t actions[] = {
0,0,4096,0,4096,16385,0,4096,32768,16384,0,4096,32769,32769,16385,0,4096,32769,32769,32770,32769,16385,0,4096,32769,32769,36864,40960,16384,0,
4096,32769,32769,36864,40960,16385,0,4096,32769,32769,36864,40961,16386,0,4096,32769,32769,36864,40962,0,4096,32769,32769,36864,40963,0,4096,32769,32769,36864,
45060,0,4096,32769,32769,36864,45061,0,4096,32769,32769,36864,45062,0,4096,32770,32769,16385,0,16384,0,16388,0,16389,0,20480,8192,0,20480,8192,
4096,0,20480,8192,4096,32768,12288,0,20480,8192,4096,32768,12289,0,20480,8192,4096,32768,12290,32768,12288,0,20480,8192,4096,32768,12290,32768,12289,0,
20480,8192,4096,32768,12290,32768,12290,0,20480,8192,4096,32768,12290,32768,12291,0,20480,8192,4096,32769,16385,0,20480,8192,16385,0,20480,8192,16388,0,
20480,45063,24576,40960,16384,0,20480,45063,24576,40960,16385,0,20480,45063,24576,40961,16386,0,20480,45063,24576,40962,0,20480,45063,24576,40963,0,20480,45063,
24576,45060,0,20480,45063,24576,45061,0,20480,45063,24576,45062,0,20480,45064,0,24576,40960,16384,0,24576,40960,16385,0,24576,40961,16386,0,24576,40962,
0,24576,40963,0,24576,45060,0,24576,45061,0,24576,45062,0,32768,16384,0,32769,32769,16385,0,32769,32769,32770,32769,16385,0,32769,32769,36864,40960,
16384,0,32769,32769,36864,40960,16385,0,32769,32769,36864,40961,16386,0,32769,32769,36864,40962,0,32769,32769,36864,40963,0,32769,32769,36864,45060,0,32769,
32769,36864,45061,0,32769,32769,36864,45062,0,36864,40960,16384,0,36864,40960,16385,0,36864,40961,16386,0,36864,40962,0,36864,40963,0,36864,45060,0,
36864,45061,0,36864,45062,0,36867,40960,16384,0,36867,40960,16385,0,36867,40961,16386,0,36867,40962,0,36867,40963,0,36867,45060,0,36867,45061,0,
36867,45062,0,};
struct action_table_entry {
    uint32_t target_nfa_state;
    uint32_t dfa_state;
    uint32_t dfa_symbol;
    uint32_t nfa_state;
    uint32_t actions;
    uint32_t push_nfa_state;
};
static const struct action_table_entry action_table[2048][2] = {
{0},{0},{0},{{3511,68,17,3437,327},{226,48,24,3568,208,162},},{0},{0},{{2263,40,20,3560,230},{245,9,19,2266,193},},{{162,36,24,3568,168,162},},{{3568,72,13,3511,0},
{2265,28,24,3568,208,2254},},{{3560,42,2,195,0},{232,64,16,2259,178},},{{2266,9,24,3568,208,245},},{0},{{2265,24,24,3568,208,2254},{226,43,20,162,196},},
{{2264,72,20,2264,150},{195,39,20,162,279},},{{2266,13,24,3568,208,245},},{{2261,7,16,2266,56},{162,40,20,3560,136},},{{2259,58,20,232,196},},
{0},{{3514,29,20,162,79},},{{2261,11,16,2266,56},},{{3511,77,23,3577,321,2264},{162,31,8,3583,112},},{{2301,22,23,3577,294,2254},{2254,25,23,3577,173,2254},},
{{195,48,24,3568,291,162},},{0},{{2265,16,20,2254,196},{162,35,24,3568,168,162},},{{3437,67,18,3437,220},{226,30,20,162,196},},{0},{{2263,15,22,245,248},
{245,6,17,2266,183},},{0},{0},{0},{{2279,11,22,245,287},{2258,62,18,2259,330},},{{162,39,20,162,150},},{0},{0},{0},{{2261,4,16,2266,56},},{{3511,74,17,3437,327},
{226,38,24,3568,208,162},},{{2279,15,23,3577,294,245},},{0},{0},{{226,42,24,3568,208,162},},{{2260,4,23,3577,259,245},},{0},{0},{{3556,28,20,2254,79},},{{226,46,23,3577,211,162},},
{0},{{2279,7,17,2266,300},},{{2301,23,22,2254,287},{2254,24,22,2254,162},},{{2258,53,20,232,306},},{0},{0},{{162,34,20,162,150},},{0},{{2266,4,16,2266,214},},
{{3514,39,20,162,79},{2263,12,22,245,248},},{{245,7,22,245,162},},{{226,33,24,3568,208,162},},{{162,17,5,3573,98},},{0},{0},{{2301,28,18,2265,303},
{2254,19,18,2265,188},},{{3437,73,22,2264,204},},{{2264,70,19,3437,193},},{{3511,75,24,3568,318,2264},},{{3556,19,20,2254,79},},{{2258,66,18,2259,330},
{232,54,20,232,150},},{{2264,74,19,3437,193},},{{3514,42,20,162,79},{2263,4,23,3577,259,245},},{{3437,77,23,3577,211,2264},{2260,7,20,245,236},},
{0},{0},{0},{0},{{195,33,20,162,279},},{{2266,7,16,2266,214},},{{3511,67,20,2264,306},{2261,13,24,3568,44,245},},{{245,4,18,2266,188},},{{232,62,24,3568,168,232},},
{{3437,69,17,3437,217},{2260,15,18,2266,274},},{{162,33,23,3577,173,162},},{0},{{2254,22,18,2265,188},},{0},{0},{0},{{3519,45,0,2261,0},},{{2279,9,23,3577,294,245},},
{{2266,10,16,2266,214},},{0},{0},{{2264,73,20,2264,150},{195,38,20,162,279},},{{3568,77,13,3511,0},{2261,6,23,3577,50,245},},{{162,41,20,162,150},},
{0},{{232,57,24,3568,168,232},},{{3514,30,20,162,79},{2263,5,22,245,248},},{{3511,76,20,3578,310},{2261,10,24,3568,44,245},},{{2265,27,20,3575,200},
{2260,6,24,3568,254,245},},{{232,61,24,3568,168,232},},{0},{0},{0},{0},{0},{{2261,14,20,3570,30},},{{3556,26,20,2254,79},},{0},{0},{{2279,10,22,245,287},},{{2265,19,24,3568,208,2254},},
{0},{{2264,68,20,2264,150},{195,43,20,162,279},},{{245,9,23,3577,173,245},},{{162,36,20,162,150},},{{2265,28,20,2254,196},{226,39,16,226,214},},
{{232,64,20,232,150},},{{3582,54,11,3535,0},{2263,6,18,2266,274},},{0},{{3437,75,23,3577,211,2264},{226,43,16,226,214},},{{2264,72,24,3568,168,2264},
{195,39,24,3568,291,162},},{0},{0},{{232,56,17,2259,183},},{0},{{195,35,23,3577,294,162},},{{2261,11,20,245,23},{162,44,24,3568,168,162},},{{2265,20,24,3568,208,2254},},
{{2279,6,17,2266,300},{2258,54,20,232,306},},{0},{{3514,44,20,162,79},{2263,11,18,2266,274},},{{2265,16,24,3568,208,2254},{162,35,20,162,150},},
{{3437,67,22,2264,204},},{{2266,5,24,3568,208,245},{162,48,17,226,183},},{{2263,15,18,2266,274},},{0},{0},{{2264,67,24,3568,168,2264},{195,44,24,3568,291,162},},
{{3512,24,2,2301,0},{3511,69,20,2264,306},},{{2254,20,19,2265,193},},{0},{{3437,72,22,2264,204},},{0},{{2261,4,20,245,23},{162,43,24,3568,168,162},},
{{3556,16,20,2254,79},{232,55,19,2259,193},},{0},{0},{{3535,66,20,232,79},{3514,43,20,162,79},},{{2265,25,24,3568,208,2254},},{0},{{3569,36,11,3514,0},
{2266,12,24,3568,208,245},},{{2259,59,17,2259,217},},{{2301,19,18,2265,303},{2254,28,18,2265,188},},{0},{{3568,67,13,3511,0},},{{2265,21,17,2265,217},},
{{2301,23,18,2265,303},{2254,24,18,2265,188},},{{2258,53,24,3568,318,232},},{0},{0},{{3437,68,17,3437,217},},{0},{0},{0},{{245,7,18,2266,188},},{0},{0},{{2266,11,24,3568,208,245},
{162,38,17,226,183},},{{245,11,18,2266,188},},{{2301,28,22,2254,287},{2254,19,22,2254,162},},{0},{{2266,15,24,3568,208,245},{162,42,17,226,183},},
{{226,37,23,3577,211,162},},{0},{{2258,66,22,232,314},{232,54,16,2259,178},},{{2264,74,23,3577,173,2264},{195,37,23,3577,294,162},},{0},{{2260,7,16,2266,264},
{226,41,24,3568,208,162},},{{3560,48,2,195,0},{232,58,16,2259,178},},{0},{0},{{226,45,24,3568,208,162},},{0},{{2266,7,20,245,196},},{{3511,67,24,3568,318,2264},
{2261,13,20,245,23},},{{245,4,22,245,162},},{0},{0},{{3519,7,0,2261,0},{3511,51,20,2264,306},},{{3568,70,13,3511,0},{2265,18,16,2265,214},},
{{2301,25,22,2254,287},{2254,22,22,2254,162},},{{2258,56,23,3577,321,232},},{{2259,66,17,2259,217},},{0},{{2260,11,17,2266,269},},{{3512,15,2,2279,0},
{232,65,20,3582,156},},{{2266,10,20,245,196},},{{2254,18,23,3577,173,2254},},{{3437,74,17,3437,217},{226,36,24,3568,208,162},},{{2264,73,16,3437,178},
{195,38,16,226,297},},{{2279,13,22,245,287},},{{3511,72,24,3568,318,2264},{162,41,16,226,178},},{{232,57,23,3577,173,232},},{{2264,77,16,3437,178},},
{{2263,5,18,2266,274},{2259,61,22,232,204},},{{2261,10,20,245,23},},{0},{{2301,21,17,2265,300},{2254,26,17,2265,183},},{0},{0},{{2265,23,16,2265,214},},
{0},{{3568,69,13,3511,0},{3512,6,2,2279,0},},{{245,5,23,3577,173,245},},{{245,18,1,3528,88},},{{226,35,24,3568,208,162},},{0},{{2279,10,18,2266,303},},
{0},{0},{{2264,68,16,3437,178},{195,43,16,226,297},},{0},{{162,36,16,226,178},},{{2265,28,16,2265,214},{226,39,20,162,196},},{{2266,9,23,3577,211,245},},
{{2263,6,22,245,248},},{{2259,62,23,3577,211,232},{245,13,22,245,162},},{{2265,24,16,2265,214},},{{2260,5,17,2266,269},},{{3511,73,17,3437,327},},
{0},{{2258,64,23,3577,321,232},},{0},{0},{{2265,20,23,3577,211,2254},},{0},{{2258,54,16,2259,324},{232,60,24,3568,168,232},},{{195,48,16,226,297},},{{2263,11,22,245,248},},
{0},{{2258,58,16,2259,324},},{{2261,15,17,2266,62},},{0},{0},{{226,34,20,162,196},},{0},{{3511,69,16,3437,324},},{{2254,20,23,3577,173,2254},},{0},{{3437,72,18,3437,220},},
{{162,43,23,3577,173,162},},{0},{{232,55,23,3577,173,232},},{0},{{195,36,17,226,300},},{{2263,7,17,2266,269},},{{2260,4,24,3568,254,245},},{{2279,3,23,3577,294,245},
{232,59,24,3568,168,232},},{{2266,12,20,245,196},},{0},{{2301,19,22,2254,287},{2254,28,22,2254,162},},{{195,32,24,3568,291,162},},{{2261,12,23,3577,50,245},},
{{3512,19,2,2301,0},},{0},{0},{{2259,55,18,2259,220},},{{3511,70,16,3437,324},},{{2260,12,20,245,236},},{{2301,24,22,2254,287},{2254,23,22,2254,162},},
{{2266,4,24,3568,208,245},{2258,57,17,2259,327},},{0},{{226,33,23,3577,211,162},},{0},{0},{{2266,11,20,245,196},},{{245,11,22,245,162},},{0},{{2264,70,24,3568,168,2264},
{195,41,24,3568,291,162},},{{2261,5,17,2266,62},},{0},{0},{{2264,74,24,3568,168,2264},{195,37,24,3568,291,162},},{{2259,60,22,232,204},{245,15,23,3577,173,245},},
{{2265,26,23,3577,211,2254},{162,46,24,3568,168,162},},{{226,41,20,162,196},},{{232,58,20,232,150},},{{2266,3,24,3568,208,245},},{{2301,20,17,2265,300},},
{{2265,22,24,3568,208,2254},{2260,3,20,245,236},},{0},{{2279,4,18,2266,303},{2266,7,24,3568,208,245},},{{2261,13,16,2266,56},{162,29,23,3577,173,162},},
{0},{{195,29,20,162,279},},{{2263,9,23,3577,259,245},{195,46,24,3568,291,162},},{{3511,51,24,3568,318,2264},},{{2265,18,20,2254,196},},{{2258,56,24,3568,318,232},},
{{2264,69,24,3568,168,2264},{195,42,24,3568,291,162},},{0},{0},{0},{{3560,43,2,195,0},{232,53,20,232,150},},{0},{{2254,18,19,2265,193},},{{226,36,20,162,196},},
{{3528,49,20,2261,79},},{{2279,13,18,2266,303},},{0},{{232,57,19,2259,193},},{{2264,77,20,2264,150},{195,34,20,162,279},},{0},{{2261,10,16,2266,56},
{162,45,20,162,150},},{0},{{2258,55,24,3568,318,232},},{0},{{2263,10,22,245,248},},{{2265,23,20,2254,196},{226,44,24,3568,208,162},},{0},{0},{{245,5,19,2266,193},},
{0},{{3437,70,18,3437,220},{226,35,20,162,196},},{{195,47,20,3569,283},},{{3511,68,24,3568,318,2264},{226,48,17,226,217},},{{2301,26,17,2265,300},
{2254,21,17,2265,183},},{0},{0},{{3514,37,20,162,79},},{{2260,10,20,245,236},},{0},{{2261,3,22,245,37},},{0},{{245,13,18,2266,188},},{{2265,24,20,2254,196},
{226,43,24,3568,208,162},},{0},{0},{0},{{2301,18,22,2254,287},},{{3437,51,22,2264,204},},{0},{{3511,77,24,3568,318,2264},{162,31,7,3583,104},},{{3556,25,20,2254,79},},
{{232,60,20,232,150},},{{195,48,20,162,279},},{0},{{3568,68,13,3511,0},{2260,13,20,245,236},},{{2258,58,20,232,306},},{{2266,5,16,2266,214},},
{{3514,32,20,162,79},},{0},{{2264,67,23,3577,173,2264},{195,44,23,3577,294,162},},{0},{{162,39,19,226,193},},{{2259,64,18,2259,220},{245,10,22,245,162},},
{{3556,20,20,2254,79},},{0},{{162,43,19,226,193},},{{3511,74,24,3568,318,2264},{226,38,17,226,217},},{{2254,16,22,2254,162},},{0},{0},{{226,42,17,226,217},},
{0},{{232,59,20,232,150},},{0},{0},{0},{{3557,70,20,2264,79},},{{2279,7,22,245,287},},{0},{0},{0},{{2259,55,22,232,204},{245,3,20,245,150},},{{3511,70,20,2264,306},},
{{2260,12,24,3568,254,245},},{{2301,24,18,2265,303},{2254,23,18,2265,188},},{0},{0},{0},{0},{0},{{2266,11,16,2266,214},},{0},{0},{{2264,70,20,2264,150},{195,41,20,162,279},},
{{2266,15,16,2266,214},},{{3511,75,20,2264,306},},{0},{{3557,67,20,2264,79},},{{2259,60,18,2259,220},{245,15,19,2266,193},},{{162,46,20,162,150},},
{{2260,7,24,3568,254,245},{226,41,16,226,214},},{{2266,3,23,3577,211,245},{2261,9,18,2266,68},},{{2259,56,18,2259,220},},{0},{{2265,22,20,2254,196},
{2260,3,24,3568,254,245},},{{195,33,24,3568,291,162},},{{2279,4,22,245,287},},{0},{{232,62,17,2259,183},},{{3437,69,22,2264,204},{195,29,24,3568,291,162},},
{{195,46,20,162,279},},{0},{0},{0},{0},{{3514,38,20,162,79},{2263,13,22,245,248},},{0},{{2279,9,16,2266,297},{2258,60,20,232,306},},{{162,37,18,226,188},},
{0},{{2263,4294967295U,4294967295U,2263,0,2263},},{{226,36,16,226,214},},{{2264,73,24,3568,168,2264},{195,38,24,3568,291,162},},{{3511,72,23,3577,321,2264},},{0},{{3556,18,20,2254,79},},
{{2264,77,24,3568,168,2264},{195,34,24,3568,291,162},},{0},{{2260,6,17,2266,269},},{{232,61,23,3577,173,232},},{0},{0},{{2263,10,18,2266,274},{2259,57,17,2259,217},},
{0},{{2279,5,23,3577,294,245},{2258,59,20,232,306},},{{2266,6,24,3568,208,245},},{{3514,33,20,162,79},},{0},{{3437,70,22,2264,204},},{0},{{2265,19,17,2265,217},},
{0},{{3556,21,20,2254,79},},{{2264,68,24,3568,168,2264},{195,43,24,3568,291,162},},{0},{{2260,10,16,2266,264},},{0},{0},{0},{{226,43,23,3577,211,162},},{{2264,72,17,3437,183},
{195,39,17,226,300},},{{2266,13,23,3577,211,245},},{0},{{2259,58,23,3577,211,232},},{{2301,18,18,2265,303},},{{3557,69,20,2264,79},},{{3519,16,0,2261,0},},
{{3511,77,20,2264,306},},{{2301,22,18,2265,303},},{{2258,54,24,3568,318,232},{232,60,16,2259,178},},{{2259,54,22,232,204},},{{2265,16,23,3577,211,2254},},
{{2260,13,16,2266,264},},{{2258,58,24,3568,318,232},},{{2266,5,20,245,196},},{0},{{2260,9,16,2266,264},},{{2264,67,19,3437,193},},{{2258,62,23,3577,321,232},},
{{3511,69,24,3568,318,2264},{162,39,23,3577,173,162},},{{2259,64,22,232,204},{245,10,18,2266,188},},{0},{{2263,3,23,3577,259,245},},{{3519,9,0,2261,0},},
{{3511,74,20,2264,306},},{0},{0},{0},{0},{{2260,4,16,2266,264},},{{232,59,16,2259,178},},{{2259,59,22,232,204},},{0},{{226,46,24,3568,208,162},},{0},{{2279,7,18,2266,303},},
{0},{0},{0},{{245,3,24,3568,168,245},},{{3519,6,0,2261,0},{3511,70,24,3568,318,2264},},{{226,29,23,3577,211,162},},{0},{0},{0},{0},{0},{{162,38,22,162,162},},{0},{0},{0},{{2264,70,16,3437,178},
{195,41,16,226,297},},{{2266,15,20,245,196},},{{232,66,18,2259,188},},{{2279,12,20,245,279},},{{2264,74,16,3437,178},{195,37,16,226,297},},
{{2263,4,18,2266,274},},{{162,46,16,226,178},},{0},{{2261,9,22,245,37},},{{2259,56,22,232,204},},{0},{{2265,22,16,2265,214},{226,45,20,162,196},},
{0},{{3512,7,2,2279,0},{3511,67,17,3437,327},},{0},{0},{{3437,69,18,3437,220},{2260,15,17,2266,269},},{{195,46,16,226,297},},{0},{0},{{2258,56,16,2259,324},},
{{2264,69,16,3437,178},{195,42,16,226,297},},{{2263,13,18,2266,274},},{{2260,11,24,3568,254,245},},{{2279,9,20,245,279},{2258,60,16,2259,324},},
{{162,37,22,162,162},},{0},{0},{{2264,73,23,3577,173,2264},{195,38,23,3577,294,162},},{{2261,6,18,2266,68},},{{3576,40,20,3560,74},},{0},{0},{0},{0},{0},{{2301,21,22,2254,287},
{2254,26,22,2254,162},},{{2258,55,16,2259,324},},{0},{0},{0},{{2258,59,16,2259,324},},{{2266,6,20,245,196},},{0},{0},{0},{{162,32,22,162,162},},{{3511,68,16,3437,324},},
{0},{0},{{3535,55,20,232,79},{245,9,16,2266,178},},{0},{{2265,28,23,3577,211,2254},},{{232,64,17,2259,183},},{0},{0},{{3437,75,20,2264,196},},{{2260,5,24,3568,254,245},},
{0},{{2261,7,17,2266,62},},{{2258,64,16,2259,324},{232,56,18,2259,188},},{0},{{195,35,24,3568,291,162},},{{2261,11,17,2266,62},},{{3511,77,16,3437,324},},
{{2301,22,22,2254,287},{2254,25,22,2254,162},},{{3570,13,11,3554,0},},{{2259,54,18,2259,220},},{{162,35,23,3577,173,162},},{0},{0},{{2263,15,23,3577,259,245},
{245,6,16,2266,178},},{0},{{2260,9,20,245,236},},{0},{{2279,11,23,3577,294,245},},{{2254,20,16,2265,178},},{0},{0},{0},{{2261,4,23,3577,50,245},},{{3511,74,16,3437,324},},
{{2279,15,20,245,279},},{{2264,75,24,3568,168,2264},{195,36,24,3568,291,162},},{{2263,7,22,245,248},},{0},{{2260,4,20,245,236},},{0},{{2259,59,18,2259,220},},
{0},{{226,46,20,162,196},},{{195,32,20,162,279},},{{2265,21,18,2265,220},},{{2301,23,23,3577,294,2254},{2254,24,23,3577,173,2254},},{{2258,53,23,3577,321,232},},
{0},{0},{0},{0},{{2266,4,17,2266,217},{2258,57,24,3568,318,232},},{0},{{245,7,23,3577,173,245},},{0},{{2258,61,24,3568,318,232},{162,17,4,3573,92},},{{162,38,18,226,188},},
{0},{{2301,28,17,2265,300},{2254,19,17,2265,183},},{{3437,73,23,3577,211,2264},},{{2261,5,22,245,37},{162,42,18,226,188},},{{226,37,18,226,220},},
{{232,66,22,232,162},},{{2279,12,24,3568,291,245},},{{2264,74,20,2264,150},{195,37,20,162,279},},{{2263,4,22,245,248},},{{3437,77,20,2264,196},
{2260,7,23,3577,259,245},},{0},{0},{0},{0},{0},{{2266,7,23,3577,211,245},},{0},{{245,4,17,2266,183},},{0},{{2263,9,16,2266,264},},{{162,33,22,162,162},},{0},{{2254,22,19,2265,193},},
{{2258,56,20,232,306},},{{2264,69,20,2264,150},{195,42,20,162,279},},{0},{{3554,5,20,245,79},{3528,7,20,2261,79},},{{2279,9,24,3568,291,245},},
{{2266,10,17,2266,217},},{{2263,1,22,3519,223},},{{3437,74,20,2264,196},},{{2264,73,19,3437,193},},{{2261,6,22,245,37},},{{162,41,23,3577,173,162},},
{0},{{2264,77,19,3437,193},},{{2263,5,23,3577,259,245},},{0},{0},{{2301,21,18,2265,303},{2254,26,18,2265,188},},{{2258,55,20,232,306},},{0},{0},{0},{0},{{2266,6,16,2266,214},},
{0},{0},{0},{0},{{3511,68,20,2264,306},},{0},{0},{{245,9,20,245,150},},{0},{{2260,10,24,3568,254,245},{226,39,23,3577,211,162},},{0},{{2263,6,17,2266,269},},{0},{{3437,75,24,3568,208,2264},},
{{2260,5,20,245,236},},{0},{0},{{2258,64,20,232,306},{232,56,22,232,162},},{0},{{2264,76,20,3578,156},{195,35,20,162,279},},{0},{0},{{2279,6,16,2266,297},},
{{3557,73,20,2264,79},},{0},{0},{{3437,67,23,3577,211,2264},{2260,13,24,3568,254,245},},{{2261,15,22,245,37},{162,48,18,226,188},},{{245,6,20,245,150},},
{0},{{2260,9,24,3568,254,245},},{0},{{3512,13,2,2279,0},},{{2301,27,20,3575,283},{2254,20,20,2254,150},},{0},{0},{0},{{226,38,22,162,204},},{{232,55,18,2259,188},},
{{2279,15,16,2266,297},},{{2264,75,20,2264,150},{195,36,20,162,279},},{{2263,7,18,2266,274},},{0},{0},{0},{0},{{2254,28,19,2265,193},},{{226,46,16,226,214},},
{0},{{3512,4,2,2279,0},{2265,21,22,2254,204},},{{2254,24,19,2265,193},},{{3556,24,20,2254,79},},{0},{0},{{3437,68,16,3437,214},},{0},{{2258,57,20,232,306},},
{{3578,67,11,3557,0},},{{245,7,19,2266,193},},{{3554,6,20,245,79},{3528,4,20,2261,79},},{0},{{2266,11,23,3577,211,245},},{{245,11,19,2266,193},},
{0},{0},{{2261,5,18,2266,68},{162,42,22,162,162},},{{226,37,22,162,204},},{0},{{2258,66,23,3577,321,232},{232,54,17,2259,183},},{{245,15,20,245,150},},
{{2265,26,18,2265,220},},{{3437,77,16,3437,214},},{{232,58,17,2259,183},},{0},{0},{0},{0},{{2279,4,17,2266,300},},{0},{0},{0},{{3575,26,11,3556,0},{2263,9,20,245,236},},
{0},{0},{{2301,25,23,3577,294,2254},{2254,22,23,3577,173,2254},},{0},{{2259,66,16,2259,214},},{{226,32,22,162,204},},{{2260,11,16,2266,264},},{{2258,60,24,3568,318,232},
{232,53,23,3577,173,232},},{0},{{2254,18,20,2254,150},},{{3437,74,16,3437,214},},{0},{{2279,13,23,3577,294,245},},{{162,41,19,226,193},},{{2258,65,20,3582,310},
{232,57,22,232,162},},{{2264,77,23,3577,173,2264},{195,34,23,3577,294,162},},{{3535,62,20,232,79},{2259,61,23,3577,211,232},},{{2261,10,23,3577,50,245},},
{0},{0},{{3557,72,20,2264,79},},{0},{{2265,23,17,2265,217},},{0},{{2258,59,24,3568,318,232},},{{245,5,20,245,150},},{0},{{3437,70,17,3437,217},{226,35,23,3577,211,162},},
{0},{{2279,10,17,2266,300},},{{2301,26,20,2254,279},{2254,21,20,2254,150},},{0},{{2264,68,17,3437,183},{195,43,17,226,300},},{{245,9,24,3568,168,245},},
{{162,36,17,226,183},},{{232,52,22,3580,146},},{{2266,9,22,245,204},},{{3535,59,20,232,79},},{{2259,62,22,232,204},{245,13,23,3577,173,245},},
{{2265,24,23,3577,211,2254},},{{2260,5,16,2266,264},},{{3511,73,18,3437,330},},{0},{{2258,64,24,3568,318,232},},{0},{0},{{2265,20,22,2254,204},},{0},{{2279,6,20,245,279},
{2258,54,17,2259,327},},{0},{{2263,11,23,3577,259,245},},{{3437,67,24,3568,208,2264},{2260,13,23,3577,259,245},},{{2258,58,17,2259,327},},{{2261,15,18,2266,68},
{162,48,22,162,162},},{{245,6,24,3568,168,245},},{0},{0},{{2279,11,24,3568,291,245},},{{3560,41,2,195,0},{3511,69,17,3437,327},},{{2259,64,17,2259,217},
{2254,20,24,3568,168,2254},},{0},{{3437,72,17,3437,217},},{{162,43,22,162,162},},{{226,38,18,226,220},},{{232,55,22,232,162},},{0},{{195,36,16,226,297},},
{{2265,25,22,2254,204},{226,42,18,226,220},},{0},{{2279,3,20,245,279},},{0},{0},{{2301,19,23,3577,294,2254},{2254,28,23,3577,173,2254},},{0},{{2261,12,22,245,37},},
{{162,30,22,162,162},},{0},{0},{{2263,8,20,3512,226},},{{3511,70,23,3577,321,2264},},{{3437,68,20,2264,196},},{0},{{2258,57,16,2259,324},},{0},{{226,33,22,162,204},},
{{195,45,22,162,287},},{0},{{2261,1,22,3519,7},},{{245,11,23,3577,173,245},},{{3437,73,24,3568,208,2264},},{0},{0},{0},{0},{{2264,51,20,2264,150},},{{2259,60,17,2259,217},
{245,15,16,2266,178},},{{2265,26,22,2254,204},},{{226,41,23,3577,211,162},},{0},{{3535,61,20,232,79},{2259,56,17,2259,217},},{{2301,20,16,2265,297},},
{{2260,3,23,3577,259,245},},{0},{0},{{2261,13,17,2266,62},{162,29,22,162,162},},{{232,62,22,232,162},},{{2260,15,24,3568,254,245},},{{2263,9,24,3568,254,245},
{195,46,23,3577,294,162},},{0},{{3512,22,2,2301,0},{2265,18,23,3577,211,2254},},{0},{0},{{2259,66,20,232,196},},{0},{{2260,11,20,245,236},},{{162,37,17,226,183},},
{{3535,58,20,232,79},},{{2254,18,16,2265,178},},{0},{{3575,18,11,3556,0},},{0},{0},{{3581,52,22,3580,81},{232,57,18,2259,188},},{0},{0},{{162,45,23,3577,173,162},},
{0},{0},{{195,30,24,3568,291,162},},{{2259,57,22,232,204},},{0},{{2279,5,20,245,279},{2258,59,23,3577,321,232},},{{2261,40,20,3560,16},},{{245,5,16,2266,178},},
{0},{{2260,14,20,3570,242},},{0},{{2265,19,22,2254,204},{226,48,18,226,220},},{{2301,26,16,2265,297},{2254,21,16,2265,178},},{0},{0},{0},{0},{0},{{2266,9,18,2266,220},
{2261,3,23,3577,50,245},},{0},{{2259,62,18,2259,220},{245,13,19,2266,193},},{{2264,72,18,3437,188},{195,39,18,226,303},},{{2266,13,18,2266,220},},
{{3560,46,2,195,0},{3511,73,22,2264,314},},{{2259,58,18,2259,220},},{{2301,18,17,2265,300},},{{3437,51,23,3577,211,2264},},{{162,44,22,162,162},},
{{2265,20,18,2265,220},},{{2301,22,17,2265,300},},{{2279,6,24,3568,291,245},},{{195,48,23,3577,294,162},},{0},{0},{0},{0},{0},{0},{{2264,67,22,2264,162},{195,44,22,162,287},},
{{2258,62,24,3568,318,232},},{{162,39,18,226,188},},{{245,10,17,2266,183},},{0},{0},{{162,43,18,226,188},},{{3511,74,23,3577,321,2264},},{{2254,16,23,3577,173,2254},},
{{2279,15,24,3568,291,245},},{0},{{226,42,22,162,204},},{{3554,15,20,245,79},{3528,13,20,2261,79},},{{2279,3,24,3568,291,245},{232,59,23,3577,173,232},},
{0},{{2301,19,24,3568,291,2254},{2254,28,24,3568,168,2254},},{0},{0},{{2279,7,23,3577,294,245},},{0},{0},{0},{{2259,55,23,3577,211,232},},{0},{{3437,68,24,3568,208,2264},},{{2301,24,17,2265,300},
{2254,23,17,2265,183},},{0},{{245,7,24,3568,168,245},},{0},{{2260,8,20,3512,226},},{{2258,61,20,232,306},},{{2259,65,20,3582,200},{245,11,24,3568,168,245},},
{{2301,28,24,3568,291,2254},{2254,19,24,3568,168,2254},},{{3554,10,20,245,79},},{0},{{2266,15,23,3577,211,245},},{0},{{2258,66,24,3568,318,232},},{0},{{2263,4,17,2266,269},},
{0},{{3437,77,24,3568,208,2264},},{{2266,3,22,245,204},},{0},{{2301,20,20,2254,279},{2254,27,20,3575,156},},{{2265,22,23,3577,211,2254},},{0},{{3546,62,22,2258,83},
{3511,67,18,3437,330},},{{245,4,24,3568,168,245},},{{232,62,18,2259,188},},{{3437,69,23,3577,211,2264},{2260,15,20,245,236},},{{3557,75,20,2264,79},},
{0},{{2301,25,24,3568,291,2254},{2254,22,24,3568,168,2254},},{0},{{2264,69,19,3437,193},{245,46,1,3528,88},},{{2263,13,23,3577,259,245},{2259,66,24,3568,208,232},},
{0},{{2279,9,17,2266,300},},{0},{{245,12,20,245,150},},{0},{{3437,74,24,3568,208,2264},{226,36,17,226,217},},{{3519,49,0,2261,0},{2261,6,17,2266,62},},
{{3511,72,22,2264,314},},{0},{0},{0},{{3557,68,20,2264,79},},{{2260,6,18,2266,274},},{{232,61,22,232,162},},{0},{{195,30,20,162,279},},{{2263,10,17,2266,269},
{2259,57,18,2259,220},},{0},{{2279,5,16,2266,297},},{0},{0},{0},{0},{0},{{2265,19,18,2265,220},{226,48,22,162,204},},{0},{0},{0},{0},{{2260,10,17,2266,269},},{{232,64,18,2259,188},},
{0},{0},{{226,43,22,162,204},},{{2264,72,22,2264,162},{195,39,22,162,287},},{{2266,13,22,245,204},},{{2261,7,22,245,37},},{{3573,45,3,3576,2},
{2259,58,22,232,204},},{{3554,12,20,245,79},{3437,51,24,3568,208,2264},},{0},{{3546,56,22,2258,83},},{{3512,5,2,2279,0},{162,31,10,3583,128},},
{0},{{232,60,17,2259,183},},{{2263,11,24,3568,254,245},},{{2265,16,22,2254,204},},{{3437,67,16,3437,214},{226,30,22,162,204},},{0},{{2266,5,23,3577,211,245},},
{0},{{2260,9,23,3577,259,245},},{{2264,67,18,3437,188},},{{2279,11,16,2266,297},{2258,62,20,232,306},},{{162,39,22,162,162},},{0},{{3554,11,20,245,79},
{3528,9,20,2261,79},},{{2263,3,20,245,236},},{{2261,4,18,2266,68},},{{3512,28,2,2301,0},},{0},{0},{0},{0},{{2260,4,17,2266,269},},{{232,59,19,2259,193},},
{{2259,59,23,3577,211,232},},{0},{0},{0},{0},{{2301,23,20,2254,279},{2254,24,20,2254,150},},{0},{0},{{3557,74,20,2264,79},},{{162,34,22,162,162},},{{226,29,22,162,204},},
{{2266,4,22,245,204},},{{2263,12,20,245,236},},{{245,7,20,245,150},},{0},{0},{{162,38,23,3577,173,162},},{0},{0},{{3437,73,16,3437,214},},{{2264,70,17,3437,183},
{195,41,17,226,300},},{{226,37,17,226,217},},{{2301,16,20,2254,279},{232,66,19,2259,193},},{{2279,12,23,3577,294,245},},{{2264,74,17,3437,183},
{195,37,17,226,300},},{{3535,57,20,232,79},{245,15,24,3568,168,245},},{{162,46,17,226,183},},{0},{{2261,9,23,3577,50,245},},{0},{{2301,20,24,3568,291,2254},},
{{226,45,23,3577,211,162},},{{2279,4,24,3568,291,245},{2266,7,18,2266,220},},{{3546,66,22,2258,83},{3511,67,22,2264,314},},{0},{0},{{2260,15,16,2266,264},},
{0},{0},{0},{{2258,56,17,2259,327},},{{2264,69,23,3577,173,2264},{195,42,23,3577,294,162},},{{3535,54,20,232,79},},{{3568,73,13,3511,0},{3519,11,0,2261,0},},
{{2258,60,17,2259,327},},{{2266,10,18,2266,220},},{{245,12,24,3568,168,245},},{{2254,18,24,3568,168,2254},},{{2264,73,22,2264,162},{195,38,22,162,287},},
{{2279,13,24,3568,291,245},},{{3511,72,18,3437,330},},{0},{0},{{2263,5,20,245,236},},{{3546,57,22,2258,83},},{{2260,6,22,245,248},},{{2301,21,23,3577,294,2254},
{2254,26,23,3577,173,2254},},{{2258,55,23,3577,321,232},},{0},{{226,44,22,162,204},},{{3519,0,0,2261,0},},{0},{0},{{2259,53,22,232,204},{245,5,24,3568,168,245},},
{{3437,70,24,3568,208,2264},},{0},{{2279,10,24,3568,291,245},{162,32,23,3577,173,162},},{{3512,10,2,2279,0},},{{2301,26,24,3568,291,2254},{2254,21,24,3568,168,2254},},
{{2264,68,22,2264,162},{195,43,22,162,287},},{{245,9,17,2266,183},},{0},{{2265,28,22,2254,204},{226,39,18,226,220},},{{232,64,22,232,162},},
{{2279,14,20,3570,283},},{0},{{226,43,18,226,220},},{{2260,5,23,3577,259,245},},{0},{{2261,7,18,2266,68},},{{2258,64,17,2259,327},{232,56,19,2259,193},},
{0},{0},{{2261,11,18,2266,68},},{{3511,77,17,3437,327},},{{2258,54,22,232,314},},{{3579,49,4294967295U,3579,0,2263},},{{2259,54,17,2259,217},},{{162,35,22,162,162},},
{{3437,67,20,2264,196},},{0},{{2263,15,20,245,236},{245,6,19,2266,193},},{0},{0},{0},{{2279,11,20,245,279},{2258,62,16,2259,324},},{{2259,64,24,3568,208,232},
{2254,20,17,2265,183},},{0},{{3437,72,24,3568,208,2264},},{{2263,3,24,3568,254,245},},{{2261,4,22,245,37},},{{232,55,17,2259,183},},{0},{0},{{3535,56,20,232,79},
{2263,7,23,3577,259,245},},{0},{{3437,76,20,3578,200},},{0},{0},{{2301,19,16,2265,297},{2254,28,16,2265,178},},{0},{{195,32,23,3577,294,162},},{0},{{2301,23,16,2265,297},
{2254,24,16,2265,178},},{{2258,53,22,232,314},},{0},{0},{0},{{3512,23,2,2301,0},},{{2266,4,18,2266,220},},{{2263,12,24,3568,254,245},},{{245,7,16,2266,178},},
{0},{0},{{3546,55,22,2258,83},{162,38,19,226,193},},{{3535,53,20,232,79},{245,11,16,2266,178},},{{2301,28,16,2265,297},{2254,19,16,2265,178},},
{{3437,73,20,2264,196},},{{2261,5,23,3577,50,245},{162,42,19,226,193},},{0},{{232,66,23,3577,173,232},},{{2258,66,16,2259,324},{232,54,22,232,162},},
{{2264,51,24,3568,168,2264},},{{2265,26,17,2265,217},},{{2260,7,22,245,248},},{0},{0},{0},{0},{{2260,4294967295U,4294967295U,2263,1,2263},{195,33,22,162,287},},{{2266,7,22,245,204},},
{{2261,13,22,245,37},},{{245,4,16,2266,178},},{0},{{2263,9,17,2266,269},},{{3511,51,22,2264,314},},{0},{{2254,22,16,2265,178},},{0},{0},{0},{0},{0},{{2266,10,22,245,204},},
{0},{{3437,74,23,3577,211,2264},},{{2264,73,18,3437,188},{195,38,18,226,303},},{{2279,13,20,245,279},},{{162,41,22,162,162},},{0},{{2264,77,18,3437,188},},
{{2263,5,16,2266,264},{2259,61,20,232,196},},{0},{0},{{2254,26,19,2265,193},},{0},{0},{0},{0},{{2279,5,24,3568,291,245},},{{2266,6,17,2266,217},},{0},{0},{0},{{2279,10,20,245,279},},
{{3560,38,2,195,0},{3511,68,23,3577,321,2264},},{0},{{2264,68,18,3437,188},{195,43,18,226,303},},{0},{{162,36,22,162,162},},{{2265,28,18,2265,220},
{226,39,22,162,204},},{0},{{2263,6,16,2266,264},},{{245,13,24,3568,168,245},},{{2265,24,18,2265,220},},{{3528,10,20,2261,79},},{0},{0},{{2301,18,24,3568,291,2254},
{232,56,23,3577,173,232},},{0},{0},{{2261,11,22,245,37},},{{2301,22,24,3568,291,2254},{2254,25,24,3568,168,2254},},{{2279,6,23,3577,294,245},{2258,54,18,2259,330},},
{0},{{2263,11,16,2266,264},},{0},{{2258,58,18,2259,330},},{{2261,15,23,3577,50,245},{162,48,19,226,193},},{{2263,15,16,2266,264},{245,6,23,3577,173,245},},
{0},{{226,34,22,162,204},},{{3554,7,20,245,79},{3528,5,20,2261,79},},{{3511,69,22,2264,314},},{{245,10,24,3568,168,245},},{0},{{3437,72,20,2264,196},},
{0},{{226,38,23,3577,211,162},},{{2254,16,24,3568,168,2254},},{{2279,15,17,2266,300},},{{2264,75,23,3577,173,2264},{195,36,23,3577,294,162},},{{245,14,20,3570,156},},
{0},{0},{0},{0},{{2301,19,20,2254,279},{2254,28,20,2254,150},},{{226,46,17,226,217},},{0},{{2265,21,23,3577,211,2254},},{0},{0},{{3528,0,20,2261,79},},{{3511,70,18,3437,330},},
{{3437,68,23,3577,211,2264},{2260,12,22,245,248},},{{2301,24,24,3568,291,2254},{2254,23,24,3568,168,2254},},{{2258,57,23,3577,321,232},},{0},{0},{0},{0},{{2266,11,22,245,204},},
{{245,11,20,245,150},},{{2301,28,20,2254,279},{2254,19,20,2254,150},},{0},{{162,42,23,3577,173,162},},{0},{0},{{2258,66,20,232,306},{232,54,18,2259,188},},
{{2263,4,24,3568,254,245},{2259,60,20,232,196},},{0},{{3437,77,17,3437,217},{2260,7,18,2266,274},},{{232,58,18,2259,188},},{0},{{2254,8,20,3512,142},},
{0},{0},{{2279,4,16,2266,297},},{{2261,13,18,2266,68},},{{245,4,20,245,150},},{0},{0},{0},{{2265,18,18,2265,220},},{{2301,25,20,2254,279},{2254,22,20,2254,150},},
{0},{{2263,13,24,3568,254,245},{2259,66,23,3577,211,232},},{{226,32,23,3577,211,162},},{0},{{232,53,22,232,162},},{0},{0},{0},{{3554,9,20,245,79},{3528,11,20,2261,79},},
{{2279,13,16,2266,297},},{{162,41,18,226,188},},{0},{{2264,77,22,2264,162},{195,34,22,162,287},},{{2259,61,24,3568,208,232},},{{2261,10,22,245,37},},
{0},{0},{0},{{2263,10,24,3568,254,245},},{{2265,23,18,2265,220},},{0},{0},{0},{0},{{3437,70,16,3437,214},{226,35,22,162,204},},{0},{{2279,10,16,2266,297},},{{2301,26,23,3577,294,2254},
{2254,21,23,3577,173,2254},},{0},{{3554,4,20,245,79},{3528,6,20,2261,79},},{0},{{162,36,18,226,188},},{0},{{2266,9,17,2266,217},{2261,3,20,245,23},},
{{2263,6,20,245,236},},{{245,13,20,245,150},},{{2265,24,22,2254,204},},{{2266,13,17,2266,217},},{0},{0},{{2301,18,20,2254,279},},{{3437,51,20,2264,196},},
{0},{0},{0},{{232,60,22,232,162},},{{3554,3,20,245,79},{195,48,18,226,303},},{{2263,11,20,245,236},},{{2260,13,22,245,248},},{{3512,20,2,2301,0},
{2258,58,22,232,314},},{{162,48,23,3577,173,162},},{{3557,77,20,2264,79},},{0},{0},{0},{{3576,8,20,3512,4},{3511,69,18,3437,330},},{{2259,64,16,2259,214},
{245,10,20,245,150},},{0},{{3437,72,16,3437,214},},{0},{0},{{2254,16,20,2254,150},},{0},{0},{{2265,25,23,3577,211,2254},},{{3519,13,0,2261,0},},{0},{{2266,12,22,245,204},},
{{3535,60,20,232,79},},{0},{0},{{2279,7,24,3568,291,245},},{{162,30,23,3577,173,162},},{{2301,23,24,3568,291,2254},{2254,24,24,3568,168,2254},},{0},{{2259,55,16,2259,214},},
{{3511,70,22,2264,314},},{0},{{2301,24,20,2254,279},{2254,23,20,2254,150},},{0},{0},{0},{{3519,10,0,2261,0},{195,45,23,3577,294,162},},{0},{{2266,11,18,2266,220},},
{0},{0},{0},{{2266,15,18,2266,220},},{{3511,75,22,2264,314},},{{2301,16,24,3568,291,2254},},{{2264,51,23,3577,173,2264},},{{2259,60,16,2259,214},{245,15,17,2266,183},},
{{162,46,22,162,162},},{{226,41,22,162,204},},{{232,58,22,232,162},},{{2259,56,16,2259,214},},{{2301,20,23,3577,294,2254},},{{2260,3,22,245,248},},
{0},{{2279,4,20,245,279},},{0},{{232,62,23,3577,173,232},},{{3437,69,24,3568,208,2264},{195,29,22,162,287},},{{195,46,22,162,287},},{0},{{3512,11,2,2279,0},
{2265,18,22,2254,204},},{0},{0},{{2263,13,20,245,236},},{0},{{2260,11,23,3577,259,245},},{{162,37,16,226,178},},{{245,12,23,3577,173,245},},{{2254,18,17,2265,183},},
{{226,36,22,162,204},},{0},{0},{0},{{232,57,17,2259,183},},{0},{{2264,50,12,3579,85},{2263,5,24,3568,254,245},},{{2261,10,18,2266,68},{162,45,22,162,162},},
{0},{0},{{195,30,23,3577,294,162},},{{2263,10,20,245,236},{2259,57,23,3577,211,232},},{{2265,23,22,2254,204},},{{2258,59,22,232,314},},{0},{{245,5,17,2266,183},},
{0},{{3437,70,20,2264,196},},{0},{{2265,19,23,3577,211,2254},},{{3569,46,11,3514,0},{2254,21,19,2265,193},},{0},{0},{0},{{2260,10,22,245,248},},{0},{{2261,3,24,3568,44,245},},
{{2263,6,24,3568,254,245},},{{2259,62,17,2259,217},{245,13,16,2266,178},},{{2264,72,19,3437,193},},{0},{{3511,73,23,3577,321,2264},},{{2259,58,17,2259,217},},
{{2301,18,16,2265,297},},{0},{{162,44,23,3577,173,162},},{{2265,20,17,2265,217},},{{2301,22,16,2265,297},},{{232,60,18,2259,188},},{{195,48,22,162,287},},
{0},{{2260,13,18,2266,274},},{0},{{2266,5,18,2266,220},},{{2263,15,24,3568,254,245},},{{2260,9,18,2266,274},},{{2264,67,17,3437,183},},{0},{{162,39,17,226,183},},
{{2259,64,20,232,196},{245,10,16,2266,178},},{0},{0},{{162,43,17,226,183},},{{3511,74,22,2264,314},},{0},{0},{0},{{226,42,23,3577,211,162},},{{2260,4,18,2266,274},},
{{232,59,22,232,162},},{0},{0},{0},{0},{{2279,7,20,245,279},},{0},{0},{0},{{2259,55,20,232,196},{245,3,22,245,162},},{0},{0},{{2301,24,16,2265,297},{2254,23,16,2265,178},},
{0},{0},{0},{0},{{2258,61,23,3577,321,232},},{0},{0},{0},{{2264,70,22,2264,162},{195,41,22,162,287},},{{2266,15,22,245,204},},{{2301,16,23,3577,294,2254},{232,66,16,2259,178},},
{0},{0},{{2263,4,16,2266,264},},{{3546,58,22,2258,83},{162,46,18,226,188},},{{226,41,18,226,220},},{{2261,9,16,2266,56},},{{2259,56,20,232,196},},
{0},{{2265,22,22,2254,204},},{{3528,16,20,2261,79},},{{162,29,24,3568,168,162},},{0},{{232,62,19,2259,193},},{{3437,69,20,2264,196},{2260,15,23,3577,259,245},},
{{195,46,18,226,303},},{0},{{3560,39,2,195,0},},{0},{{2264,69,18,3437,188},{195,42,18,226,303},},{{2263,13,16,2266,264},},{0},{{2279,9,18,2266,303},
{2258,60,22,232,314},},{{162,37,20,162,150},},{0},{0},{{226,36,18,226,220},},{{2261,6,16,2266,56},},{{3511,72,17,3437,327},},{0},{0},{{3554,13,20,245,79},
{3528,15,20,2261,79},},{0},{0},{{2301,21,24,3568,291,2254},{2254,26,24,3568,168,2254},},{{2258,55,18,2259,330},},{0},{{2263,10,16,2266,264},},{0},{{2279,5,17,2266,300},
{2258,59,18,2259,330},},{{2266,6,22,245,204},},{0},{0},{0},{{162,32,20,162,150},},{{226,48,23,3577,211,162},},{{3577,62,15,3546,0},},{0},{{245,9,18,2266,188},},
{0},{{2260,10,18,2266,274},},{{232,64,19,2259,193},},{{3573,16,3,3576,2},},{{245,13,1,3528,88},},{0},{{2264,72,23,3577,173,2264},{195,39,23,3577,294,162},},
{0},{{2261,7,23,3577,50,245},},{0},{0},{0},{0},{{3511,77,22,2264,314},{162,31,9,3583,120},},{{2301,22,20,2254,279},{2254,25,20,2254,150},},{0},{{2259,54,20,232,196},},
{{3583,17,6,3573,2},},{{3437,67,17,3437,217},{226,30,23,3577,211,162},},{0},{{2266,5,22,245,204},},{0},{{2260,9,22,245,248},},{0},{{2279,11,17,2266,300},},
{0},{0},{0},{0},{{2261,4,17,2266,62},},{{3511,74,18,3437,330},},{{2279,15,22,245,287},},{0},{{2263,7,24,3568,254,245},},{{3546,59,22,2258,83},},{{2260,4,22,245,248},},
{{232,59,18,2259,188},},{{2259,59,20,232,196},},{0},{{226,46,22,162,204},},{0},{{2279,7,16,2266,297},},{0},{0},{0},{{2259,55,24,3568,208,232},},{{162,34,23,3577,173,162},},
{0},{{2266,4,23,3577,211,245},},{{2263,12,23,3577,259,245},},{0},{0},{0},{{162,38,20,162,150},},{0},{{2254,19,19,2265,193},},{{3437,73,17,3437,217},},{{2264,70,18,3437,188},
{195,41,18,226,303},},{{226,37,16,226,214},},{{232,66,20,232,150},},{{2279,12,22,245,287},},{{2264,74,18,3437,188},{195,37,18,226,303},},
{{2263,4,20,245,236},{2259,60,24,3568,208,232},},{{3437,77,22,2264,204},},{0},{{2261,9,20,245,23},},{{2259,56,24,3568,208,232},},{0},{{2265,22,18,2265,220},
{226,45,22,162,204},},{{2266,7,17,2266,217},},{{3511,67,23,3577,321,2264},},{{245,4,19,2266,193},},{0},{{3437,69,16,3437,214},},{{162,33,20,162,150},},
{0},{0},{{2258,56,18,2259,330},},{{2264,69,22,2264,162},{195,42,22,162,287},},{0},{0},{{2279,9,22,245,287},{2258,60,18,2259,330},},{{162,37,24,3568,168,162},},
{0},{0},{0},{{2261,6,20,245,23},},{0},{0},{0},{{3535,64,20,232,79},{3514,41,20,162,79},},{0},{{2260,6,23,3577,259,245},},{{2301,21,20,2254,279},{2254,26,20,2254,150},},
{{2258,55,22,232,314},},{0},{{226,44,23,3577,211,162},},{0},{{3512,21,2,2301,0},},{{2266,6,18,2266,220},},{{2263,14,20,3570,242},{2259,53,23,3577,211,232},},
{0},{0},{{2279,10,23,3577,294,245},{162,32,24,3568,168,162},},{{3511,68,18,3437,330},},{0},{{2264,68,23,3577,173,2264},{195,43,23,3577,294,162},},{{245,9,22,245,162},},
{0},{{226,39,17,226,217},},{{232,64,23,3577,173,232},},{0},{0},{{3437,75,22,2264,204},{226,43,17,226,217},},{{2260,5,22,245,248},},{0},{0},{{2258,64,18,2259,330},
{232,56,16,2259,178},},{0},{{195,35,22,162,287},},{0},{{3511,77,18,3437,330},},{{2279,6,18,2266,303},{2258,54,23,3577,321,232},},{{245,2,1,3528,88},},
{{2259,54,16,2259,214},},{{3546,60,22,2258,83},},{0},{{2261,15,20,245,23},{162,48,16,226,178},},{{245,6,18,2266,188},},{0},{0},{{3519,5,0,2261,0},},
{{2258,62,17,2259,327},},{{2254,20,18,2265,188},},{0},{{3437,72,23,3577,211,2264},},{0},{0},{{232,55,16,2259,178},},{{2279,15,18,2266,303},},{{3570,4,11,3554,0},},
{{2263,7,20,245,236},},{0},{0},{{2261,8,20,3512,11},},{{2259,59,16,2259,214},},{{2301,19,17,2265,300},{2254,28,17,2265,183},},{{226,46,18,226,220},},
{{195,32,22,162,287},},{{2265,21,16,2265,214},},{{2301,23,17,2265,300},{2254,24,17,2265,183},},{0},{0},{0},{{3437,68,18,3437,220},{226,29,24,3568,208,162},},
{{3560,36,2,195,0},},{0},{0},{{245,7,17,2266,183},},{0},{0},{{162,38,16,226,178},},{{245,11,17,2266,183},},{{2301,28,23,3577,294,2254},{2254,19,23,3577,173,2254},},
{0},{{2261,5,20,245,23},{162,42,16,226,178},},{{226,37,20,162,196},},{{232,66,24,3568,168,232},},{{2258,66,17,2259,327},{232,54,23,3577,173,232},},
{{2264,74,22,2264,162},{195,37,22,162,287},},{{2265,26,16,2265,214},},{{3437,77,18,3437,220},{2260,7,17,2266,269},},{0},{{2261,9,24,3568,44,245},},
{0},{0},{{195,33,23,3577,294,162},},{0},{{2261,13,23,3577,50,245},},{{245,4,23,3577,173,245},},{0},{{2263,9,18,2266,274},},{{3511,51,23,3577,321,2264},},{{2265,18,17,2265,217},},
{{2254,22,17,2265,183},},{{2258,56,22,232,314},},{{2259,66,18,2259,220},},{{226,32,20,162,196},},{{3528,45,20,2261,79},},{{3512,26,2,2301,0},},
{{2266,10,23,3577,211,245},},{{2254,18,22,2254,162},},{{3437,74,22,2264,204},},{{2264,73,17,3437,183},{195,38,17,226,300},},{{2261,6,24,3568,44,245},},
{{162,41,17,226,183},},{0},{{2264,77,17,3437,183},},{{2263,5,17,2266,269},},{0},{0},{{2301,21,16,2265,297},{2254,26,16,2265,178},},{0},{{2259,57,24,3568,208,232},},
{0},{{2260,40,20,3560,230},},{0},{{2259,53,24,3568,208,232},{245,5,22,245,162},},{0},{0},{0},{0},{{3511,68,22,2264,314},},{0},{{2264,68,19,3437,193},},{0},{{162,36,23,3577,173,162},},
{{2265,28,17,2265,217},},{{2266,9,20,245,196},},{{2263,6,23,3577,259,245},},{{2259,62,24,3568,208,232},},{{2265,24,17,2265,217},},{{2260,5,18,2266,274},},
{{3511,73,16,3437,324},},{{2259,58,24,3568,208,232},},{{2258,64,22,232,314},{232,56,20,232,150},},{0},{0},{{2261,11,23,3577,50,245},},{0},{{2279,6,22,245,287},},
{{195,48,17,226,300},},{{2263,11,17,2266,269},},{{3546,64,22,2258,83},},{0},{{2261,15,16,2266,56},{162,48,20,162,150},},{{2263,15,17,2266,269},
{245,6,22,245,162},},{0},{{226,34,23,3577,211,162},},{0},{{3511,69,23,3577,321,2264},{162,39,24,3568,168,162},},{{2254,20,22,2254,162},},{0},{0},{0},{{226,38,20,162,196},},
{{232,55,20,232,150},},{0},{{2264,75,22,2264,162},{195,36,22,162,287},},{{2263,7,16,2266,264},},{0},{{2279,3,22,245,287},},{{3577,55,15,3546,0},
{162,47,20,3569,156},},{0},{0},{0},{0},{{2265,21,20,2254,196},{162,30,24,3568,168,162},},{0},{0},{0},{{3511,70,17,3437,327},{162,34,24,3568,168,162},},{{3437,68,22,2264,204},
{2260,12,23,3577,259,245},},{{2301,24,23,3577,294,2254},{2254,23,23,3577,173,2254},},{{2258,57,22,232,314},},{0},{{226,33,20,162,196},},{{195,45,20,162,279},},
{0},{0},{0},{0},{0},{{2261,5,16,2266,56},{162,42,20,162,150},},{{226,37,24,3568,208,162},},{0},{{232,54,19,2259,193},},{{2259,60,23,3577,211,232},{245,15,22,245,162},},
{{2265,26,20,2254,196},},{0},{{232,58,19,2259,193},},{0},{{2301,20,18,2265,303},},{0},{0},{0},{{162,29,20,162,150},},{{232,62,20,232,150},},{0},{{3514,34,20,162,79},
{2263,9,22,245,248},},{0},{0},{0},{0},{{2259,66,22,232,204},},{{3546,54,22,2258,83},{226,32,24,3568,208,162},},{{2260,11,18,2266,274},},{0},{0},{{3556,22,20,2254,79},
{2254,18,18,2265,188},},{{3437,74,18,3437,220},},{0},{{2279,13,17,2266,300},},{0},{{232,57,20,232,150},},{0},{0},{{2261,10,17,2266,62},},{0},{0},{{3514,45,20,162,79},},
{{2263,10,23,3577,259,245},{2259,57,20,232,196},},{0},{0},{0},{{245,5,18,2266,188},},{0},{0},{0},{{2265,19,20,2254,196},{226,48,16,226,214},},{{2301,26,22,2254,287},
{2254,21,22,2254,162},},{0},{0},{{3514,48,20,162,79},},{{3546,53,22,3581,83},{162,36,19,226,193},},{{232,64,24,3568,168,232},},{{2266,9,16,2266,214},},
{0},{{2259,62,20,232,196},},{0},{{2266,13,16,2266,214},},{{3511,73,20,2264,306},{2261,7,24,3568,44,245},},{0},{{2301,18,23,3577,294,2254},{232,56,24,3568,168,232},},
{{2260,1,22,3519,223},},{{2261,11,24,3568,44,245},{162,44,20,162,150},},{{2265,20,20,2254,196},},{0},{{232,60,23,3577,173,232},},{0},{{2259,54,24,3568,208,232},},
{0},{{3512,9,2,2279,0},{2258,58,23,3577,321,232},},{{2266,5,17,2266,217},{162,48,24,3568,168,162},},{0},{0},{{2264,67,20,2264,150},{195,44,20,162,279},},
{0},{0},{{245,10,23,3577,173,245},},{0},{{3514,36,20,162,79},},{{2261,4,24,3568,44,245},{162,43,20,162,150},},{{226,38,16,226,214},},{{232,55,24,3568,168,232},},
{0},{{195,36,18,226,303},},{{2265,25,20,2254,196},{226,42,16,226,214},},{0},{0},{{2266,12,23,3577,211,245},},{{2259,59,24,3568,208,232},},{0},{{3557,51,20,2264,79},},
{{2261,12,20,245,23},},{{2265,21,24,3568,208,2254},{162,30,20,162,150},},{0},{0},{{3514,35,20,162,79},{2259,55,17,2259,217},},{0},{0},{{2254,23,19,2265,193},},
{{2258,57,18,2259,330},},{0},{0},{{195,45,24,3568,291,162},},{{2261,4294967295U,4294967295U,2263,2,2263},},{{2266,11,17,2266,217},{162,38,24,3568,168,162},},{{3556,23,20,2254,79},},
{0},{0},{{2266,15,17,2266,217},{162,42,24,3568,168,162},},{{3568,74,13,3511,0},{3511,75,23,3577,321,2264},},{0},{{2264,51,22,2264,162},},{{245,15,18,2266,188},},
{{2265,26,24,3568,208,2254},{162,46,23,3577,173,162},},{{226,41,17,226,217},},{{232,58,23,3577,173,232},},{{3514,46,20,162,79},},{{2301,20,22,2254,287},},
{0},{0},{{2279,4,23,3577,294,245},},{0},{{232,62,16,2259,178},},{{195,29,23,3577,294,162},},{0},{{162,33,24,3568,168,162},},{0},{0},{0},{0},{0},{{2260,11,22,245,248},},{{2266,10,24,3568,208,245},
{162,37,19,226,193},},{{245,12,22,245,162},},{0},{{226,36,23,3577,211,162},},{{3519,15,0,2261,0},},{{3511,72,20,2264,306},},{0},{{232,57,16,2259,178},},
{0},{0},{{2260,6,16,2266,264},},{0},{0},{{195,30,22,162,287},},{{2259,57,16,2259,214},},{{2265,23,23,3577,211,2254},},{{2279,5,22,245,287},},{0},{0},{0},{{3437,70,23,3577,211,2264},},
{{3519,4,0,2261,0},},{{2265,19,16,2265,214},{226,48,20,162,196},},{{2301,26,18,2265,303},{2254,21,18,2265,188},},{0},{0},{0},{{2260,10,23,3577,259,245},
{226,39,24,3568,208,162},},{0},{0},{0},{{2259,62,16,2259,214},{245,13,17,2266,183},},{{2264,72,16,3437,178},{195,39,16,226,297},},{{2266,13,20,245,196},},
{{3511,73,24,3568,318,2264},{2261,7,20,245,23},},{{2259,58,16,2259,214},},{0},{0},{0},{{2265,20,16,2265,214},{226,47,20,3569,200},},{0},{{232,60,19,2259,193},},
{{2259,54,23,3577,211,232},},{0},{{2260,13,17,2266,269},{226,30,24,3568,208,162},},{{3560,37,2,195,0},},{{2261,15,24,3568,44,245},},{0},{{2260,9,17,2266,269},
{226,34,24,3568,208,162},},{{2264,67,16,3437,178},},{{2279,11,18,2266,303},{2258,62,22,232,314},},{{162,39,16,226,178},},{{2259,64,23,3577,211,232},
{245,10,19,2266,193},},{0},{{2263,3,22,245,248},},{{162,43,16,226,178},},{{3580,50,14,3579,0},},{0},{0},{0},{{226,42,20,162,196},},{0},{{232,59,17,2259,183},},
{0},{0},{0},{0},{{2261,12,24,3568,44,245},},{0},{0},{0},{{245,3,23,3577,173,245},},{0},{{226,29,20,162,196},},{{2266,4,20,245,196},},{0},{0},{0},{0},{{2258,61,22,232,314},},{0},{0},{{3437,73,18,3437,220},},
{{2264,70,23,3577,173,2264},{195,41,23,3577,294,162},},{{2261,5,24,3568,44,245},},{{2301,16,22,2254,287},{232,66,17,2259,183},},{{232,54,24,3568,168,232},},
{0},{0},{{162,46,19,226,193},},{{232,58,24,3568,168,232},},{{2266,3,20,245,196},{2261,9,17,2266,62},},{{2259,56,23,3577,211,232},},{0},{{2265,22,17,2265,217},},
{0},{{3512,18,2,2301,0},{3511,67,16,3437,324},},{0},{0},{{2260,15,22,245,248},},{{195,46,17,226,300},},{{2265,18,24,3568,208,2254},},{0},{0},{{2264,69,17,3437,183},
{195,42,17,226,300},},{{2263,13,17,2266,269},},{0},{{2258,60,23,3577,321,232},{232,53,24,3568,168,232},},{{162,37,23,3577,173,162},},{0},{0},{0},{{2266,14,20,3570,200},},
{{3511,72,16,3437,324},{162,41,24,3568,168,162},},{0},{0},{0},{{162,45,24,3568,168,162},},{{2260,6,20,245,236},},{{232,61,20,232,150},},{{2258,55,17,2259,327},},
{0},{{2265,23,24,3568,208,2254},{226,44,20,162,196},},{0},{{2279,5,18,2266,303},{2258,59,17,2259,327},},{{2266,6,23,3577,211,245},},{{2259,53,20,232,196},},
};

static const struct action_table_entry *action_table_lookup(uint32_t nfa_state, uint32_t dfa_state, uint32_t token) {
    uint32_t index = ((((((0xe5aa55e5 ^ (nfa_state)) * 0xe5aa55e5) ^ (dfa_state)) * 0xe5aa55e5) ^ (token)) * 0xe5aa55e5) & 2047;
    uint32_t j = 0;
    const struct action_table_entry *entry = 0;
    for (; j < 2; ++j) {
        entry = &action_table[index][j];
        if (entry->target_nfa_state == nfa_state && entry->dfa_state == dfa_state && entry->dfa_symbol == token)
            break;
    }
    if (j >= 2)
        return 0;
    return entry;
}
static void apply_actions(struct construct_state *state, uint32_t index, size_t start, size_t end) {
    size_t offset = end;
    for (uint32_t i = index; actions[i]; ++i) {
        if (((((actions[i]) >> 12) & 0xf) & 8))
            offset = start;
        construct_action_apply(state, actions[i], offset);
    }
}
static parsed_id build_parse_tree(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run *run, struct bluebird_tree *tree) {
    struct construct_state construct_state = { .info = tree };
    struct state_stack stack = {0};
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset - whitespace;
    construct_begin(&construct_state, offset, CONSTRUCT_NORMAL_ROOT);
    uint32_t nfa_state = 2260;
    while (run) {
        uint16_t length_offset = run->lengths_size - 1;
        uint16_t n = run->number_of_tokens;
        for (uint16_t i = n - 1; i < n; i--) {
            size_t end = offset;
            size_t len = 0;
            const struct action_table_entry *entry = action_table_lookup(nfa_state, run->states[i], run->tokens[i]);
            if (!entry)
                abort();
            if (entry->dfa_symbol < 23)
                len = decode_token_length(run, &length_offset, &offset);
            else {
                if (stack.depth >= stack.capacity)
                    grow_state_stack(&stack);
                stack.states[stack.depth++] = entry->push_nfa_state;
            }
            apply_actions(&construct_state, entry->actions, end, end + whitespace);
            if (entry->dfa_state == 50) {
                if (stack.depth == 0)
                    abort();
                nfa_state = stack.states[--stack.depth];
            } else
                nfa_state = entry->nfa_state;
            whitespace = end - offset - len;
        }
        struct bluebird_token_run *old = run;
        run = run->prev;
        free(old);
    }
    const struct action_table_entry *entry = action_table_lookup(nfa_state, UINT32_MAX, UINT32_MAX);
    if (!entry)
        abort();
    apply_actions(&construct_state, entry->actions, offset, offset + whitespace);
    free(stack.states);
    return construct_finish(&construct_state, offset);
}
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info) {
    switch (text[0]) {
    case 35:
        *end_token = false;
        *token = 4294967295U;
        return 1;
    case 40:
        *end_token = false;
        *token = 12;
        return 1;
    case 41:
        *end_token = true;
        *token = 13;
        return 1;
    case 42:
        *end_token = false;
        *token = 16;
        return 1;
    case 43:
        *end_token = false;
        *token = 17;
        return 1;
    case 46:
        if (text[1] == 111 && text[2] == 112 && text[3] == 101 && text[4] == 114 && text[5] == 97 && text[6] == 116 && text[7] == 111 && text[8] == 114 && text[9] == 115) {
            *end_token = false;
            *token = 3;
            return 10;
        } else {
            return 0;
        }
    case 58:
        *end_token = false;
        *token = 2;
        return 1;
    case 61:
        *end_token = false;
        *token = 1;
        return 1;
    case 63:
        *end_token = false;
        *token = 18;
        return 1;
    case 64:
        *end_token = false;
        *token = 11;
        return 1;
    case 91:
        *end_token = false;
        *token = 14;
        return 1;
    case 93:
        *end_token = true;
        *token = 15;
        return 1;
    case 102:
        if (text[1] == 108 && text[2] == 97 && text[3] == 116) {
            *end_token = false;
            *token = 7;
            return 4;
        } else {
            return 0;
        }
    case 105:
        if (text[1] == 110 && text[2] == 102 && text[3] == 105 && text[4] == 120) {
            *end_token = false;
            *token = 6;
            return 5;
        } else {
            return 0;
        }
    case 108:
        switch (text[1]) {
        case 101:
            if (text[2] == 102 && text[3] == 116) {
                *end_token = false;
                *token = 8;
                return 4;
            } else {
                return 0;
            }
        case 105:
            if (text[2] == 110 && text[3] == 101 && text[4] == 45 && text[5] == 99 && text[6] == 111 && text[7] == 109 && text[8] == 109 && text[9] == 101 && text[10] == 110 && text[11] == 116 && text[12] == 45 && text[13] == 116 && text[14] == 111 && text[15] == 107 && text[16] == 101 && text[17] == 110) {
                *end_token = false;
                *token = 0;
                return 18;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 110:
        if (text[1] == 111 && text[2] == 110 && text[3] == 97 && text[4] == 115 && text[5] == 115 && text[6] == 111 && text[7] == 99) {
            *end_token = false;
            *token = 10;
            return 8;
        } else {
            return 0;
        }
    case 112:
        switch (text[1]) {
        case 111:
            if (text[2] == 115 && text[3] == 116 && text[4] == 102 && text[5] == 105 && text[6] == 120) {
                *end_token = false;
                *token = 4;
                return 7;
            } else {
                return 0;
            }
        case 114:
            if (text[2] == 101 && text[3] == 102 && text[4] == 105 && text[5] == 120) {
                *end_token = false;
                *token = 5;
                return 6;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 114:
        if (text[1] == 105 && text[2] == 103 && text[3] == 104 && text[4] == 116) {
            *end_token = false;
            *token = 9;
            return 5;
        } else {
            return 0;
        }
    case 124:
        *end_token = false;
        *token = 19;
        return 1;
    default:
        return 0;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context) {
    switch (parent) {
    case 0:
        switch (slot) {
        case 0: return 1;
        case 1: return 2;
        default: break;
        }
        break;
    case 1:
        switch (slot) {
        case 0: return 11;
        default: break;
        }
        break;
    case 2:
        switch (slot) {
        case 0: return 9;
        case 1: return 3;
        default: break;
        }
        break;
    case 3:
        switch (slot) {
        case 0: return 8;
        case 1: return 9;
        case 2: return 4;
        default: break;
        }
        break;
    case 4:
        switch (slot) {
        case 0: return 6;
        case 1: return 5;
        default: break;
        }
        break;
    case 5:
        switch (slot) {
        case 0: return 8;
        case 1: return 9;
        default: break;
        }
        break;
    case 6:
        switch (slot) {
        case 0: return 7;
        default: break;
        }
        break;
    case 8:
        switch (slot) {
        case 0: return 9;
        case 1: return 9;
        case 2: return 11;
        case 3: return 8;
        case 4: return 11;
        case 5: return 11;
        case 6: return 8;
        default: break;
        }
        break;
    default: break;
    }
    return UINT32_MAX;
}
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context) {
    switch (rule) {
    case 8:
        switch (choice) {
        case 4:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 5:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 6:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 7:
            *precedence = -2;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        case 8:
            *precedence = -3;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        default: return;
        }
    default: return;
    }
}
static size_t number_of_slots_lookup(uint32_t rule, void *context) {
    switch (rule) {
    case 0: return 2;
    case 1: return 1;
    case 2: return 2;
    case 3: return 3;
    case 4: return 2;
    case 5: return 2;
    case 6: return 1;
    case 7: return 0;
    case 8: return 7;
    case 9: return 0;
    case 10: return 0;
    case 11: return 0;
    default: return 0;
    }
}
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context) {
    switch (rule) {
    case 0:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 1:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 2:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 3:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 4:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 5:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 6:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 7:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 8:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 6;
        break;
    case 9:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 10:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 11:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    }
}
#endif

