// -----------------------------------------------------------------------------
// This file was generated by the Owl parsing tool.
// Make sure to #define OWL_PARSER_IMPLEMENTATION somewhere so the parser
// is compiled properly.  Just two lines are enough -- a typical parser.c might
// look like:
//
//   #define OWL_PARSER_IMPLEMENTATION
//   #include "owl-parser.h"

#ifndef _OWL_PARSER_H_
#define _OWL_PARSER_H_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

// The owl_tree struct represents an entire parse tree.  Use the
// owl_tree_create_...() functions to create a tree, then call owl_tree_root()
// to get the root owl_ref.
struct owl_tree;

// Creates an owl_tree from a string.  The tree may directly reference pieces of
// the string -- you're responsible for keeping it around until
// owl_tree_destroy() is called.
struct owl_tree *owl_tree_create_from_string(const char *string);

// Creates an owl_tree by reading from a file.
struct owl_tree *owl_tree_create_from_file(FILE *file);

// Destroys an owl_tree, freeing its resources back to the system.
void owl_tree_destroy(struct owl_tree *);

// Prints a representation of the tree to standard output.
void owl_tree_print(struct owl_tree *);

// An owl_ref references a list of children in the parse tree.  Use the
// parsed_..._get() function corresponding to the element type to unpack the
// child into its appropriate parsed_... struct.
struct owl_ref {
    struct owl_tree *_tree;
    size_t _offset;
    uint32_t _type;
    bool empty;
};

// The owl_next function advances a ref to the next sibling element.
struct owl_ref owl_next(struct owl_ref);

// Tests two refs for equality.
bool owl_refs_equal(struct owl_ref a, struct owl_ref b);

// Returns the root owl_ref.
struct owl_ref owl_tree_root_ref(struct owl_tree *tree);

// As a shortcut, returns the parsed_grammar struct corresponding to the root ref.
struct parsed_grammar owl_tree_get_parsed_grammar(struct owl_tree *tree);

// The range of text corresponding to a tree element.
struct source_range {
    size_t start;
    size_t end;
};

enum owl_error {
    // No error -- everything's fine!
    ERROR_NONE,

    // The file passed to owl_tree_create_from_file wasn't valid because
    // - it was NULL,
    // - it doesn't support fseek/ftell, or
    // - there was an error while reading it.
    ERROR_INVALID_FILE,

    // A piece of text couldn't be matched as a token.
    ERROR_INVALID_TOKEN,

    // The parser encountered an out-of-place token that doesn't fit the grammar.
    ERROR_UNEXPECTED_TOKEN,

    // The input is valid so far, but incomplete; more tokens could be added to
    // complete it.
    ERROR_MORE_INPUT_NEEDED,
};
// Returns an error code, or ERROR_NONE if there wasn't an error.
// The error_range parameter can be null.
enum owl_error owl_tree_get_error(struct owl_tree *tree, struct source_range *error_range);

enum parsed_type {
    PARSED_IDENT = 1,
    PARSED_CHOICE,
    PARSED_PARENS,
    PARSED_FLAT_OP,
    PARSED_LEFT_OP,
    PARSED_LITERAL,
    PARSED_INFIX_OP,
    PARSED_OPTIONAL,
    PARSED_RIGHT_OP,
    PARSED_BRACKETED,
    PARSED_PREFIX_OP,
    PARSED_POSTFIX_OP,
    PARSED_NONASSOC_OP,
    PARSED_ONE_OR_MORE,
    PARSED_ZERO_OR_MORE,
    PARSED_CONCATENATION,
};

struct parsed_grammar {
    struct source_range range;
    struct owl_ref rule;
    struct owl_ref comment_token;
};

struct parsed_rule {
    struct source_range range;
    struct owl_ref identifier;
    struct owl_ref body;
};

struct parsed_body {
    struct source_range range;
    struct owl_ref expr;
    struct owl_ref identifier;
    struct owl_ref operators;
};

struct parsed_operators {
    struct source_range range;
    struct owl_ref fixity;
    struct owl_ref operator;
};

struct parsed_fixity {
    struct source_range range;
    enum parsed_type type;
    struct owl_ref assoc;
};

struct parsed_assoc {
    struct source_range range;
    enum parsed_type type;
};

struct parsed_operator {
    struct source_range range;
    struct owl_ref expr;
    struct owl_ref identifier;
};

struct parsed_expr {
    struct source_range range;
    enum parsed_type type;
    struct owl_ref identifier;
    struct owl_ref exception;
    struct owl_ref rename;
    struct owl_ref string;
    struct owl_ref expr;
    struct owl_ref begin_token;
    struct owl_ref end_token;
    struct owl_ref operand;
};

struct parsed_comment_token {
    struct source_range range;
    struct owl_ref string;
};

struct parsed_identifier {
    struct source_range range;
    const char *identifier;
    size_t length;
};

struct parsed_number {
    struct source_range range;
    double number;
};

struct parsed_string {
    struct source_range range;
    const char *string;
    size_t length;
    bool has_escapes;
};

struct parsed_grammar parsed_grammar_get(struct owl_ref);
struct parsed_rule parsed_rule_get(struct owl_ref);
struct parsed_body parsed_body_get(struct owl_ref);
struct parsed_operators parsed_operators_get(struct owl_ref);
struct parsed_fixity parsed_fixity_get(struct owl_ref);
struct parsed_assoc parsed_assoc_get(struct owl_ref);
struct parsed_operator parsed_operator_get(struct owl_ref);
struct parsed_expr parsed_expr_get(struct owl_ref);
struct parsed_comment_token parsed_comment_token_get(struct owl_ref);
struct parsed_identifier parsed_identifier_get(struct owl_ref);
struct parsed_number parsed_number_get(struct owl_ref);
struct parsed_string parsed_string_get(struct owl_ref);

#endif

#ifdef OWL_PARSER_IMPLEMENTATION
// Code implementing the parser.  This might get a bit messy!
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct owl_tree {
    const char *string;
    bool owns_string;
    uint8_t *parse_tree;
    size_t parse_tree_size;
    size_t next_offset;
    enum owl_error error;
    struct source_range error_range;
    size_t root_offset;
    struct {
        const char *identifier;
        size_t length;
        struct source_range range;
    } *identifier_tokens;
    size_t number_of_identifier_tokens;
    size_t used_identifier_tokens;
    size_t identifier_tokens_capacity;
    struct {
        double number;
        struct source_range range;
    } *number_tokens;
    size_t number_of_number_tokens;
    size_t used_number_tokens;
    size_t number_tokens_capacity;
    struct {
        const char *string;
        size_t length;
        bool has_escapes;
        struct source_range range;
    } *string_tokens;
    size_t number_of_string_tokens;
    size_t used_string_tokens;
    size_t string_tokens_capacity;
};
static void add_identifier_token(struct owl_tree *tree, size_t start, size_t end, const char *identifier_param, size_t length_param) {
    size_t index = tree->number_of_identifier_tokens++;
    if (tree->number_of_identifier_tokens > tree->identifier_tokens_capacity) {
        size_t capacity = (tree->identifier_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->identifier_tokens, sizeof(tree->identifier_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->identifier_tokens_capacity = capacity;
        tree->identifier_tokens = tokens;
    }
    tree->identifier_tokens[index].range.start = start;
    tree->identifier_tokens[index].range.end = end;
    tree->identifier_tokens[index].identifier = identifier_param;
    tree->identifier_tokens[index].length = length_param;
}
static void add_number_token(struct owl_tree *tree, size_t start, size_t end, double number_param) {
    size_t index = tree->number_of_number_tokens++;
    if (tree->number_of_number_tokens > tree->number_tokens_capacity) {
        size_t capacity = (tree->number_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->number_tokens, sizeof(tree->number_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->number_tokens_capacity = capacity;
        tree->number_tokens = tokens;
    }
    tree->number_tokens[index].range.start = start;
    tree->number_tokens[index].range.end = end;
    tree->number_tokens[index].number = number_param;
}
static void add_string_token(struct owl_tree *tree, size_t start, size_t end, const char *string_param, size_t length_param, bool has_escapes_param) {
    size_t index = tree->number_of_string_tokens++;
    if (tree->number_of_string_tokens > tree->string_tokens_capacity) {
        size_t capacity = (tree->string_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->string_tokens, sizeof(tree->string_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->string_tokens_capacity = capacity;
        tree->string_tokens = tokens;
    }
    tree->string_tokens[index].range.start = start;
    tree->string_tokens[index].range.end = end;
    tree->string_tokens[index].string = string_param;
    tree->string_tokens[index].length = length_param;
    tree->string_tokens[index].has_escapes = has_escapes_param;
}
// Reserve 10 bytes for each entry (the maximum encoded size of a 64-bit value).
#define RESERVATION_AMOUNT 10
static inline uint64_t read_tree(size_t *offset, struct owl_tree *tree) {
    uint8_t *parse_tree = tree->parse_tree;
    size_t parse_tree_size = tree->parse_tree_size;
    size_t i = *offset;
    if (i + RESERVATION_AMOUNT >= parse_tree_size)
        return 0;
    uint64_t result = 0;
    int shift_amount = 0;
    while ((parse_tree[i] & 0x80) != 0 && shift_amount < 64) {
        result |= (parse_tree[i] & 0x7f) << shift_amount;
        shift_amount += 7;
        i++;
    }
    result |= (parse_tree[i] & 0x7f) << shift_amount;
    i++;
    *offset = i;
    return result;
}
static bool grow_tree(struct owl_tree *tree, size_t size)
{
    size_t n = tree->parse_tree_size;
    while (n < size || n < 4096)
        n = (n + 1) * 3 / 2;
    uint8_t *parse_tree = realloc(tree->parse_tree, n);
    if (!parse_tree)
        return false;
    tree->parse_tree_size = n;
    tree->parse_tree = parse_tree;
    return true;
}
static void write_tree(struct owl_tree *tree, uint64_t value)
{
    size_t reserved_size = tree->next_offset + RESERVATION_AMOUNT;
    if (tree->parse_tree_size <= reserved_size && !grow_tree(tree, reserved_size))
        abort();
    while (value >> 7 != 0) {
        tree->parse_tree[tree->next_offset++] = 0x80 | (value & 0x7f);
        value >>= 7;
    }
    tree->parse_tree[tree->next_offset++] = value & 0x7f;
}
struct parsed_grammar parsed_grammar_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 0) {
        return (struct parsed_grammar){
            .rule.empty = true,
            .comment_token.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_grammar result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.rule._tree = ref._tree;
    result.rule._offset = read_tree(&offset, ref._tree);
    result.rule._type = 1;
    result.rule.empty = result.rule._offset == 0;
    result.comment_token._tree = ref._tree;
    result.comment_token._offset = read_tree(&offset, ref._tree);
    result.comment_token._type = 8;
    result.comment_token.empty = result.comment_token._offset == 0;
    return result;
}
struct parsed_rule parsed_rule_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 1) {
        return (struct parsed_rule){
            .identifier.empty = true,
            .body.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_rule result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    result.body._tree = ref._tree;
    result.body._offset = read_tree(&offset, ref._tree);
    result.body._type = 2;
    result.body.empty = result.body._offset == 0;
    return result;
}
struct parsed_body parsed_body_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 2) {
        return (struct parsed_body){
            .expr.empty = true,
            .identifier.empty = true,
            .operators.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_body result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.expr._tree = ref._tree;
    result.expr._offset = read_tree(&offset, ref._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    result.operators._tree = ref._tree;
    result.operators._offset = read_tree(&offset, ref._tree);
    result.operators._type = 3;
    result.operators.empty = result.operators._offset == 0;
    return result;
}
struct parsed_operators parsed_operators_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 3) {
        return (struct parsed_operators){
            .fixity.empty = true,
            .operator.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_operators result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.fixity._tree = ref._tree;
    result.fixity._offset = read_tree(&offset, ref._tree);
    result.fixity._type = 4;
    result.fixity.empty = result.fixity._offset == 0;
    result.operator._tree = ref._tree;
    result.operator._offset = read_tree(&offset, ref._tree);
    result.operator._type = 6;
    result.operator.empty = result.operator._offset == 0;
    return result;
}
struct parsed_fixity parsed_fixity_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 4) {
        return (struct parsed_fixity){
            .assoc.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_fixity result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&offset, ref._tree),
    };
    result.assoc._tree = ref._tree;
    result.assoc._offset = read_tree(&offset, ref._tree);
    result.assoc._type = 5;
    result.assoc.empty = result.assoc._offset == 0;
    return result;
}
struct parsed_assoc parsed_assoc_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 5) {
        return (struct parsed_assoc){
        0
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_assoc result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&offset, ref._tree),
    };
    return result;
}
struct parsed_operator parsed_operator_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 6) {
        return (struct parsed_operator){
            .expr.empty = true,
            .identifier.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_operator result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.expr._tree = ref._tree;
    result.expr._offset = read_tree(&offset, ref._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    return result;
}
struct parsed_expr parsed_expr_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 7) {
        return (struct parsed_expr){
            .identifier.empty = true,
            .exception.empty = true,
            .rename.empty = true,
            .string.empty = true,
            .expr.empty = true,
            .begin_token.empty = true,
            .end_token.empty = true,
            .operand.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_expr result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&offset, ref._tree),
    };
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    result.exception._tree = ref._tree;
    result.exception._offset = read_tree(&offset, ref._tree);
    result.exception._type = 9;
    result.exception.empty = result.exception._offset == 0;
    result.rename._tree = ref._tree;
    result.rename._offset = read_tree(&offset, ref._tree);
    result.rename._type = 9;
    result.rename.empty = result.rename._offset == 0;
    result.string._tree = ref._tree;
    result.string._offset = read_tree(&offset, ref._tree);
    result.string._type = 11;
    result.string.empty = result.string._offset == 0;
    result.expr._tree = ref._tree;
    result.expr._offset = read_tree(&offset, ref._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.begin_token._tree = ref._tree;
    result.begin_token._offset = read_tree(&offset, ref._tree);
    result.begin_token._type = 11;
    result.begin_token.empty = result.begin_token._offset == 0;
    result.end_token._tree = ref._tree;
    result.end_token._offset = read_tree(&offset, ref._tree);
    result.end_token._type = 11;
    result.end_token.empty = result.end_token._offset == 0;
    result.operand._tree = ref._tree;
    result.operand._offset = read_tree(&offset, ref._tree);
    result.operand._type = 7;
    result.operand.empty = result.operand._offset == 0;
    return result;
}
struct parsed_comment_token parsed_comment_token_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 8) {
        return (struct parsed_comment_token){
            .string.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_comment_token result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.string._tree = ref._tree;
    result.string._offset = read_tree(&offset, ref._tree);
    result.string._type = 11;
    result.string.empty = result.string._offset == 0;
    return result;
}
struct parsed_identifier parsed_identifier_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 9) {
        return (struct parsed_identifier){
        0
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t token_index = read_tree(&offset, ref._tree);
    struct parsed_identifier result = {
        .identifier = ref._tree->identifier_tokens[token_index].identifier,
        .length = ref._tree->identifier_tokens[token_index].length,
        .range = ref._tree->identifier_tokens[token_index].range,
    };
    return result;
}
struct parsed_number parsed_number_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 10) {
        return (struct parsed_number){
        0
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t token_index = read_tree(&offset, ref._tree);
    struct parsed_number result = {
        .number = ref._tree->number_tokens[token_index].number,
        .range = ref._tree->number_tokens[token_index].range,
    };
    return result;
}
struct parsed_string parsed_string_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 11) {
        return (struct parsed_string){
        0
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t token_index = read_tree(&offset, ref._tree);
    struct parsed_string result = {
        .string = ref._tree->string_tokens[token_index].string,
        .length = ref._tree->string_tokens[token_index].length,
        .has_escapes = ref._tree->string_tokens[token_index].has_escapes,
        .range = ref._tree->string_tokens[token_index].range,
    };
    return result;
}
static size_t finish_node(uint32_t rule, uint32_t choice, size_t next_sibling, size_t *slots, size_t start_location, size_t end_location, void *info) {
    struct owl_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling);
    write_tree(tree, start_location);
    write_tree(tree, end_location - start_location);
    switch (rule) {
    case 0: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 1: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 2: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        break;
    }
    case 3: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 4: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_POSTFIX_OP);
            break;
        case 1:
            write_tree(tree, PARSED_PREFIX_OP);
            break;
        case 2:
            write_tree(tree, PARSED_INFIX_OP);
            break;
        }
        write_tree(tree, slots[0]);
        break;
    }
    case 5: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_FLAT_OP);
            break;
        case 1:
            write_tree(tree, PARSED_LEFT_OP);
            break;
        case 2:
            write_tree(tree, PARSED_RIGHT_OP);
            break;
        case 3:
            write_tree(tree, PARSED_NONASSOC_OP);
            break;
        }
        break;
    }
    case 6: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 7: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_IDENT);
            break;
        case 1:
            write_tree(tree, PARSED_LITERAL);
            break;
        case 2:
            write_tree(tree, PARSED_PARENS);
            break;
        case 3:
            write_tree(tree, PARSED_BRACKETED);
            break;
        case 4:
            write_tree(tree, PARSED_ZERO_OR_MORE);
            break;
        case 5:
            write_tree(tree, PARSED_ONE_OR_MORE);
            break;
        case 6:
            write_tree(tree, PARSED_OPTIONAL);
            break;
        case 7:
            write_tree(tree, PARSED_CONCATENATION);
            break;
        case 8:
            write_tree(tree, PARSED_CHOICE);
            break;
        }
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        write_tree(tree, slots[3]);
        write_tree(tree, slots[4]);
        write_tree(tree, slots[5]);
        write_tree(tree, slots[6]);
        write_tree(tree, slots[7]);
        break;
    }
    case 8: {
        write_tree(tree, slots[0]);
        break;
    }
    default:
        break;
    }
    return offset;
}
static size_t finish_token(uint32_t rule, size_t next_sibling, void *info) {
    struct owl_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling);
    switch (rule) {
    case 9: {
        tree->used_identifier_tokens++;
        if (tree->used_identifier_tokens > tree->number_of_identifier_tokens)
            abort();
        size_t token_index = tree->number_of_identifier_tokens - tree->used_identifier_tokens;
        write_tree(tree, token_index);
        break;
    }
    case 10: {
        tree->used_number_tokens++;
        if (tree->used_number_tokens > tree->number_of_number_tokens)
            abort();
        size_t token_index = tree->number_of_number_tokens - tree->used_number_tokens;
        write_tree(tree, token_index);
        break;
    }
    case 11: {
        tree->used_string_tokens++;
        if (tree->used_string_tokens > tree->number_of_string_tokens)
            abort();
        size_t token_index = tree->number_of_string_tokens - tree->used_string_tokens;
        write_tree(tree, token_index);
        break;
    }
    default:
        break;
    }
    return offset;
}
static void check_for_error(struct owl_tree *tree) {
    if (tree->error == ERROR_NONE)
        return;
    fprintf(stderr, "parse error: ");
    switch (tree->error) {
    case ERROR_INVALID_FILE:
        fprintf(stderr, "invalid file\n");
        break;
    case ERROR_INVALID_TOKEN:
        fprintf(stderr, "invalid token '%.*s'\n", (int)(tree->error_range.end - tree->error_range.start), tree->string + tree->error_range.start);
        break;
    case ERROR_UNEXPECTED_TOKEN:
        fprintf(stderr, "unexpected token '%.*s'\n", (int)(tree->error_range.end - tree->error_range.start), tree->string + tree->error_range.start);
        break;
    case ERROR_MORE_INPUT_NEEDED:
        fprintf(stderr, "more input needed\n");
        break;
    default:
        break;
    }
    exit(-1);
}
static void parsed_grammar_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_rule_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_body_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_operators_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_fixity_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_assoc_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_operator_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_expr_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_comment_token_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_identifier_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_number_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_string_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_grammar_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_grammar it = parsed_grammar_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("grammar");
        if (strcmp("grammar", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_rule_print(tree, it.rule, "rule", indent + 1);
        parsed_comment_token_print(tree, it.comment_token, "comment_token", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_rule_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_rule it = parsed_rule_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("rule");
        if (strcmp("rule", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_body_print(tree, it.body, "body", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_body_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_body it = parsed_body_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("body");
        if (strcmp("body", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_operators_print(tree, it.operators, "operators", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_operators_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_operators it = parsed_operators_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operators");
        if (strcmp("operators", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_fixity_print(tree, it.fixity, "fixity", indent + 1);
        parsed_operator_print(tree, it.operator, "operator", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_fixity_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_fixity it = parsed_fixity_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("fixity");
        if (strcmp("fixity", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_POSTFIX_OP:
            printf(" : POSTFIX_OP");
            break;
        case PARSED_PREFIX_OP:
            printf(" : PREFIX_OP");
            break;
        case PARSED_INFIX_OP:
            printf(" : INFIX_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_assoc_print(tree, it.assoc, "assoc", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_assoc_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_assoc it = parsed_assoc_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("assoc");
        if (strcmp("assoc", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_FLAT_OP:
            printf(" : FLAT_OP");
            break;
        case PARSED_LEFT_OP:
            printf(" : LEFT_OP");
            break;
        case PARSED_RIGHT_OP:
            printf(" : RIGHT_OP");
            break;
        case PARSED_NONASSOC_OP:
            printf(" : NONASSOC_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
static void parsed_operator_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_operator it = parsed_operator_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operator");
        if (strcmp("operator", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_expr_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_expr it = parsed_expr_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("expr");
        if (strcmp("expr", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_IDENT:
            printf(" : IDENT");
            break;
        case PARSED_LITERAL:
            printf(" : LITERAL");
            break;
        case PARSED_PARENS:
            printf(" : PARENS");
            break;
        case PARSED_BRACKETED:
            printf(" : BRACKETED");
            break;
        case PARSED_ZERO_OR_MORE:
            printf(" : ZERO_OR_MORE");
            break;
        case PARSED_ONE_OR_MORE:
            printf(" : ONE_OR_MORE");
            break;
        case PARSED_OPTIONAL:
            printf(" : OPTIONAL");
            break;
        case PARSED_CONCATENATION:
            printf(" : CONCATENATION");
            break;
        case PARSED_CHOICE:
            printf(" : CHOICE");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_identifier_print(tree, it.exception, "exception", indent + 1);
        parsed_identifier_print(tree, it.rename, "rename", indent + 1);
        parsed_string_print(tree, it.string, "string", indent + 1);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_string_print(tree, it.begin_token, "begin_token", indent + 1);
        parsed_string_print(tree, it.end_token, "end_token", indent + 1);
        parsed_expr_print(tree, it.operand, "operand", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_comment_token_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_comment_token it = parsed_comment_token_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("comment_token");
        if (strcmp("comment_token", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_string_print(tree, it.string, "string", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_identifier_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_identifier it = parsed_identifier_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("identifier");
        if (strcmp("identifier", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.identifier);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
static void parsed_number_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_number it = parsed_number_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("number");
        if (strcmp("number", slot_name))
            printf("@%s", slot_name);
        printf(" - %f", it.number);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
static void parsed_string_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_string it = parsed_string_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("string");
        if (strcmp("string", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.string);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
void owl_tree_print(struct owl_tree *tree) {
    check_for_error(tree);
    parsed_grammar_print(tree, owl_tree_root_ref(tree), "grammar", 0);
}
struct owl_ref owl_next(struct owl_ref ref) {
    if (ref.empty) return ref;
    size_t offset = read_tree(&ref._offset, ref._tree);
    return (struct owl_ref){
        ._tree = ref._tree,
        ._offset = offset,
        ._type = ref._type,
        .empty = offset == 0,
    };
}
bool owl_refs_equal(struct owl_ref a, struct owl_ref b) {
    return a._tree == b._tree && a._offset == b._offset;
}
struct owl_ref owl_tree_root_ref(struct owl_tree *tree) {
    check_for_error(tree);
    return (struct owl_ref){
        ._tree = tree,
        ._offset = tree->root_offset,
        ._type = 0,
        .empty = tree->root_offset == 0,
    };
}
struct parsed_grammar owl_tree_get_parsed_grammar(struct owl_tree *tree) {
    check_for_error(tree);
    return parsed_grammar_get(owl_tree_root_ref(tree));
}
#define IGNORE_TOKEN_WRITE(...)
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info);
static void write_identifier_token(size_t offset, size_t length, void *info) {
    struct owl_tree *tree = info;
    add_identifier_token(tree, offset, offset + length, tree->string + offset, length);
}
static void write_number_token(size_t offset, size_t length, double number, void *info) {
    struct owl_tree *tree = info;
    add_number_token(tree, offset, offset + length, number);
}
static void write_string_token(size_t offset, size_t length, const char *string, size_t string_length, bool has_escapes, void *info) {
    struct owl_tree *tree = info;
    add_string_token(tree, offset, offset + length, string, string_length, has_escapes);
}
struct owl_token_run {
    struct owl_token_run *prev;
    uint16_t number_of_tokens;
    uint16_t lengths_size;
    uint8_t lengths[4096 * 2];
    uint32_t tokens[4096];
    uint32_t states[4096];
};
struct owl_default_tokenizer {
    const char *text;
    size_t offset;
    size_t whitespace;
    uint32_t identifier_token;
    uint32_t number_token;
    uint32_t string_token;
    void *info;
};
static bool char_is_whitespace(char c) {
    switch (c) {
    case ' ':
    case '\t':
    case '\r':
    case '\n':
        return true;
    default:
        return false;
    }
}
static bool char_is_numeric(char c) {
    return c >= '0' && c <= '9';
}
static bool char_is_alphabetic(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}
static bool char_starts_identifier(char c) {
    return char_is_alphabetic(c) || c == '_';
}
static bool char_continues_identifier(char c, void *info) {
    if (true && c == '-') return true;
    return char_is_numeric(c) || char_starts_identifier(c);
}
static bool encode_length(struct owl_token_run *run, uint16_t *lengths_size, size_t length) {
    uint8_t mark = 0;
    while (*lengths_size < sizeof(run->lengths)) {
        run->lengths[*lengths_size] = mark | (length & 0x7f);
        mark = 0x80;
        length >>= 7;
        (*lengths_size)++;
        if (length == 0) return true;
    }
    return false;
}
static bool encode_token_length(struct owl_token_run *run, uint16_t *lengths_size, size_t length, size_t whitespace) {
    uint16_t size = *lengths_size;
    if (encode_length(run, lengths_size, length) && encode_length(run, lengths_size, whitespace)) return true;
    *lengths_size = size;
    return false;
}
static size_t decode_length(struct owl_token_run *run, uint16_t *length_offset) {
    size_t length = 0;
    while (*length_offset < sizeof(run->lengths)) {
        size_t l = run->lengths[(*length_offset)--];
        length <<= 7;
        length += l & 0x7f;
        if (!(l & 0x80)) return length;
    }
    abort();
}
static size_t decode_token_length(struct owl_token_run *run, uint16_t *length_offset, size_t *string_offset) {
    size_t whitespace = decode_length(run, length_offset);
    size_t length = decode_length(run, length_offset);
    *string_offset -= whitespace + length;
    return length;
}
static bool owl_default_tokenizer_advance(struct owl_default_tokenizer *tokenizer, struct owl_token_run **previous_run) {
    struct owl_token_run *run = malloc(sizeof(struct owl_token_run));
    if (!run) return false;
    uint16_t number_of_tokens = 0;
    uint16_t lengths_size = 0;
    const char *text = tokenizer->text;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset;
    while (number_of_tokens < 4096) {
        char c = text[offset];
        if (c == '\0') break;
        if (char_is_whitespace(c)) {
            whitespace++;
            offset++;
            continue;
        }
        uint32_t token;
        bool is_token = false;
        bool end_token = false;
        bool comment = false;
        bool has_escapes = false;
        size_t token_length = read_keyword_token(&token, &end_token, text + offset, tokenizer->info);
        if (token_length > 0) {
            is_token = true;
            if (token == 0xffffffff) comment = true;
        }
        double number = 0;
        if (char_is_numeric(c) || (c == '.' && char_is_numeric(text[offset + 1]))) {
            const char *start = (const char *)text + offset;
            char *rest = 0;
            number = strtod(start, &rest);
            if (rest > start && rest - start > token_length) {
                token_length = rest - start;
                is_token = true;
                end_token = false;
                comment = false;
                token = 22;
            }
        }
        else if (c == '\'' || c == '"') {
            size_t string_offset = offset + 1;
            while (text[string_offset] != '\0') {
                if (text[string_offset] == c) {
                    token_length = string_offset + 1 - offset;
                    is_token = true;
                    end_token = false;
                    comment = false;
                    token = 23;
                    break;
                }
                if (text[string_offset] == '\\') {
                    has_escapes = true;
                    string_offset++;
                    if (text[string_offset] == '\0') break;
                }
                string_offset++;
            }
        }
        else if (char_starts_identifier(c)) {
            size_t identifier_offset = offset + 1;
            while (char_continues_identifier(text[identifier_offset], tokenizer->info)) identifier_offset++;
            if (identifier_offset - offset > token_length) {
                token_length = identifier_offset - offset;
                is_token = true;
                end_token = false;
                comment = false;
                token = 21;
            }
        }
        if (comment) {
            while (text[offset] != '\0' && text[offset] != '\n') {
                whitespace++;
                offset++;
            }
            continue;
        }
        else if (!is_token || token == 0xffffffff) {
            tokenizer->offset = offset;
            tokenizer->whitespace = whitespace;
            free(run);
            return false;
        }
        if (end_token && number_of_tokens + 1 >= 4096) break;
        if (!encode_token_length(run, &lengths_size, token_length, whitespace)) break;
        if (token == 21) {
            write_identifier_token(offset, token_length, tokenizer->info);
        }
        else if (token == 22) {
            write_number_token(offset, token_length, number, tokenizer->info);
        }
        else if (token == 23) {
            size_t content_offset = offset + 1;
            size_t content_length = token_length - 2;
            const char *string = text + content_offset;
            size_t string_length = content_length;
            if (has_escapes) {
                for (size_t i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') {
                        string_length--;
                        i++;
                    }
                }
                char *unescaped = malloc(string_length);
                size_t j = 0;
                for (size_t i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') i++;
                    unescaped[j++] = text[content_offset + i];
                }
                string = unescaped;
            }
            write_string_token(offset, token_length, string, string_length, has_escapes, tokenizer->info);
        }
        run->tokens[number_of_tokens] = token;
        whitespace = 0;
        number_of_tokens++;
        offset += token_length;
        if (end_token) {
            assert(number_of_tokens < 4096);
            run->tokens[number_of_tokens] = 4294967295U;
            number_of_tokens++;
        }
    }
    if (number_of_tokens == 0) {
        tokenizer->offset = offset;
        tokenizer->whitespace = whitespace;
        free(run);
        return false;
    }
    tokenizer->offset = offset;
    tokenizer->whitespace = whitespace;
    run->prev = *previous_run;
    run->number_of_tokens = number_of_tokens;
    run->lengths_size = lengths_size;
    *previous_run = run;
    return true;
}
static void find_token_range(struct owl_default_tokenizer *tokenizer, struct owl_token_run *run, uint16_t index, size_t *start, size_t *end) {
    size_t offset = tokenizer->offset - tokenizer->whitespace;
    size_t last_offset = offset;
    size_t len = 0;
    uint16_t length_offset = run->lengths_size - 1;
    for (uint16_t j = index;
    j < run->number_of_tokens;
    ++j) {
        if (run->tokens[j] == 4294967295U) continue;
        last_offset = offset;
        len = decode_token_length(run, &length_offset, &offset);
    }
    *start = last_offset - len;
    *end = last_offset;
}
static void estimate_next_token_range(struct owl_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset;
    size_t i = tokenizer->offset + 1;
    while (tokenizer->text[i] != '\0' && !char_is_whitespace(tokenizer->text[i]) && !char_continues_identifier(tokenizer->text[i], tokenizer->info)) i++;
    *end = i;
}
static void find_end_range(struct owl_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset - tokenizer->whitespace - 1;
    *end = tokenizer->offset - tokenizer->whitespace;
    if (*start > *end) {
        *start = *end;
        *end += 1;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context);
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context);
static size_t number_of_slots_lookup(uint32_t rule, void *context);
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context);
enum construct_fixity_associativity {
CONSTRUCT_PREFIX, CONSTRUCT_POSTFIX, CONSTRUCT_INFIX_LEFT, CONSTRUCT_INFIX_RIGHT, CONSTRUCT_INFIX_FLAT, };
struct construct_node {
    struct construct_node *next;
    size_t number_of_slots;
    size_t *slots;
    uint32_t rule;
    uint16_t slot_index;
    uint16_t choice_index;
    enum construct_fixity_associativity fixity_associativity;
    int precedence;
    size_t start_location;
    size_t end_location;
};
struct construct_expression {
    struct construct_expression *parent;
    struct construct_node *first_operator;
    struct construct_node *first_value;
    uint32_t operand_slot_index;
    uint32_t left_slot_index;
    uint32_t right_slot_index;
    uint32_t rule;
    uint16_t slot_index;
};
enum construct_root_type {
CONSTRUCT_NORMAL_ROOT, CONSTRUCT_EXPRESSION_ROOT, };
struct construct_state {
    enum construct_root_type root_type;
    struct construct_node *under_construction;
    struct construct_expression *current_expression;
    struct construct_node *node_freelist;
    struct construct_expression *expression_freelist;
    void *info;
};
static struct construct_node *construct_node_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_node *node;
    size_t number_of_slots = number_of_slots_lookup(rule, s->info);
    if (s->node_freelist) {
        node = s->node_freelist;
        s->node_freelist = node->next;
        size_t *slots = node->slots;
        if (number_of_slots > node->number_of_slots) {
            slots = realloc(slots, number_of_slots * sizeof(size_t));
            if (!slots) abort();
        }
        memset(node, 0, sizeof(struct construct_node));
        memset(slots, 0, number_of_slots * sizeof(size_t));
        node->slots = slots;
    }
    else {
        node = calloc(1, sizeof(struct construct_node));
        if (!node) abort();
        node->slots = calloc(number_of_slots, sizeof(size_t));
        if (!node->slots) abort();
    }
    node->rule = rule;
    node->number_of_slots = number_of_slots;
    return node;
}
static struct construct_expression *construct_expression_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_expression *expr;
    if (s->expression_freelist) {
        expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        memset(expr, 0, sizeof(struct construct_expression));
    }
    else {
        expr = calloc(1, sizeof(struct construct_expression));
        if (!expr) abort();
    }
    (left_right_operand_slots_lookup(rule, &(expr->left_slot_index), &(expr->right_slot_index), &(expr->operand_slot_index), s->info));
    expr->rule = rule;
    return expr;
}
static void construct_node_free(struct construct_state *state, struct construct_node *node) {
    node->next = state->node_freelist;
    state->node_freelist = node;
}
static void construct_expression_free(struct construct_state *state, struct construct_expression *expr) {
    expr->parent = state->expression_freelist;
    state->expression_freelist = expr;
}
static bool construct_expression_should_reduce(struct construct_state *s, struct construct_expression *expr, struct construct_node *node) {
    if (node->fixity_associativity == CONSTRUCT_POSTFIX) return false;
    struct construct_node *top = expr->first_operator;
    if (!top) return false;
    return node->precedence < top->precedence || (node->precedence == top->precedence && node->fixity_associativity == CONSTRUCT_INFIX_RIGHT);
}
static void construct_expression_reduce(struct construct_state *s, struct construct_expression *expr) {
    struct construct_node *op = expr->first_operator;
    if (op->fixity_associativity == CONSTRUCT_INFIX_FLAT) {
        struct construct_node *first_value = expr->first_value;
        struct construct_node *last_value = first_value;
        struct construct_node *last_operator = op;
        size_t operand = op->slots[expr->operand_slot_index];
        struct construct_node *combined_op = construct_node_alloc(s, op->rule);
        combined_op->choice_index = op->choice_index;
        combined_op->slot_index = op->slot_index;
        combined_op->fixity_associativity = op->fixity_associativity;
        combined_op->precedence = op->precedence;
        struct construct_node *reversed_values = 0;
        while (last_operator && last_operator->choice_index == op->choice_index) {
            struct construct_node *next_op = last_operator->next;
            construct_node_free(s, last_operator);
            last_operator = next_op;
            assert(last_value);
            struct construct_node *next_value = last_value->next;
            last_value->next = reversed_values;
            reversed_values = last_value;
            last_value = next_value;
        }
        combined_op->start_location = first_value->start_location;
        combined_op->end_location = last_value->end_location;
        assert(last_value);
        operand = (finish_node((last_value)->rule, (last_value)->choice_index, operand, (last_value)->slots, (last_value)->start_location, (last_value)->end_location, s->info));
        combined_op->next = last_value->next;
        construct_node_free(s, last_value);
        while (reversed_values) {
            operand = (finish_node((reversed_values)->rule, (reversed_values)->choice_index, operand, (reversed_values)->slots, (reversed_values)->start_location, (reversed_values)->end_location, s->info));
            struct construct_node *next_value = reversed_values->next;
            construct_node_free(s, reversed_values);
            reversed_values = next_value;
        }
        expr->first_operator = last_operator;
        expr->first_value = combined_op;
        combined_op->slots[expr->operand_slot_index] = operand;
    }
    else if (op->fixity_associativity == CONSTRUCT_INFIX_LEFT || op->fixity_associativity == CONSTRUCT_INFIX_RIGHT) {
        expr->first_operator = op->next;
        struct construct_node *left = expr->first_value;
        struct construct_node *right = left->next;
        op->next = right->next;
        expr->first_value = op;
        op->start_location = left->start_location;
        op->end_location = right->end_location;
        op->slots[expr->left_slot_index] = (finish_node((left)->rule, (left)->choice_index, op->slots[expr->left_slot_index], (left)->slots, (left)->start_location, (left)->end_location, s->info));
        op->slots[expr->right_slot_index] = (finish_node((right)->rule, (right)->choice_index, op->slots[expr->right_slot_index], (right)->slots, (right)->start_location, (right)->end_location, s->info));
        construct_node_free(s, left);
        construct_node_free(s, right);
    }
    else {
        expr->first_operator = op->next;
        struct construct_node *value = expr->first_value;
        op->next = value->next;
        expr->first_value = op;
        if (value->start_location < op->start_location) op->start_location = value->start_location;
        if (value->end_location > op->end_location) op->end_location = value->end_location;
        op->slots[expr->operand_slot_index] = (finish_node((value)->rule, (value)->choice_index, op->slots[expr->operand_slot_index], (value)->slots, (value)->start_location, (value)->end_location, s->info));
        construct_node_free(s, value);
    }
}
static void construct_begin(struct construct_state *s, size_t offset, enum construct_root_type type) {
    s->root_type = type;
    uint32_t r = 0;
    if (type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = construct_expression_alloc(s, r);
        expr->parent = s->current_expression;
        s->current_expression = expr;
    }
    else {
        struct construct_node *node = construct_node_alloc(s, r);
        node->next = s->under_construction;
        node->end_location = offset;
        s->under_construction = node;
    }
}
static size_t construct_finish(struct construct_state *s, size_t offset) {
    size_t finished = 0;
    if (s->root_type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = s->current_expression;
        s->current_expression = expr->parent;
        while (expr->first_operator) construct_expression_reduce(s, expr);
        struct construct_node *node = expr->first_value;
        if (node) {
            finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            assert(node->next == 0);
            construct_node_free(s, node);
        }
        construct_expression_free(s, expr);
    }
    else {
        struct construct_node *node = s->under_construction;
        s->under_construction = node->next;
        node->start_location = offset;
        finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
        construct_node_free(s, node);
    }
    while (s->node_freelist) {
        struct construct_node *node = s->node_freelist;
        s->node_freelist = node->next;
        free(node->slots);
        free(node);
    }
    while (s->expression_freelist) {
        struct construct_expression *expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        free(expr);
    }
    return finished;
}
static void construct_action_apply(struct construct_state *s, uint16_t action, size_t offset) {
    switch ((((action) >> 12) & 0xf)) {
    case 8:
        {
            struct construct_node *node = construct_node_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            node->next = s->under_construction;
            node->slot_index = ((action) & 0xfff);
            node->end_location = offset;
            s->under_construction = node;
            break;
        }
    case 9:
        {
            struct construct_expression *expr = construct_expression_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            expr->parent = s->current_expression;
            s->current_expression = expr;
            expr->slot_index = ((action) & 0xfff);
            break;
        }
    case 1:
        {
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            size_t *finished;
            finished = &s->under_construction->slots[node->slot_index];
            *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            construct_node_free(s, node);
            break;
        }
    case 2:
        {
            struct construct_expression *expr = s->current_expression;
            s->current_expression = expr->parent;
            while (expr->first_operator) construct_expression_reduce(s, expr);
            size_t *finished;
            finished = &s->under_construction->slots[expr->slot_index];
            struct construct_node *node = expr->first_value;
            if (node) {
                *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
                assert(node->next == 0);
                construct_node_free(s, node);
            }
            construct_expression_free(s, expr);
            break;
        }
    case 3:
        s->under_construction->choice_index = ((action) & 0xfff);
        break;
    case 4:
        {
            uint16_t slot = ((action) & 0xfff);
            size_t *finished = &s->under_construction->slots[slot];
            *finished = finish_token(rule_lookup(s->under_construction->rule, slot, s->info), *finished, s->info);
            break;
        }
    case 10:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 11:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            enum construct_fixity_associativity fixity_associativity;
            int precedence;
            do {
                int local;
                fixity_associativity_precedence_lookup(&local, &precedence, expr->rule, ((action) & 0xfff), s->info);
                fixity_associativity = local;
            }
            while (0);
            node->fixity_associativity = fixity_associativity;
            node->precedence = precedence;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 5:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            node->next = expr->first_value;
            expr->first_value = node;
            break;
        }
    case 6:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            while (construct_expression_should_reduce(s, expr, node)) construct_expression_reduce(s, expr);
            node->next = expr->first_operator;
            expr->first_operator = node;
            if (node->fixity_associativity == CONSTRUCT_PREFIX) construct_expression_reduce(s, expr);
            break;
        }
    }
}

struct fill_run_continuation;
struct fill_run_state {
    uint32_t state;
    uint32_t reachability_mask[1];
    struct fill_run_continuation *cont;
};
struct fill_run_continuation {
    struct fill_run_state *stack;
    uint32_t top_index;
    uint32_t capacity;
    int error;
};
static void continuation_stack_push(struct fill_run_state **top) {
    struct fill_run_continuation *cont = (*top)->cont;
    cont->top_index++;
    if (cont->top_index >= cont->capacity) {
        size_t new_capacity = (cont->capacity + 2) * 3 / 2;
        if (new_capacity <= cont->capacity)
            abort();
        struct fill_run_state *new_states = realloc(cont->stack, new_capacity * sizeof(struct fill_run_state));
        if (!new_states)
            abort();
        cont->stack = new_states;
        cont->capacity = new_capacity;
        *top = &cont->stack[cont->top_index];
    } else
        (*top)++;
    (*top)->cont = cont;
}
static void bracket_entry_state(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index, uint32_t mask0);
static void (*state_funcs[92])(struct owl_token_run *, struct fill_run_state *, uint16_t);
static void state_func_70(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(0 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    default: top->cont->error = 1; return;
    }
}
static void state_func_2(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 3; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_14(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 17; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_30(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 33; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_53(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 56; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_15(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 16; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_17(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 18; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_8(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 19; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_82(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    if (top->cont->top_index == 0) {
        top->cont->error = 1;
        return;
    }
    top->cont->top_index--;
    top--;
    run->tokens[token_index] = 24;
    run->states[token_index] = top->state;
    state_funcs[top->state](run, top, token_index);
    return;
}
static void state_func_72(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    if (top->cont->top_index == 0) {
        top->cont->error = 1;
        return;
    }
    top->cont->top_index--;
    top--;
    run->tokens[token_index] = 25;
    run->states[token_index] = top->state;
    state_funcs[top->state](run, top, token_index);
    return;
}
static void state_func_31(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 32; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_33(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 34; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_46(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 51; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_54(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 55; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_56(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 57; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_1(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 58; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_87(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 90; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_88(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 89; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_90(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 91; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_73(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 76; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_74(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 75; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_76(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 77; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_61(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 62; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_58(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 20: top->state = 1; return;
    case 21: top->state = 2; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_59(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(3 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 12: top->state = 60; return;
    case 14: top->state = 61; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_20(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 3: top->state = 35; return;
    case 4: top->state = 36; return;
    case 5: top->state = 37; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_37(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 6: top->state = 38; return;
    case 7: top->state = 39; return;
    case 8: top->state = 40; return;
    case 9: top->state = 41; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_3(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 4; return;
    case 23: top->state = 5; return;
    case 24: top->state = 6; return;
    case 25: top->state = 7; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_28(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 29; return;
    case 23: top->state = 22; return;
    case 24: top->state = 23; return;
    case 25: top->state = 24; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_50(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 42; return;
    case 23: top->state = 43; return;
    case 24: top->state = 44; return;
    case 25: top->state = 45; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_86(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 78; return;
    case 23: top->state = 79; return;
    case 24: top->state = 80; return;
    case 25: top->state = 81; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_62(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 21: top->state = 63; return;
    case 23: top->state = 64; return;
    case 24: top->state = 65; return;
    case 25: top->state = 66; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_19(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 2: top->state = 20; return;
    case 20: top->state = 1; return;
    case 21: top->state = 21; return;
    case 23: top->state = 22; return;
    case 24: top->state = 23; return;
    case 25: top->state = 24; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_51(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 2: top->state = 20; return;
    case 20: top->state = 1; return;
    case 21: top->state = 52; return;
    case 23: top->state = 43; return;
    case 24: top->state = 44; return;
    case 25: top->state = 45; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_67(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 16: top->state = 67; return;
    case 17: top->state = 68; return;
    case 18: top->state = 69; return;
    case 19: top->state = 70; return;
    case 21: top->state = 63; return;
    case 23: top->state = 71; return;
    case 24: top->state = 65; return;
    case 25: top->state = 66; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_22(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 8; return;
    case 16: top->state = 25; return;
    case 17: top->state = 26; return;
    case 18: top->state = 27; return;
    case 19: top->state = 28; return;
    case 21: top->state = 29; return;
    case 23: top->state = 22; return;
    case 24: top->state = 23; return;
    case 25: top->state = 24; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_44(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 46; return;
    case 16: top->state = 47; return;
    case 17: top->state = 48; return;
    case 18: top->state = 49; return;
    case 19: top->state = 50; return;
    case 21: top->state = 42; return;
    case 23: top->state = 43; return;
    case 24: top->state = 44; return;
    case 25: top->state = 45; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_84(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 13: top->state = 82; return;
    case 16: top->state = 83; return;
    case 17: top->state = 84; return;
    case 18: top->state = 85; return;
    case 19: top->state = 86; return;
    case 21: top->state = 78; return;
    case 23: top->state = 79; return;
    case 24: top->state = 80; return;
    case 25: top->state = 81; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_71(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 15: top->state = 72; return;
    case 16: top->state = 67; return;
    case 17: top->state = 68; return;
    case 18: top->state = 69; return;
    case 19: top->state = 70; return;
    case 21: top->state = 63; return;
    case 23: top->state = 71; return;
    case 24: top->state = 65; return;
    case 25: top->state = 66; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_16(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 8; return;
    case 16: top->state = 9; return;
    case 17: top->state = 10; return;
    case 18: top->state = 11; return;
    case 19: top->state = 12; return;
    case 20: top->state = 1; return;
    case 21: top->state = 13; return;
    case 23: top->state = 5; return;
    case 24: top->state = 6; return;
    case 25: top->state = 7; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_77(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 10: top->state = 73; return;
    case 11: top->state = 74; return;
    case 16: top->state = 67; return;
    case 17: top->state = 68; return;
    case 18: top->state = 69; return;
    case 19: top->state = 70; return;
    case 21: top->state = 63; return;
    case 23: top->state = 71; return;
    case 24: top->state = 65; return;
    case 25: top->state = 66; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_34(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 8; return;
    case 10: top->state = 30; return;
    case 11: top->state = 31; return;
    case 16: top->state = 25; return;
    case 17: top->state = 26; return;
    case 18: top->state = 27; return;
    case 19: top->state = 28; return;
    case 21: top->state = 29; return;
    case 23: top->state = 22; return;
    case 24: top->state = 23; return;
    case 25: top->state = 24; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_57(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 46; return;
    case 10: top->state = 53; return;
    case 11: top->state = 54; return;
    case 16: top->state = 47; return;
    case 17: top->state = 48; return;
    case 18: top->state = 49; return;
    case 19: top->state = 50; return;
    case 21: top->state = 42; return;
    case 23: top->state = 43; return;
    case 24: top->state = 44; return;
    case 25: top->state = 45; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_91(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 10: top->state = 87; return;
    case 11: top->state = 88; return;
    case 13: top->state = 82; return;
    case 16: top->state = 83; return;
    case 17: top->state = 84; return;
    case 18: top->state = 85; return;
    case 19: top->state = 86; return;
    case 21: top->state = 78; return;
    case 23: top->state = 79; return;
    case 24: top->state = 80; return;
    case 25: top->state = 81; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_21(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 3; return;
    case 1: top->state = 8; return;
    case 10: top->state = 30; return;
    case 11: top->state = 31; return;
    case 16: top->state = 25; return;
    case 17: top->state = 26; return;
    case 18: top->state = 27; return;
    case 19: top->state = 28; return;
    case 21: top->state = 29; return;
    case 23: top->state = 22; return;
    case 24: top->state = 23; return;
    case 25: top->state = 24; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_52(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 3; return;
    case 1: top->state = 46; return;
    case 10: top->state = 53; return;
    case 11: top->state = 54; return;
    case 16: top->state = 47; return;
    case 17: top->state = 48; return;
    case 18: top->state = 49; return;
    case 19: top->state = 50; return;
    case 21: top->state = 42; return;
    case 23: top->state = 43; return;
    case 24: top->state = 44; return;
    case 25: top->state = 45; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_18(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 8; return;
    case 10: top->state = 14; return;
    case 11: top->state = 15; return;
    case 16: top->state = 9; return;
    case 17: top->state = 10; return;
    case 18: top->state = 11; return;
    case 19: top->state = 12; return;
    case 20: top->state = 1; return;
    case 21: top->state = 13; return;
    case 23: top->state = 5; return;
    case 24: top->state = 6; return;
    case 25: top->state = 7; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_13(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 3; return;
    case 1: top->state = 8; return;
    case 10: top->state = 14; return;
    case 11: top->state = 15; return;
    case 16: top->state = 9; return;
    case 17: top->state = 10; return;
    case 18: top->state = 11; return;
    case 19: top->state = 12; return;
    case 20: top->state = 1; return;
    case 21: top->state = 13; return;
    case 23: top->state = 5; return;
    case 24: top->state = 6; return;
    case 25: top->state = 7; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void (*state_funcs[92])(struct owl_token_run *, struct fill_run_state *, uint16_t) = {
    state_func_58, state_func_1, state_func_2, state_func_3,
    state_func_18, state_func_16, state_func_16, state_func_16,
    state_func_8, state_func_16, state_func_16, state_func_16,
    state_func_3, state_func_13, state_func_14, state_func_15,
    state_func_16, state_func_17, state_func_18, state_func_19,
    state_func_20, state_func_21, state_func_22, state_func_22,
    state_func_22, state_func_22, state_func_22, state_func_22,
    state_func_28, state_func_34, state_func_30, state_func_31,
    state_func_22, state_func_33, state_func_34, state_func_50,
    state_func_50, state_func_37, state_func_50, state_func_50,
    state_func_50, state_func_50, state_func_57, state_func_44,
    state_func_44, state_func_44, state_func_46, state_func_44,
    state_func_44, state_func_44, state_func_50, state_func_51,
    state_func_52, state_func_53, state_func_54, state_func_44,
    state_func_56, state_func_57, state_func_58, state_func_59,
    state_func_86, state_func_61, state_func_62, state_func_77,
    state_func_71, state_func_67, state_func_67, state_func_67,
    state_func_67, state_func_67, state_func_70, state_func_71,
    state_func_72, state_func_73, state_func_74, state_func_67,
    state_func_76, state_func_77, state_func_91, state_func_84,
    state_func_84, state_func_84, state_func_82, state_func_84,
    state_func_84, state_func_84, state_func_86, state_func_87,
    state_func_88, state_func_84, state_func_90, state_func_91,};
static void bracket_entry_state(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index, uint32_t mask0) {
    continuation_stack_push(&top);
    top->reachability_mask[0] = mask0;
    run->states[token_index] = 59;
    state_func_59(run, top, token_index);
    if (top->cont->error == -1)
        top->cont->error = 1;
}
static bool fill_run_states(struct owl_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index);
static size_t build_parse_tree(struct owl_default_tokenizer *, struct owl_token_run *, struct owl_tree *);

static struct owl_tree *owl_tree_create_empty(void) {
    return calloc(1, sizeof(struct owl_tree));
}

struct owl_tree *owl_tree_create_from_string(const char *string) {
    struct owl_tree *tree = owl_tree_create_empty();
    tree->string = string;
    tree->next_offset = 1;
    struct owl_default_tokenizer tokenizer = {
        .text = string,
        .info = tree,
    };
    struct owl_token_run *token_run = 0;
    struct fill_run_continuation c = {
        .capacity = 8,
        .top_index = 0,
    };
    c.stack = calloc(c.capacity, sizeof(struct fill_run_state));
    c.stack[0].state = 0;
    c.stack[0].cont = &c;
    uint16_t failing_index = 0;
    while (owl_default_tokenizer_advance(&tokenizer, &token_run)) {
        if (!fill_run_states(token_run, &c, &failing_index)) {
            free(c.stack);
            tree->error = ERROR_UNEXPECTED_TOKEN;
            find_token_range(&tokenizer, token_run, failing_index, &tree->error_range.start, &tree->error_range.end);
            return tree;
        }
    }
    struct fill_run_state top = c.stack[c.top_index];
    free(c.stack);
    if (string[tokenizer.offset] != '\0') {
        tree->error = ERROR_INVALID_TOKEN;
        estimate_next_token_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        return tree;
    }
    switch (top.state) {
    case 0:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 11:
    case 13:
    case 16:
    case 18:
    case 19:
    case 51:
    case 58:
        break;
    default:
        tree->error = ERROR_MORE_INPUT_NEEDED;
        find_end_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        return tree;
    }
    tree->root_offset = build_parse_tree(&tokenizer, token_run, tree);
    return tree;
}
static struct owl_tree *owl_tree_create_with_error(enum owl_error e) {
    struct owl_tree *tree = owl_tree_create_empty();
    tree->error = e;
    return tree;
}
struct owl_tree *owl_tree_create_from_file(FILE *file) {
    if (!file)
        return owl_tree_create_with_error(ERROR_INVALID_FILE);
    char *str = 0;
    size_t len = 32;
    size_t off = 0;
    while (true) {
        len = len * 3 / 2;
        char *s = realloc(str, len * 3 / 2);
        if (!s) {
            free(str);
            return 0;
        }
        str = s;
        off += fread(str + off, 1, len - off, file);
        if (off < len) {
            str[off] = '\0';
            break;
        }
    }
    struct owl_tree *tree = owl_tree_create_from_string(str);
    if (!tree) {
        free(str);
        return 0;
    }
    tree->owns_string = true;
    return tree;
}
enum owl_error owl_tree_get_error(struct owl_tree *tree, struct source_range *error_range) {
    if (error_range)
        *error_range = tree->error_range;
    return tree->error;
}
void owl_tree_destroy(struct owl_tree *tree) {
    if (!tree)
        return;
    if (tree->owns_string)
        free((void *)tree->string);
    free(tree->parse_tree);
    free(tree->identifier_tokens);
    free(tree->number_tokens);
    for (uint32_t i = 0; i < tree->number_of_string_tokens; ++i) {
        if (tree->string_tokens[i].has_escapes)
            free((void *)tree->string_tokens[i].string);
    }
    free(tree->string_tokens);
    free(tree);
}
static bool fill_run_states(struct owl_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index) {
    uint16_t token_index = 0;
    uint16_t number_of_tokens = run->number_of_tokens;
    while (token_index < number_of_tokens) {
        struct fill_run_state *top = &cont->stack[cont->top_index];
        run->states[token_index] = top->state;
        state_funcs[top->state](run, top, token_index);
        if (cont->error) {
            *failing_index = token_index - (cont->error > 0 ? 0 : 1);
            return false;
        }
        token_index++;
    }
    return true;
}
static const uint16_t actions[] = {
0,0,4096,0,4096,16385,0,4096,32768,32769,16385,0,4096,32768,32769,32770,32769,16385,0,4096,32768,32769,36864,40960,16384,0,4096,32768,32769,36864,
40960,16385,0,4096,32768,32769,36864,40960,16386,0,4096,32768,32769,36864,40961,16387,0,4096,32768,32769,36864,40962,0,4096,32768,32769,36864,40963,0,4096,
32768,32769,36864,45060,0,4096,32768,32769,36864,45061,0,4096,32768,32769,36864,45062,0,4096,32769,16384,0,4096,32770,32769,16385,0,16384,0,16385,0,
16389,0,16390,0,20480,8192,0,20480,8192,4096,0,20480,8192,4096,32768,12288,0,20480,8192,4096,32768,12289,0,20480,8192,4096,32768,12290,32768,12288,
0,20480,8192,4096,32768,12290,32768,12289,0,20480,8192,4096,32768,12290,32768,12290,0,20480,8192,4096,32768,12290,32768,12291,0,20480,8192,4096,32769,16385,
0,20480,8192,16385,0,20480,8192,16389,0,20480,45063,24576,40960,16384,0,20480,45063,24576,40960,16385,0,20480,45063,24576,40960,16386,0,20480,45063,24576,
40961,16387,0,20480,45063,24576,40962,0,20480,45063,24576,40963,0,20480,45063,24576,45060,0,20480,45063,24576,45061,0,20480,45063,24576,45062,0,20480,45064,
0,24576,40960,16384,0,24576,40960,16385,0,24576,40960,16386,0,24576,40961,16387,0,24576,40962,0,24576,40963,0,24576,45060,0,24576,45061,0,24576,
45062,0,32768,32769,16385,0,32768,32769,32770,32769,16385,0,32768,32769,36864,40960,16384,0,32768,32769,36864,40960,16385,0,32768,32769,36864,40960,16386,0,
32768,32769,36864,40961,16387,0,32768,32769,36864,40962,0,32768,32769,36864,40963,0,32768,32769,36864,45060,0,32768,32769,36864,45061,0,32768,32769,36864,45062,
0,32769,16384,0,36864,40960,16384,0,36864,40960,16385,0,36864,40960,16386,0,36864,40961,16387,0,36864,40962,0,36864,40963,0,36864,45060,0,36864,
45061,0,36864,45062,0,36868,40960,16384,0,36868,40960,16385,0,36868,40960,16386,0,36868,40961,16387,0,36868,40962,0,36868,40963,0,36868,45060,0,
36868,45061,0,36868,45062,0,};
struct action_table_entry {
    uint32_t target_nfa_state;
    uint32_t dfa_state;
    uint32_t dfa_symbol;
    uint32_t nfa_state;
    uint32_t actions;
    uint32_t push_nfa_state;
};
static const struct action_table_entry action_table[1024][3] = {
{{858,67,24,871,351,856},{12,85,24,871,183,12},},{{1,49,16,2,193},},{{3,36,24,871,320,1},{1,48,18,2,203},},{{855,11,18,16,332},
{6,4,16,16,286},},{{55,27,17,21,329},{12,81,24,871,183,12},},{{4,16,16,16,193},},{{855,9,17,16,329},{21,21,23,5,223},},
{{21,23,24,871,227,5},{4,13,19,16,208},},{{858,75,24,871,351,856},{4,13,0,864,97},},{0},{{856,67,24,871,183,856},{11,4294967295U,4294967295U,6,1,6},},
{0},{{863,10,20,7,0},},{{7,18,17,16,65},{1,50,23,1,177},},{{7,13,21,4,19},{1,47,17,2,198},},{{858,63,23,856,347},},
{{21,29,17,21,236},{11,15,21,872,264},},{{855,16,23,4,316},},{{860,79,16,859,357},{11,9,17,16,291},},{{856,75,21,856,159},
{855,18,23,4,316},},{{857,64,24,871,227,856},{855,7,21,4,304},{6,11,16,16,286},},{{857,66,23,856,223},{55,23,16,21,326},
{2,55,21,1,211},},{{856,77,18,857,203},{3,43,23,1,316},},{{11,12,25,878,281,4},{6,9,21,4,252},},{{6,7,16,16,286},},
{{5,25,24,871,183,5},},{{5,34,24,871,183,5},{5,27,21,5,159},},{{4,6,16,16,193},},{{860,83,18,859,363},{2,38,21,1,211},},
{{860,80,16,859,357},{55,26,25,878,323,5},},{{5,29,23,5,177},},{0},{{858,74,21,882,343},{21,33,21,892,215},},{{861,4,1,855,0},
{859,78,21,12,211},},{{16,11,16,16,233},{1,55,21,1,159},},{{856,64,18,857,203},{21,22,25,878,230,5},{3,52,21,1,304},},
{{860,80,21,12,335},{11,18,16,16,286},{4,12,25,878,188,4},},{{857,69,24,871,227,856},{2,52,18,2,239},},{{856,66,17,857,198},
{55,32,16,21,326},{1,49,23,1,177},},{{877,21,10,865,0},{11,16,21,4,252},{1,51,24,871,183,1},},{{857,66,18,857,239},
{856,64,17,857,198},},{{856,65,17,857,198},{16,9,17,16,236},},{{12,59,12,886,94},},{{858,66,18,857,363},},{{16,4,25,878,230,4},
{4,10,23,4,177},},{{856,77,25,878,188,856},{1,56,21,888,165},},{{5,22,24,871,183,5},},{{1,42,21,1,159},},{{1,57,17,2,198},},
{{12,91,19,859,208},{12,78,18,859,203},},{{5,24,18,21,203},},{{859,86,23,12,223},{7,4,17,16,65},{3,40,25,878,323,1},},
{{860,89,16,859,357},{856,76,21,893,165},},{{4,16,24,871,183,4},},{0},{{860,91,21,12,335},{860,91,17,859,360},},{{860,85,16,859,357},
{21,19,23,5,223},{1,52,24,871,183,1},},{{867,78,21,12,86},{855,11,16,16,326},{6,4,18,16,296},},{{55,27,23,5,316},
{2,56,21,888,215},},{{1,54,21,874,171},},{{884,78,11,867,0},{21,21,21,5,211},{11,6,16,16,286},},{{870,55,1,3,0},
{859,85,18,859,239},{4,13,17,16,198},},{{859,80,24,871,227,12},{12,83,16,859,193},},{{866,13,21,4,86},},{{857,77,21,856,211},},
{{2,47,17,2,236},},{{857,68,18,857,239},{55,29,25,878,323,5},},{{861,22,1,55,0},{1,50,25,878,188,1},},{{875,21,11,865,0},
{1,47,19,2,208},},{{858,67,25,878,354,856},{858,63,21,856,335},},{0},{{5,21,18,21,203},},{{860,79,18,859,363},{1,41,25,878,188,1},},
{{858,71,25,878,354,856},{856,75,23,856,177},},{{2,49,24,871,227,1},},{{3,45,16,2,326},},{{856,77,16,857,193},{3,43,21,1,304},},
{{855,5,18,16,332},{6,9,23,4,270},},{{4,4,19,16,208},},{{864,7,21,7,86},},{{5,27,23,5,177},},{{11,46,21,870,246},
{4,6,18,16,203},},{{857,63,21,856,211},{12,84,23,12,177},{6,5,24,871,276,4},},{{55,26,23,5,316},{2,57,21,1,211},},
{{3,39,25,878,323,1},},{{55,27,24,871,320,5},{7,10,17,16,65},},{0},{{859,83,18,859,239},{855,16,17,16,329},},{{869,67,23,858,92},
{1,55,23,1,177},},{{856,64,16,857,193},{3,52,23,1,316},},{{11,7,23,4,270},},{{12,78,24,871,183,12},},{{1,49,21,1,159},},
{{856,68,16,857,193},{11,16,23,4,270},},{{858,76,21,893,339},{55,28,24,871,320,5},},{{2,44,24,871,227,1},},{{866,18,21,4,86},
{855,6,16,16,326},},{{858,75,17,857,360},{858,66,16,857,357},},{{870,48,1,3,0},{6,12,21,4,252},{4,10,17,16,198},},
{{857,71,16,857,233},{21,32,23,5,223},},{{857,65,21,856,211},{12,89,16,859,193},},{{7,46,21,870,12},{1,42,23,1,177},},
{{892,30,1,877,0},{6,10,23,4,270},{2,48,17,2,236},},{{857,67,16,857,233},{12,91,21,12,159},},{{861,13,1,855,0},
{5,24,16,21,193},},{{859,86,21,12,211},{5,26,23,5,177},},{{858,68,25,878,354,856},{16,12,23,4,223},{11,13,21,4,252},},
{{856,69,23,856,177},{12,85,23,12,177},},{{16,10,23,4,223},{1,37,9,889,137},},{{860,91,23,12,347},{16,11,23,4,223},},
{{21,19,25,878,230,5},{3,57,21,1,304},},{{6,17,21,887,258},{4,18,16,16,193},},{{55,27,21,5,304},{2,43,24,871,227,1},},
{{869,66,23,858,92},{7,7,16,16,59},{3,55,16,2,326},},{{876,13,10,866,0},{55,21,17,21,329},{21,34,16,21,233},},
{{11,6,23,4,270},{4,5,19,16,208},},{{859,79,25,878,230,12},{856,63,18,857,203},{12,83,18,859,203},},{{864,13,21,7,86},
{55,22,21,5,304},},{{858,77,16,857,357},{856,63,24,871,183,856},},{{857,74,21,882,219},{855,13,24,871,320,4},{2,47,23,1,223},},
{{857,68,16,857,233},},{{1,45,24,871,183,1},},{{7,16,16,16,59},{1,47,21,1,159},},{{21,29,18,21,239},{3,44,21,1,304},},
{{3,47,17,2,329},},{{5,21,16,21,193},},{{1,41,23,1,177},},{{856,75,17,857,198},{11,5,16,16,286},},{{880,19,2,879,2},
{855,16,18,16,332},{855,7,17,16,329},},{{881,63,10,868,0},{3,45,18,2,332},},{0},{{11,12,21,4,252},{6,9,25,878,281,4},},
{{867,83,21,12,86},{4,4,17,16,198},},{{16,4,16,16,233},},{{858,69,24,871,351,856},{11,10,18,16,296},},{{3,55,18,2,332},},
{{12,84,21,12,159},{6,18,25,878,281,4},},{{857,77,16,857,233},{11,18,17,16,291},{2,57,23,1,223},},{{885,87,1,883,0},
{1,38,24,871,183,1},},{0},{{2,42,17,2,236},},{{859,83,16,859,233},{859,78,17,859,236},{12,80,24,871,183,12},},{{859,81,21,12,211},
{12,91,24,871,183,12},{1,55,25,878,188,1},},{{7,16,25,878,53,4},{3,52,17,2,329},},{{860,80,17,859,360},{11,7,21,4,252},},
{0},{{856,66,21,856,159},{1,44,18,2,203},},{{11,16,25,878,281,4},{1,46,21,870,145},},{{21,23,23,5,223},},{{882,77,11,868,0},
{11,6,25,878,281,4},},{{16,18,25,878,230,4},},{{865,34,21,5,86},{21,28,23,5,223},},{{6,12,23,4,270},{4,10,19,16,208},},
{{16,16,24,871,227,4},},{{859,89,25,878,230,12},{859,81,17,859,236},{7,13,17,16,65},},{{859,80,17,859,236},},{{55,22,16,21,326},
{6,10,21,4,252},},{{12,91,23,12,177},{4,5,25,878,188,4},},{0},{{866,9,21,4,86},{7,4,21,4,19},{5,26,17,21,198},},
{{11,13,23,4,270},{1,49,17,2,198},},{{12,85,21,12,159},{2,39,25,878,230,1},},{{859,84,16,859,233},},{{860,91,25,878,354,12},
{855,5,16,16,326},},{{3,57,23,1,316},},{{21,32,17,21,236},{4,18,18,16,203},},{{870,44,1,3,0},},{{862,49,21,1,86},
{858,75,23,856,347},{21,34,17,21,236},},{{21,34,18,21,239},{21,21,17,21,236},},{{11,6,21,4,252},},{{12,60,23,12,177},},
{{856,67,21,856,159},},{{856,69,24,871,183,856},{21,25,17,21,236},},{{2,47,21,1,211},},{{55,29,21,5,304},{2,45,16,2,233},},
{{856,71,17,857,198},},{{7,16,18,16,71},{1,47,23,1,177},},{{890,61,23,891,90},{6,13,23,4,270},},{{5,19,21,5,159},},
{{11,11,18,16,296},},{{6,4,23,4,270},{1,41,21,1,159},},{{865,32,21,5,86},{12,79,23,12,177},},{{857,66,24,871,227,856},
{6,6,23,4,270},},{{1,43,16,2,193},},{{7,7,25,878,53,4},{3,43,17,2,329},},{{11,12,23,4,270},},{{4,4,23,4,177},},
{{860,83,21,12,335},{5,27,24,871,183,5},},{{11,10,16,16,286},},{{860,81,17,859,360},{21,25,16,21,233},},{{860,86,21,12,335},
{857,63,25,878,230,856},{6,18,23,4,270},},{{2,57,17,2,236},},{{5,29,17,21,198},},{0},{{55,24,16,21,326},{2,42,23,1,223},},
{0},{{871,79,13,860,0},{859,81,23,12,223},{16,13,24,871,227,4},},{{862,35,21,1,86},{857,68,25,878,230,856},},{{2,40,25,878,230,1},},
{{857,75,24,871,227,856},},{{856,66,23,856,177},{1,44,16,2,193},},{{857,64,17,857,236},{4,52,0,864,97},},{{855,9,21,4,304},
{21,26,16,21,233},},{{16,16,18,16,239},},{{856,77,24,871,183,856},{16,5,24,871,227,4},},{{21,28,21,5,211},},{{858,64,17,857,360},
{6,12,25,878,281,4},},{{863,9,20,7,0},},{{868,68,21,856,86},{857,65,17,857,236},},{{3,42,25,878,323,1},},{{2,48,21,1,211},},
{{872,13,11,866,0},{4,5,23,4,177},},{{864,4,21,7,86},{7,6,24,871,47,4},},{{7,4,23,4,40},{5,26,19,21,208},},
{{4,16,23,4,177},},{{12,85,19,859,208},{2,52,24,871,227,1},},{{859,84,18,859,239},},{0},{{3,57,17,2,329},{1,52,18,2,203},},
{{12,81,19,859,208},{2,43,23,1,223},},{{5,32,24,871,183,5},},{{871,78,13,860,0},},{{855,9,25,878,323,4},{4,3,24,871,183,4},},
{{861,18,1,855,0},{21,23,16,21,233},},{{863,6,20,7,0},{12,60,21,12,159},},{{856,67,23,856,177},{1,48,25,878,188,1},},
{{861,7,1,855,0},{855,12,24,871,320,4},{11,4,16,16,286},},{{4,15,21,872,171},{3,48,17,2,329},},{{2,45,18,2,239},},
{{7,18,25,878,53,4},{3,50,21,1,304},},{{21,27,25,878,230,5},{4,9,18,16,203},},{{858,65,25,878,354,856},{12,91,17,859,198},
{6,13,17,16,291},},{{865,29,21,5,86},{2,51,24,871,227,1},},{{865,28,21,5,86},{7,3,24,871,47,4},},{{860,79,24,871,351,12},
{855,4,24,871,320,4},{3,47,23,1,316},},{{2,49,21,1,211},},{{12,88,21,884,171},{2,55,24,871,227,1},},{{1,43,18,2,203},},
{{16,4,23,4,223},{7,7,23,4,40},},{{855,5,24,871,320,4},},{{6,7,24,871,276,4},{4,4,21,4,159},},{{5,34,23,5,177},
{3,38,21,1,304},},{{3,41,25,878,323,1},},{{6,13,25,878,281,4},{4,6,24,871,183,4},},{{12,84,25,878,188,12},{6,18,21,4,252},},
{{874,57,11,862,0},{55,26,17,21,329},},{{855,16,16,16,326},},{{6,16,16,16,286},{6,3,23,4,270},},{{55,24,18,21,332},
{2,42,21,1,211},},{{11,11,24,871,276,4},},{{16,11,24,871,227,4},{6,4,25,878,281,4},},{{21,24,23,5,223},{7,5,24,871,47,4},},
{{55,19,25,878,323,5},},{0},{{870,52,1,3,0},{856,66,25,878,188,856},{16,13,18,16,239},},{{856,62,24,871,183,856},{3,48,21,1,304},},
{{858,75,16,857,357},{21,26,18,21,239},},{{16,16,16,16,233},},{0},{{862,45,21,1,86},},{{865,25,21,5,86},{861,25,1,55,0},
{11,1,23,863,301},},{{861,24,1,55,0},},{{862,56,21,888,88},{860,78,17,859,360},{1,42,24,871,183,1},},{0},{{857,71,23,856,223},
{2,48,23,1,223},},{{4,5,21,4,159},},{{857,69,23,856,223},},{{11,13,24,871,276,4},},{{6,6,17,16,291},{4,16,21,4,159},},
{{55,34,25,878,323,5},{12,85,17,859,198},},{{868,66,21,856,86},{857,65,23,856,223},},{{857,64,23,856,223},{16,6,24,871,227,4},},
{{862,38,21,1,86},{860,85,24,871,351,12},{1,52,16,2,193},},{{12,81,17,859,198},{2,43,21,1,211},},{{856,62,21,856,159},
{1,39,21,1,159},},{{55,23,18,21,332},{7,11,18,16,71},},{{861,9,1,855,0},},{{21,23,18,21,239},{4,13,25,878,188,4},},
{{7,9,17,16,65},},{{856,61,23,891,155},{1,35,24,871,183,1},},{{11,4,18,16,296},{3,51,25,878,323,1},},{{2,47,25,878,230,1},},
{{872,4,11,866,0},{860,85,18,859,363},{55,29,17,21,329},},{{877,29,10,865,0},{1,47,24,871,183,1},},{{867,91,21,12,86},
{4,9,16,16,193},},{{855,18,17,16,329},{21,29,24,871,227,5},},{{5,19,25,878,188,5},},{{859,88,21,884,219},{11,4,17,16,291},},
{{3,47,21,1,304},},{{856,65,25,878,188,856},{2,49,23,1,223},},{{864,58,21,7,86},{16,6,21,4,211},{12,79,16,859,193},},
{{16,7,21,4,211},{3,45,24,871,320,1},},{{16,4,17,16,236},{7,7,21,4,19},},{{855,11,24,871,320,4},{16,5,17,16,236},},
{{856,74,21,882,171},{5,25,19,21,208},},{{7,5,16,16,59},{5,34,17,21,198},},{{1,36,24,871,183,1},},{{862,39,21,1,86},},
{{855,10,18,16,332},{6,5,16,16,286},},{{1,38,21,1,159},},{{862,50,21,1,86},{860,84,17,859,360},},{{855,3,24,871,320,4},
{6,3,21,4,252},},{{7,16,24,871,47,4},},{{12,80,18,859,203},{4,2,0,864,97},},{{860,88,21,884,343},},{{21,24,21,5,211},
{11,7,24,871,276,4},},{{864,10,21,7,86},},{{863,5,20,7,0},{5,34,21,5,159},},{{16,13,16,16,233},{3,50,24,871,320,1},},
{{856,68,24,871,183,856},{3,48,23,1,316},},{{2,44,21,1,211},},{{16,15,21,872,219},{4,11,25,878,188,4},},{{859,91,25,878,230,12},
{55,25,23,5,316},},{{858,66,24,871,351,856},{7,13,18,16,71},},{{858,64,21,856,335},{4,10,25,878,188,4},},{{5,22,17,21,198},},
{{55,29,23,5,316},},{{1,57,24,871,183,1},},{{855,4,16,16,326},{2,48,25,878,230,1},},{{857,67,24,871,227,856},{4,3,25,878,188,4},},
{{5,24,24,871,183,5},{1,48,16,2,193},},{{860,89,25,878,354,12},{7,16,23,4,40},},{{862,40,21,1,86},{4,7,16,16,193},},
{{7,18,23,4,40},},{{5,28,24,871,183,5},},{{869,62,23,890,92},{3,38,25,878,323,1},},{{862,44,21,1,86},{5,23,21,5,159},},
{{55,32,25,878,323,5},{12,81,23,12,177},},{{1,39,23,1,177},},{{7,11,16,16,59},{3,55,24,871,320,1},},{{856,65,18,857,203},
{21,34,24,871,227,5},},{{864,11,21,7,86},{859,79,18,859,239},{12,83,25,878,188,12},},{{869,63,23,858,92},},{{860,81,21,12,335},},
{{858,77,24,871,351,856},{856,63,16,857,193},{3,51,23,1,316},},{{856,68,18,857,203},{855,13,16,16,326},},{{857,68,24,871,227,856},
{7,1,23,863,77},},{{855,18,21,4,304},},{{855,3,23,4,316},{7,3,23,4,40},},{{870,49,1,3,0},{4,11,17,16,198},},
{{859,89,23,12,223},},{{5,21,24,871,183,5},},{{858,71,18,857,363},{21,31,21,875,219},},{{855,16,25,878,323,4},{2,49,17,2,236},},
{{864,16,21,7,86},{12,79,18,859,203},},{{55,23,24,871,320,5},},{{5,32,18,21,203},},{{6,7,23,4,270},},{{875,29,11,865,0},
{866,6,21,4,86},{5,25,17,21,198},},{{16,6,18,16,239},{5,34,19,21,208},},{{859,60,24,871,227,12},{3,41,21,1,304},},
{{857,63,24,871,227,856},{11,8,21,861,242},},{{6,18,17,16,291},{2,38,25,878,230,1},},{{1,38,23,1,177},},{{865,23,21,5,86},
{860,84,23,12,347},},{0},{{55,32,18,21,332},{2,42,25,878,230,1},},{{859,78,25,878,230,12},{12,80,16,859,193},},{{860,86,25,878,354,12},
{21,22,16,21,233},},{{855,12,21,4,304},},{{857,64,16,857,233},},{0},{{858,68,21,856,335},},{{858,69,21,856,335},},{{857,69,17,857,236},
{855,10,16,16,326},{2,44,23,1,223},},{{7,12,23,4,40},{5,27,18,21,203},},{{859,91,23,12,223},{16,18,17,16,236},
{12,86,21,12,159},},{{858,65,21,856,335},},{{858,64,23,856,347},},{{12,89,25,878,188,12},{5,22,19,21,208},},{{871,89,13,860,0},
{16,3,24,871,227,4},{3,44,16,2,326},},{{857,62,21,856,211},},{{55,22,24,871,320,5},{1,20,4,880,107},},{{4,5,17,16,198},},
{{16,7,24,871,227,4},{7,4,24,871,47,4},},{{11,5,24,871,276,4},},{{4,16,17,16,198},{4,7,18,16,203},},{0},{{871,81,13,860,0},
{859,84,24,871,227,12},{1,37,7,889,121},},{{865,22,21,5,86},{860,85,23,12,347},},{{855,11,25,878,323,4},{6,10,17,16,291},},
{{12,81,21,12,159},{2,43,17,2,236},},{{869,77,23,858,92},{1,39,25,878,188,1},},{{871,84,13,860,0},{6,13,21,4,252},},
{{856,65,16,857,193},{21,21,25,878,230,5},},{{859,79,16,859,233},{12,60,24,871,183,12},{11,18,25,878,281,4},},{{7,9,21,4,19},
{3,48,16,2,326},},{{1,48,19,2,208},},{{21,25,25,878,230,5},{3,51,21,1,304},},{{855,13,18,16,332},{6,16,18,16,296},},
{{12,91,16,859,193},{1,45,19,2,208},},{{856,71,21,856,159},{7,13,24,871,47,4},{3,49,16,2,326},},{{858,67,16,857,357},
{855,3,21,4,304},},{{55,19,24,871,320,5},{4,11,19,16,208},},{{861,23,1,55,0},},{{860,79,21,12,335},},{{858,71,16,857,357},},
{{857,64,21,856,211},{855,7,24,871,320,4},},{{55,23,23,5,316},{2,55,18,2,239},},{{861,34,1,55,0},{5,23,16,21,193},
{1,43,24,871,183,1},},{{7,7,17,16,65},{3,43,25,878,323,1},},{{6,7,21,4,252},{4,4,24,871,183,4},},{{859,81,25,878,230,12},
{5,25,23,5,177},},{{5,27,16,21,193},},{{3,41,23,1,316},},{0},{{859,85,17,859,236},{12,86,25,878,188,12},},{{870,45,1,3,0},
{3,56,21,888,308},},{{11,11,25,878,281,4},{7,10,24,871,47,4},},{{11,10,25,878,281,4},{6,3,25,878,281,4},},{{55,33,21,892,308},
{7,5,25,878,53,4},},{{861,6,1,855,0},{1,55,16,2,193},},{{856,64,25,878,188,856},{21,22,18,21,239},},{{860,80,24,871,351,12},
{855,12,23,4,316},{21,24,17,21,236},},{{886,58,4294967295U,886,0,6},{856,62,25,878,188,856},},{{857,75,16,857,233},{856,63,25,878,188,856},},
{{861,21,1,55,0},{1,44,24,871,183,1},},{{21,32,21,5,211},},{{2,44,17,2,236},},{{7,12,25,878,53,4},},{{859,91,21,12,211},
{1,40,24,871,183,1},},{{11,3,24,871,276,4},},{{857,71,25,878,230,856},},{{859,89,16,859,233},{856,71,25,878,188,856},{5,22,21,5,159},},
{{16,12,21,4,211},{3,44,18,2,332},},{{16,13,21,4,211},{3,42,17,2,329},},{{855,17,21,887,308},{16,10,17,16,236},},
{{856,67,17,857,198},{5,24,23,5,177},},{{55,34,24,871,320,5},},{{858,68,18,857,363},{16,9,21,4,211},},{{16,6,25,878,230,4},
{11,11,23,4,270},},{{2,52,16,2,233},{2,39,23,1,223},},{0},{{860,85,21,12,335},},{{55,34,18,21,332},{4,18,25,878,188,4},},
{{55,32,21,5,304},{55,27,18,21,332},},{{860,80,25,878,354,12},},{{860,81,25,878,354,12},},{{55,25,17,21,329},},{{859,80,21,12,211},
{2,41,25,878,230,1},},{{7,9,23,4,40},{3,45,23,1,316},},{{860,85,17,859,360},{1,48,17,2,198},},{{860,60,23,12,347},
{11,4,24,871,276,4},},{{857,68,23,856,223},{2,45,25,878,230,1},},{{7,15,21,872,33},{1,45,17,2,198},},{{856,71,23,856,177},
{3,49,18,2,332},},{{858,63,18,857,363},{21,27,17,21,236},{11,17,21,887,258},},{{4,11,21,4,159},{3,42,23,1,316},},
{{856,65,24,871,183,856},{16,9,24,871,227,4},},{{3,47,24,871,320,1},},{{856,75,24,871,183,856},},{{855,16,21,4,304},},{{55,23,21,5,304},
{2,55,16,2,233},},{{5,23,18,21,203},},{{855,5,21,4,304},{6,9,16,16,286},},{{55,21,16,21,326},{5,26,25,878,188,5},},
{{858,65,18,857,363},{5,25,21,5,159},},{{3,51,24,871,320,1},},{{858,67,18,857,363},{12,85,18,859,203},},{{857,63,16,857,233},
{12,84,18,859,203},},{{857,77,25,878,230,856},{855,3,25,878,323,4},{5,29,21,5,159},},{{5,29,24,871,183,5},},{0},{{6,16,24,871,276,4},},
{{6,46,21,870,246},},{{1,55,18,2,203},},{{3,52,24,871,320,1},},{{855,12,25,878,323,4},{11,7,18,16,296},},{{5,32,16,21,193},},
{{857,75,18,857,239},},{{856,68,23,856,177},{11,5,17,16,291},{3,48,24,871,320,1},},{{881,77,10,868,0},{55,25,24,871,320,5},
{21,26,25,878,230,5},},{{857,69,21,856,211},},{{862,51,21,1,86},{5,8,21,861,151},},{{16,18,21,4,211},{7,17,21,887,26},},
{{858,64,24,871,351,856},{55,29,16,21,326},},{{863,58,20,7,0},{2,50,25,878,230,1},},{{857,65,24,871,227,856},{855,18,25,878,323,4},
{2,35,25,878,230,1},},{{860,78,25,878,354,12},{1,42,16,2,193},},{{873,57,10,862,0},{862,41,21,1,86},{1,57,18,2,203},},
{{6,10,25,878,281,4},},{{7,6,17,16,65},{5,24,21,5,159},},{{5,26,24,871,183,5},},{{855,7,18,16,332},{11,13,16,16,286},},
{{11,11,21,4,252},{6,6,25,878,281,4},},{{863,19,20,7,0},{858,75,21,856,335},{2,39,21,1,211},},{{860,91,16,859,357},},
{{3,57,24,871,320,1},{3,36,25,878,323,1},},{{55,34,16,21,326},{21,32,24,871,227,5},},{{55,27,16,21,326},{12,81,25,878,188,12},},
{0},{{891,59,14,886,0},{855,9,16,16,326},{21,34,21,5,211},},{{855,15,21,872,312},},{{859,80,23,12,223},{857,71,18,857,239},},
{{16,10,25,878,230,4},{7,9,25,878,53,4},},{{856,67,25,878,188,856},{1,48,23,1,177},},{{860,60,21,12,335},},{{857,68,21,856,211},
{11,11,16,16,286},},{{7,18,18,16,71},{1,45,23,1,177},},{{7,16,21,4,19},{1,47,16,2,193},},{{858,63,16,857,357},
{6,6,21,4,252},{4,9,24,871,183,4},},{{21,29,16,21,233},{4,11,23,4,177},},{{5,21,23,5,177},},{{860,79,17,859,360},},
{{55,23,25,878,323,5},},{{857,64,25,878,230,856},{6,11,17,16,291},},{{868,62,21,856,86},{860,80,23,12,347},{12,79,24,871,183,12},},
{{860,81,23,12,347},},{{855,5,23,4,316},{6,9,18,16,296},},{{55,21,18,21,332},{6,7,17,16,291},},{{12,90,21,885,165},
{3,45,17,2,329},},{{857,62,25,878,230,856},{5,34,25,878,188,5},},{{861,29,1,55,0},},{{12,84,16,859,193},},{{2,57,24,871,227,1},
{2,36,25,878,230,1},},{{16,10,24,871,227,4},},{{860,84,25,878,354,12},},{{55,34,17,21,329},},{{859,83,23,12,223},{5,31,21,875,171},},
{{859,81,24,871,227,12},{16,11,17,16,236},{16,6,16,16,233},},{{855,9,23,4,316},{3,35,25,878,323,1},},{{11,7,16,16,286},
{4,12,24,871,183,4},},{{2,40,21,1,211},},{{856,66,16,857,193},{1,44,23,1,177},},{{856,68,21,856,159},{856,62,23,856,177},
{11,16,18,16,296},},{{55,28,23,5,316},{11,18,21,4,252},},{0},{0},{{859,91,17,859,236},{16,18,23,4,223},},{{867,86,21,12,86},
{855,6,17,16,329},},{{866,16,21,4,86},},{{5,22,25,878,188,5},{2,35,23,1,223},},{{1,42,18,2,203},},{{1,57,16,2,193},},
{{12,78,17,859,198},{11,5,25,878,281,4},},{{861,26,1,55,0},{7,6,23,4,40},{5,24,19,21,208},},{{859,86,24,871,227,12},
{3,42,16,2,326},},{{862,55,21,1,86},{860,89,17,859,360},{11,13,18,16,296},},{{859,85,21,12,211},{4,7,24,871,183,4},},
{{859,84,21,12,211},{7,8,21,861,7},},{{860,91,18,859,363},{7,11,17,16,65},},{{11,9,18,16,296},{1,52,25,878,188,1},},
{{6,4,17,16,291},{4,18,21,4,159},},{{55,32,17,21,329},{7,12,21,4,19},},{{11,18,24,871,276,4},},{{855,9,18,16,332},
{21,34,23,5,223},},{{21,23,25,878,230,5},{4,13,18,16,203},},{{859,80,25,878,230,12},{2,41,21,1,211},},{0},{{1,48,21,1,159},},
{{2,47,18,2,239},},{{55,29,24,871,320,5},{12,89,19,859,208},},{{7,18,16,16,59},{1,45,21,1,159},},{{1,47,18,2,203},},
{{874,42,11,862,0},{21,27,21,5,211},},{{866,17,21,887,88},{5,23,24,871,183,5},},{{5,21,21,5,159},},{{865,24,21,5,86},
{1,41,24,871,183,1},},{0},{{6,11,23,4,270},{2,49,25,878,230,1},},{{874,52,11,862,0},{55,23,17,21,329},},{{856,77,17,857,198},},
{{855,5,17,16,329},{11,12,24,871,276,4},},{{879,8,21,861,4},{4,4,18,16,203},},{{863,18,20,7,0},{5,25,25,878,188,5},},
{0},{{855,18,18,16,332},{4,6,17,16,198},},{{868,67,21,856,86},{6,5,25,878,281,4},},{{55,26,24,871,320,5},{11,10,24,871,276,4},},
{{3,39,24,871,320,1},},{{869,65,23,858,92},{7,10,18,16,71},},{{55,24,21,5,304},{2,42,18,2,239},},{{859,83,21,12,211},},
{{858,62,24,871,351,856},},{{862,48,21,1,86},{21,22,24,871,227,5},{3,35,23,1,316},},{{860,80,18,859,363},{11,18,23,4,270},},
{{2,40,23,1,223},},{{856,66,18,857,203},{16,13,25,878,230,4},{1,44,21,1,159},},{{11,5,21,4,252},{1,51,25,878,188,1},},
{{55,28,25,878,323,5},{21,26,21,5,211},},{{857,69,25,878,230,856},},{0},{{858,62,23,856,347},{856,71,24,871,183,856},{11,3,23,4,270},},
{{855,6,23,4,316},{4,10,16,16,193},},{{864,0,21,7,86},},{{16,10,18,16,239},{2,35,21,1,211},},{{3,44,24,871,320,1},},
{{855,4,25,878,323,4},{2,48,16,2,233},},{{857,67,23,856,223},{12,78,19,859,208},{2,54,21,874,219},},{{16,5,21,4,211},
{5,24,17,21,198},},{{7,4,16,16,59},{3,40,24,871,320,1},},{{858,68,24,871,351,856},{858,68,16,857,357},},{{11,11,17,16,291},
{4,16,25,878,188,4},},{{866,11,21,4,86},{859,84,23,12,223},{1,37,8,889,129},},{{883,78,10,867,0},{55,22,18,21,332},},
{{869,64,23,858,92},{3,36,21,1,304},{1,52,23,1,177},},{{855,11,17,16,329},{4,18,23,4,177},},{{879,46,21,870,81},
{21,24,25,878,230,5},{2,43,25,878,230,1},},{0},{{21,21,18,21,239},{4,3,21,4,159},},{{11,6,24,871,276,4},{4,13,16,16,193},},
{{859,79,24,871,227,12},{12,83,19,859,208},{2,41,23,1,223},},{0},{{867,60,21,12,86},{858,77,17,857,360},{11,4,21,4,252},},
{{55,31,21,875,312},{2,47,16,2,233},},{{857,68,17,857,236},},{{1,50,24,871,183,1},},{{7,16,17,16,65},{3,49,24,871,320,1},},
{{21,27,23,5,223},{2,49,18,2,239},},{{16,7,23,4,223},},{{5,21,19,21,208},},{{16,5,23,4,223},{3,47,18,2,332},},
{{862,42,21,1,86},{858,71,24,871,351,856},{855,10,24,871,320,4},},{{855,7,16,16,326},{6,11,21,4,252},},{{1,43,21,1,159},},
{{856,77,23,856,177},{3,43,18,2,332},},{{858,66,17,857,360},{12,84,17,859,198},},{{4,4,16,16,193},},{{873,52,10,862,0},
{864,18,21,7,86},},{{5,29,18,21,203},},{{4,6,19,16,208},},{{855,10,25,878,323,4},{6,18,24,871,276,4},},{{859,85,25,878,230,12},
{2,36,21,1,211},},{{865,26,21,5,86},{1,38,25,878,188,1},},{{16,9,16,16,233},{7,10,16,16,59},},{{55,24,23,5,316},
{2,42,16,2,233},},{{859,78,18,859,239},},{{1,55,24,871,183,1},},{{3,35,21,1,304},},{{7,11,24,871,47,4},{6,11,25,878,281,4},},
{{866,12,21,4,86},{55,25,25,878,323,5},},{{1,44,19,2,208},},{{856,68,17,857,198},{11,5,23,4,270},},{{55,26,21,5,304},
{21,26,23,5,223},},{{2,44,25,878,230,1},},{{16,18,24,871,227,4},{11,9,24,871,276,4},},{{858,62,21,856,335},{855,18,24,871,320,4},
{11,3,21,4,252},},{{855,6,21,4,304},{4,10,18,16,203},},{{857,71,17,857,236},},{{859,89,24,871,227,12},{857,65,18,857,239},
{12,89,23,12,177},},{{869,75,23,858,92},{859,79,21,12,211},{5,19,23,5,177},},{{55,22,17,21,329},{2,48,18,2,239},},
{{857,67,17,857,236},{12,78,21,12,159},},{{864,19,21,7,86},},{{16,7,18,16,239},{7,4,18,16,71},},{{860,89,21,12,335},
{5,22,23,5,177},},{{864,6,21,7,86},{861,27,1,55,0},{21,32,18,21,239},},{{859,84,17,859,236},{5,28,23,5,177},},
{0},{{888,53,1,873,0},{1,52,21,1,159},},{{855,11,23,4,316},{4,18,17,16,198},},{{870,57,1,3,0},},{{3,55,17,2,329},},
{{21,21,16,21,233},{4,3,23,4,177},},{{856,69,18,857,203},{21,23,21,5,211},},{{12,83,21,12,159},},{{871,83,13,860,0},
{7,3,21,4,19},},{{860,60,24,871,351,12},{856,69,25,878,188,856},{11,4,23,4,270},},{{863,4,20,7,0},{855,13,25,878,323,4},
{7,5,17,16,65},},{{866,5,21,4,86},{2,45,17,2,236},},{{1,45,25,878,188,1},},{{7,6,21,4,19},},{{4,11,24,871,183,4},},
{{861,10,1,855,0},{856,63,17,857,198},},{{860,60,25,878,354,12},{5,21,17,21,198},},{{3,47,16,2,326},},{{856,75,16,857,193},
{21,25,23,5,223},},{{868,71,21,856,86},{857,66,25,878,230,856},{12,79,21,12,159},},{{1,43,23,1,177},},{{856,77,21,856,159},
{5,32,25,878,188,5},{3,43,16,2,326},},{{858,69,16,857,357},{6,9,24,871,276,4},},{{55,21,24,871,320,5},},{0},{{11,10,17,16,291},},
{{4,6,21,4,159},},{{855,10,23,4,316},{6,5,21,4,252},},{{857,77,17,857,236},{2,36,23,1,223},},{{5,29,16,21,193},},
{{860,78,21,12,335},{6,16,21,4,252},},{{55,24,17,21,329},{16,7,17,16,236},},{{859,78,16,859,233},{12,80,25,878,188,12},},
{{858,69,23,856,347},{12,83,23,12,177},},{{856,64,23,856,177},{11,16,16,16,286},{3,52,16,2,326},},{{871,80,13,860,0},
{6,4294967295U,4294967295U,6,0,6},{2,40,24,871,227,1},},{{12,86,23,12,177},},{{858,65,23,856,347},{1,44,17,2,198},},{{11,16,24,871,276,4},
{1,51,21,1,159},},{{858,67,23,856,347},{21,26,17,21,236},},{{857,63,23,856,223},},{{860,85,25,878,354,12},{857,62,23,856,223},},
{{858,66,23,856,347},},{{858,64,16,857,357},{6,12,24,871,276,4},},{{873,42,10,862,0},},{{857,65,16,857,233},{12,89,21,12,159},},
{{865,27,21,5,86},{861,11,1,855,0},},{{55,22,23,5,316},{6,10,18,16,296},},{{12,78,23,12,177},{4,5,24,871,183,4},},
{{16,5,25,878,230,4},{7,6,25,878,53,4},},{{5,26,16,21,193},},{{6,6,18,16,296},{4,7,21,4,159},},{{868,64,21,856,86},
{2,39,24,871,227,1},},{{5,28,21,5,159},},{{860,91,24,871,351,12},},{{3,57,16,2,326},{1,52,19,2,208},},{{4,18,19,16,208},
{3,48,18,2,332},},{{12,84,24,871,183,12},},{{862,36,21,1,86},{3,55,23,1,316},},{{856,65,23,856,177},{855,9,24,871,320,4},
{1,49,18,2,203},},{{858,77,18,857,363},{12,91,18,859,203},},{{863,51,20,7,0},{6,18,16,16,286},},{{860,81,18,859,363},
{12,89,18,859,203},},{{858,77,21,856,335},{4,16,18,16,203},},{{855,7,25,878,323,4},},{{6,15,21,872,264},},{{5,23,25,878,188,5},},
{{21,27,24,871,227,5},{4,9,19,16,208},},{0},{{859,90,21,885,215},{2,51,25,878,230,1},},{{871,85,13,860,0},},{{862,57,21,1,86},
{860,79,25,878,354,12},},{{856,75,18,857,203},{4,21,0,864,97},},{{2,55,25,878,230,1},},{{3,45,21,1,304},{1,43,17,2,198},},
{{5,32,23,5,177},},{{858,69,18,857,363},},{{876,18,10,866,0},{6,7,25,878,281,4},{4,17,21,887,165},},{{7,5,21,4,19},
{5,27,25,878,188,5},},{{11,10,23,4,270},{3,41,24,871,320,1},},{{4,6,23,4,177},},{{855,10,21,4,304},{6,5,23,4,270},},
{{857,77,23,856,223},{55,26,18,21,332},{2,57,16,2,233},},{{860,84,18,859,363},},{{6,16,23,4,270},},{{858,63,25,878,354,856},},
{{860,83,16,859,357},{12,80,23,12,177},},{{859,81,16,859,233},{16,11,25,878,230,4},},{{860,86,23,12,347},{856,64,21,856,159},
{3,52,18,2,332},},{{863,7,20,7,0},},{{867,85,21,12,86},{857,75,25,878,230,856},},{{867,84,21,12,86},{856,66,24,871,183,856},},
{{869,71,23,858,92},{1,51,23,1,177},},{{867,90,21,885,88},},{{867,81,21,12,86},},{{867,80,21,12,86},{1,40,23,1,177},},
{{858,66,21,856,335},},{{858,64,18,857,363},{857,67,18,857,239},{855,6,25,878,323,4},},{{857,71,21,856,211},{857,66,16,857,233},
{2,50,23,1,223},},{{860,78,16,859,357},{1,42,25,878,188,1},},{{865,33,21,892,88},{3,42,24,871,320,1},},{{6,10,16,16,286},},
{{12,78,25,878,188,12},{6,8,21,861,242},},{{858,69,17,857,360},{12,83,17,859,198},},{{5,26,18,21,203},},{{6,6,16,16,286},
{4,7,23,4,177},},{{2,52,25,878,230,1},},{0},{{21,24,24,871,227,5},},{{3,57,18,2,332},{1,52,17,2,198},},{{863,0,20,7,0},
{857,63,17,857,236},{12,81,18,859,203},},{{859,60,25,878,230,12},{3,44,25,878,323,1},},{{3,55,21,1,304},},{{856,65,21,856,159},},
{{21,23,17,21,236},{11,6,18,16,296},},{{878,71,15,869,0},{16,10,16,16,233},{7,9,16,16,59},},{{860,81,16,859,357},
{1,48,24,871,183,1},},{{858,77,23,856,347},{3,42,21,1,304},},{{855,13,21,4,304},},{{2,45,21,1,211},},{{16,12,25,878,230,4},
{7,18,24,871,47,4},},{{884,91,11,867,0},{858,67,21,856,335},{4,9,17,16,198},},{{858,65,24,871,351,856},{55,19,23,5,316},
{6,13,16,16,286},},{{875,34,11,865,0},{5,19,24,871,183,5},{2,51,23,1,223},},{{7,3,25,878,53,4},},{0},{{857,64,18,857,239},},
{{12,79,17,859,198},},{{1,43,19,2,208},},{{5,32,21,5,159},{1,49,24,871,183,1},},{{855,5,25,878,323,4},{5,29,19,21,208},},
{{5,25,18,21,203},},{{16,6,23,4,223},{7,5,23,4,40},},{{11,10,21,4,252},{1,36,25,878,188,1},},{{860,90,21,885,339},
{4,6,25,878,188,4},},{{6,18,18,16,296},{6,5,17,16,291},},{{55,26,16,21,326},{2,57,18,2,239},},{{860,84,16,859,357},
{3,54,21,874,312},},{{6,16,17,16,291},},{0},{{12,80,21,12,159},{7,11,25,878,53,4},},{{859,81,18,859,239},},{{55,24,24,871,320,5},},
{0},{{859,83,17,859,236},},{{3,50,25,878,323,1},},{{11,9,25,878,281,4},},{{868,75,21,856,86},{857,69,18,857,239},},{{866,10,21,4,86},
{16,16,17,16,236},},{{859,91,24,871,227,12},{1,40,21,1,159},},{0},{{4,10,24,871,183,4},},{{855,4,18,16,332},{2,50,21,1,211},},
{{860,78,18,859,363},{3,44,23,1,316},},{{855,6,18,16,332},},{{855,4,17,16,329},{2,48,24,871,227,1},},{{893,73,1,881,0},},
{{866,7,21,4,86},{5,24,25,878,188,5},},{{11,13,25,878,281,4},},{{4,7,17,16,198},},{{12,85,16,859,193},},{{857,76,21,893,215},
{5,28,25,878,188,5},},{0},{{55,34,23,5,316},{6,4,24,871,276,4},},{{55,27,25,878,323,5},{12,81,16,859,193},},{{861,16,1,855,0},
{16,13,17,16,236},},{{55,32,24,871,320,5},{16,10,21,4,211},},{{868,63,21,856,86},{16,11,21,4,211},},{{861,5,1,855,0},
{4,13,24,871,183,4},},{{859,89,18,859,239},{7,9,18,16,71},{7,5,18,16,71},},{{856,67,16,857,193},{1,35,25,878,188,1},},
{{860,83,17,859,360},{858,77,25,878,354,856},{7,7,18,16,71},},{{855,13,23,4,316},{2,47,24,871,227,1},},{{55,29,18,21,332},
{2,45,23,1,223},},{{856,71,16,857,193},{3,49,21,1,304},{1,47,25,878,188,1},},{{860,83,25,878,354,12},{4,9,23,4,177},},
{{55,19,21,5,304},{6,13,18,16,296},},{{2,51,21,1,211},},{0},{0},{{860,84,21,12,335},{6,11,24,871,276,4},},{{864,5,21,7,86},
{12,79,19,859,208},},{{3,45,25,878,323,1},},{{21,19,24,871,227,5},{5,32,19,21,208},},{0},{{55,32,23,5,316},{5,25,16,21,193},},
{{16,6,17,16,236},{5,34,16,21,193},},{{1,36,23,1,177},},{0},{{855,10,17,16,329},{2,38,24,871,227,1},},{{16,7,16,16,233},},
{{16,4,18,16,239},},{{855,11,21,4,304},},{{870,43,1,3,0},{2,42,24,871,227,1},},{{12,80,19,859,208},},{{21,22,17,21,236},
{5,26,21,5,159},},{{11,7,25,878,281,4},},{0},{{857,75,21,856,211},},{{16,13,23,4,223},},{{856,68,25,878,188,856},{21,29,25,878,230,5},},
{{889,20,5,880,2},{857,69,16,857,233},{21,28,25,878,230,5},},{{21,19,21,5,211},{16,16,23,4,223},},{{16,18,16,16,233},},
{{858,66,25,878,354,856},{21,28,24,871,227,5},},{0},{{859,89,21,12,211},{5,22,16,21,193},},{{16,3,25,878,230,4},{3,44,17,2,329},},
{{877,34,10,865,0},{859,85,23,12,223},{1,57,25,878,188,1},},{{55,22,25,878,323,5},},{{857,67,25,878,230,856},{4,5,18,16,203},},
{{16,7,25,878,230,4},{7,4,25,878,53,4},},{{860,89,24,871,351,12},{858,68,23,856,347},{7,13,23,4,40},},{{4,7,19,16,208},},
{{2,52,21,1,211},},{{859,84,25,878,230,12},{1,37,6,889,113},},{{3,38,24,871,320,1},},{{55,34,21,5,304},{12,85,25,878,188,12},},
{{2,43,18,2,239},{1,49,19,2,208},},{{864,51,21,7,86},{859,60,21,12,211},{1,39,24,871,183,1},},{{3,55,25,878,323,1},},
{{21,21,24,871,227,5},{12,89,17,859,198},},{{859,80,16,859,233},{12,83,24,871,183,12},{4,16,19,16,208},},{0},{{856,67,18,857,203},
{855,6,24,871,320,4},},{{856,69,17,857,198},{21,25,24,871,227,5},},{{855,13,17,16,329},},{{1,45,18,2,203},},{{856,71,18,857,203},
{3,49,23,1,316},},{{858,67,17,857,360},{4,9,21,4,159},},{{867,89,21,12,86},{21,29,23,5,223},{4,11,16,16,193},},
{0},{{5,21,25,878,188,5},},{{859,83,24,871,227,12},{858,71,17,857,360},},{{855,16,24,871,320,4},{2,49,16,2,233},},{{857,66,17,857,236},
{11,9,16,16,286},},{{855,18,16,16,326},{5,23,23,5,177},},{{5,32,17,21,198},{3,43,24,871,320,1},},{{869,69,23,858,92},
{55,21,21,5,304},{6,4,21,4,252},},{{869,68,23,858,92},},{{867,79,21,12,86},{5,34,18,21,203},},{{7,7,24,871,47,4},
{1,36,21,1,159},},{{55,21,25,878,323,5},},{{859,85,16,859,233},{12,86,24,871,183,12},},{{858,63,24,871,351,856},},{{16,9,25,878,230,4},
{7,10,25,878,53,4},},{0},{{55,24,25,878,323,5},{21,25,18,21,239},},{{859,83,25,878,230,12},{859,78,24,871,227,12},{12,80,17,859,198},},
{{856,64,24,871,183,856},},{{21,24,18,21,239},{4,12,23,4,177},},{{2,57,25,878,230,1},},{{857,75,23,856,223},},{{16,12,24,871,227,4},
{1,44,25,878,188,1},},{{7,4294967295U,4294967295U,6,2,6},},{{2,44,16,2,233},},{{16,16,21,4,211},{16,11,18,16,239},},{{866,3,21,4,86},
{16,18,18,16,239},{1,40,25,878,188,1},},{{16,9,18,16,239},},{{860,78,24,871,351,12},{857,71,24,871,227,856},},{{878,64,15,869,0},
{12,89,24,871,183,12},{5,22,18,21,203},},{{862,43,21,1,86},{16,4,24,871,227,4},},{{3,42,18,2,332},{1,57,23,1,177},},
{{855,4,21,4,304},{1,20,3,880,101},},{{872,18,11,866,0},{4,5,16,16,193},},{{868,65,21,856,86},},{{858,68,17,857,360},},
{{860,86,24,871,351,12},},{{2,52,23,1,223},},{{868,69,21,856,86},{857,63,18,857,239},},{{11,9,21,4,252},},{{4,18,24,871,183,4},},
{{868,76,21,893,88},{2,43,16,2,233},},{{864,9,21,7,86},{859,60,23,12,223},},{{7,11,23,4,40},},{{55,25,16,21,326},
{4,13,23,4,177},},{{859,80,18,859,239},{859,79,17,859,236},{11,7,17,16,291},},{{11,6,17,16,291},},{{1,35,21,1,159},},
{{856,63,21,856,159},{11,4,25,878,281,4},},{{880,51,2,879,2},{16,4,21,4,211},},{{7,18,21,4,19},{1,45,16,2,193},},
{{7,13,25,878,53,4},{3,49,17,2,329},},{{21,27,16,21,233},},{{21,29,21,5,211},{4,11,18,16,203},},{0},{0},{{858,71,23,856,347},
{856,75,25,878,188,856},{3,50,23,1,316},},{{1,49,25,878,188,1},},{{2,55,17,2,236},},{{1,43,25,878,188,1},},{{858,69,25,878,354,856},
{6,9,17,16,291},},{{55,21,23,5,316},{4,4,25,878,188,4},},{0},{{866,4,21,4,86},{5,27,17,21,198},},{{21,34,25,878,230,5},},
{{865,21,21,5,86},{5,33,21,892,165},},{{868,77,21,856,86},{857,77,24,871,227,856},{3,36,23,1,316},},{{862,52,21,1,86},
{3,39,23,1,316},},{{16,9,23,4,223},{7,10,23,4,40},},{{6,3,24,871,276,4},},{{16,17,21,887,215},{6,1,23,863,301},},
{{1,55,17,2,198},},{{21,22,21,5,211},{3,52,25,878,323,1},},{{21,24,16,21,233},{4,12,21,4,159},},{{887,14,1,876,0},},
{{857,75,17,857,236},},{{11,16,17,16,291},{3,48,25,878,323,1},},{0},{{863,11,20,7,0},{2,44,18,2,239},},{{7,12,24,871,47,4},},
{{859,91,18,859,239},},{{858,62,25,878,354,856},{11,3,25,878,281,4},},{{2,50,24,871,227,1},},{{859,89,17,859,236},{858,75,18,857,363},
{5,23,17,21,198},},{{876,4,10,866,0},{16,3,21,4,211},{1,42,17,2,198},},{{21,32,16,21,233},{1,57,21,1,159},},
{{855,4,23,4,316},{6,10,24,871,276,4},},{{16,5,18,16,239},{7,6,18,16,71},},{{3,40,21,1,304},},{{12,60,25,878,188,12},},
{{6,6,24,871,276,4},},{{857,62,24,871,227,856},{2,52,17,2,236},},{{3,38,23,1,316},},{{856,69,16,857,193},{11,9,23,4,270},},
{{858,75,25,878,354,856},{21,32,25,878,230,5},},{{857,67,21,856,211},},{{883,91,10,867,0},{857,66,21,856,211},},{{7,11,21,4,19},
{6,5,18,16,296},},{{55,25,18,21,332},{4,13,21,4,159},},{{859,79,23,12,223},{2,41,24,871,227,1},},{{882,63,11,868,0},
{7,9,24,871,47,4},},{{860,81,24,871,351,12},{1,35,23,1,177},},{{860,83,23,12,347},{856,69,21,856,159},{856,63,23,856,177},},
{{860,83,24,871,351,12},{2,45,24,871,227,1},},{{1,50,21,1,159},},{{21,25,21,5,211},},{{858,63,17,857,360},{21,27,18,21,239},
{4,9,25,878,188,4},},{{858,65,16,857,357},{6,13,24,871,276,4},},{0},{{3,47,25,878,323,1},},{{861,32,1,55,0},{858,71,21,856,335},},
{{855,7,23,4,316},{6,11,18,16,296},},{{12,79,25,878,188,12},{2,55,23,1,223},},{{5,23,19,21,208},},{0},{{6,7,18,16,296},
{3,57,25,878,323,1},},{0},{{860,78,23,12,347},{5,27,19,21,208},},{{870,47,1,3,0},{860,79,23,12,347},},{{863,16,20,7,0},
{12,84,19,859,208},{2,38,23,1,223},},{{857,77,18,857,239},{2,36,24,871,227,1},},{{5,29,25,878,188,5},{3,39,21,1,304},},
{{860,84,24,871,351,12},{7,10,21,4,19},},{{3,49,25,878,323,1},},{{859,78,23,12,223},{858,65,17,857,360},},{{870,42,1,3,0},
{1,55,19,2,208},},{{21,22,23,5,223},{3,35,24,871,320,1},},{{865,19,21,5,86},{11,18,18,16,296},{6,16,25,878,281,4},},
{{12,91,25,878,188,12},},{{871,91,13,860,0},},{{862,47,21,1,86},{11,5,18,16,296},},{{21,26,24,871,227,5},},{{860,89,23,12,347},},
{{16,16,25,878,230,4},},{{859,91,16,859,233},},{{858,64,25,878,354,856},{4,10,21,4,159},},{{859,85,24,871,227,12},},{{857,65,25,878,230,856},
{2,35,24,871,227,1},},{{16,3,23,4,223},{1,42,19,2,208},},{{55,25,21,5,304},{1,57,19,2,208},},{{863,13,20,7,0},
{12,78,16,859,193},{7,13,16,16,59},},{{16,5,16,16,233},{7,6,16,16,59},},{{859,86,25,878,230,12},{3,40,23,1,316},},
{{860,89,18,859,363},{11,13,17,16,291},},{{55,28,21,5,304},{4,7,25,878,188,4},},};

static const struct action_table_entry *action_table_lookup(uint32_t nfa_state, uint32_t dfa_state, uint32_t token) {
    uint32_t index1 = ((((((0xe5aa55e5 ^ (nfa_state)) * 0xe5aa55e5) ^ (dfa_state)) * 0xe5aa55e5) ^ (token)) * 0xe5aa55e5) & 1023;
    uint32_t index2 = ((((((0xf2579761 ^ (nfa_state)) * 0xf2579761) ^ (dfa_state)) * 0xf2579761) ^ (token)) * 0xf2579761) & 1023;
    uint32_t j = 0;
    const struct action_table_entry *entry = 0;
    for (; j < 3; ++j) {
        entry = &action_table[index1][j];
        if (entry->target_nfa_state == nfa_state && entry->dfa_state == dfa_state && entry->dfa_symbol == token)
            break;
        entry = &action_table[index2][j];
        if (entry->target_nfa_state == nfa_state && entry->dfa_state == dfa_state && entry->dfa_symbol == token)
            break;
    }
    if (j >= 3)
        return 0;
    return entry;
}
static void apply_actions(struct construct_state *state, uint32_t index, size_t start, size_t end) {
    size_t offset = end;
    for (uint32_t i = index; actions[i]; ++i) {
        if (((((actions[i]) >> 12) & 0xf) & 8))
            offset = start;
        construct_action_apply(state, actions[i], offset);
    }
}
static size_t build_parse_tree(struct owl_default_tokenizer *tokenizer, struct owl_token_run *run, struct owl_tree *tree) {
    struct construct_state construct_state = { .info = tree };
    uint32_t *state_stack = 0;
    uint32_t stack_depth = 0;
    size_t stack_capacity = 0;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset - whitespace;
    construct_begin(&construct_state, offset, CONSTRUCT_NORMAL_ROOT);
    uint32_t nfa_state = 11;
    while (run) {
        uint16_t length_offset = run->lengths_size - 1;
        uint16_t n = run->number_of_tokens;
        for (uint16_t i = n - 1; i < n; i--) {
            size_t end = offset;
            size_t len = 0;
            const struct action_table_entry *entry = action_table_lookup(nfa_state, run->states[i], run->tokens[i]);
            if (!entry)
                abort();
            if (entry->dfa_symbol < 24)
                len = decode_token_length(run, &length_offset, &offset);
            else {
                if (stack_depth >= stack_capacity) {
                    size_t new_capacity = (stack_capacity + 2) * 3 / 2;
                    if (new_capacity <= stack_capacity)
                        abort();
                    uint32_t *new_stack = realloc(state_stack, new_capacity * sizeof(uint32_t));
                    if (!new_stack)
                        abort();
                    state_stack = new_stack;
                    stack_capacity = new_capacity;
                }
                state_stack[stack_depth++] = entry->push_nfa_state;
            }
            apply_actions(&construct_state, entry->actions, end, end + whitespace);
            if (entry->dfa_state == 59) {
                if (stack_depth == 0)
                    abort();
                nfa_state = state_stack[--stack_depth];
            } else
                nfa_state = entry->nfa_state;
            whitespace = end - offset - len;
        }
        struct owl_token_run *old = run;
        run = run->prev;
        free(old);
    }
    const struct action_table_entry *entry = action_table_lookup(nfa_state, UINT32_MAX, UINT32_MAX);
    if (!entry)
        abort();
    apply_actions(&construct_state, entry->actions, offset, offset + whitespace);
    free(state_stack);
    return construct_finish(&construct_state, offset);
}
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info) {
    switch (text[0]) {
    case 35:
        *end_token = false;
        *token = 4294967295U;
        return 1;
    case 40:
        *end_token = false;
        *token = 12;
        return 1;
    case 41:
        *end_token = true;
        *token = 13;
        return 1;
    case 42:
        *end_token = false;
        *token = 16;
        return 1;
    case 43:
        *end_token = false;
        *token = 17;
        return 1;
    case 46:
        if (text[1] == 111 && text[2] == 112 && text[3] == 101 && text[4] == 114 && text[5] == 97 && text[6] == 116 && text[7] == 111 && text[8] == 114 && text[9] == 115) {
            *end_token = false;
            *token = 2;
            return 10;
        } else {
            return 0;
        }
    case 58:
        *end_token = false;
        *token = 1;
        return 1;
    case 61:
        *end_token = false;
        *token = 0;
        return 1;
    case 63:
        *end_token = false;
        *token = 18;
        return 1;
    case 64:
        *end_token = false;
        *token = 11;
        return 1;
    case 91:
        *end_token = false;
        *token = 14;
        return 1;
    case 92:
        *end_token = false;
        *token = 10;
        return 1;
    case 93:
        *end_token = true;
        *token = 15;
        return 1;
    case 102:
        if (text[1] == 108 && text[2] == 97 && text[3] == 116) {
            *end_token = false;
            *token = 6;
            return 4;
        } else {
            return 0;
        }
    case 105:
        if (text[1] == 110 && text[2] == 102 && text[3] == 105 && text[4] == 120) {
            *end_token = false;
            *token = 5;
            return 5;
        } else {
            return 0;
        }
    case 108:
        switch (text[1]) {
        case 101:
            if (text[2] == 102 && text[3] == 116) {
                *end_token = false;
                *token = 7;
                return 4;
            } else {
                return 0;
            }
        case 105:
            if (text[2] == 110 && text[3] == 101 && text[4] == 45 && text[5] == 99 && text[6] == 111 && text[7] == 109 && text[8] == 109 && text[9] == 101 && text[10] == 110 && text[11] == 116 && text[12] == 45 && text[13] == 116 && text[14] == 111 && text[15] == 107 && text[16] == 101 && text[17] == 110) {
                *end_token = false;
                *token = 20;
                return 18;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 110:
        if (text[1] == 111 && text[2] == 110 && text[3] == 97 && text[4] == 115 && text[5] == 115 && text[6] == 111 && text[7] == 99) {
            *end_token = false;
            *token = 9;
            return 8;
        } else {
            return 0;
        }
    case 112:
        switch (text[1]) {
        case 111:
            if (text[2] == 115 && text[3] == 116 && text[4] == 102 && text[5] == 105 && text[6] == 120) {
                *end_token = false;
                *token = 3;
                return 7;
            } else {
                return 0;
            }
        case 114:
            if (text[2] == 101 && text[3] == 102 && text[4] == 105 && text[5] == 120) {
                *end_token = false;
                *token = 4;
                return 6;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 114:
        if (text[1] == 105 && text[2] == 103 && text[3] == 104 && text[4] == 116) {
            *end_token = false;
            *token = 8;
            return 5;
        } else {
            return 0;
        }
    case 124:
        *end_token = false;
        *token = 19;
        return 1;
    default:
        return 0;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context) {
    switch (parent) {
    case 0:
        switch (slot) {
        case 0: return 1;
        case 1: return 8;
        default: break;
        }
        break;
    case 1:
        switch (slot) {
        case 0: return 9;
        case 1: return 2;
        default: break;
        }
        break;
    case 2:
        switch (slot) {
        case 0: return 7;
        case 1: return 9;
        case 2: return 3;
        default: break;
        }
        break;
    case 3:
        switch (slot) {
        case 0: return 4;
        case 1: return 6;
        default: break;
        }
        break;
    case 4:
        switch (slot) {
        case 0: return 5;
        default: break;
        }
        break;
    case 6:
        switch (slot) {
        case 0: return 7;
        case 1: return 9;
        default: break;
        }
        break;
    case 7:
        switch (slot) {
        case 0: return 9;
        case 1: return 9;
        case 2: return 9;
        case 3: return 11;
        case 4: return 7;
        case 5: return 11;
        case 6: return 11;
        case 7: return 7;
        default: break;
        }
        break;
    case 8:
        switch (slot) {
        case 0: return 11;
        default: break;
        }
        break;
    default: break;
    }
    return UINT32_MAX;
}
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context) {
    switch (rule) {
    case 7:
        switch (choice) {
        case 4:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 5:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 6:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 7:
            *precedence = -2;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        case 8:
            *precedence = -3;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        default: return;
        }
    default: return;
    }
}
static size_t number_of_slots_lookup(uint32_t rule, void *context) {
    switch (rule) {
    case 0: return 2;
    case 1: return 2;
    case 2: return 3;
    case 3: return 2;
    case 4: return 1;
    case 5: return 0;
    case 6: return 2;
    case 7: return 8;
    case 8: return 1;
    case 9: return 0;
    case 10: return 0;
    case 11: return 0;
    default: return 0;
    }
}
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context) {
    switch (rule) {
    case 0:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 1:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 2:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 3:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 4:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 5:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 6:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 7:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 7;
        break;
    case 8:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 9:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 10:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 11:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    }
}
#endif

