// -----------------------------------------------------------------------------
// This file was generated by the bluebird parsing tool.
// Make sure to #define BLUEBIRD_PARSER_IMPLEMENTATION somewhere so the parser
// is compiled properly.  Just two lines are enough -- a typical parser.c might
// look like:
//
//   #define BLUEBIRD_PARSER_IMPLEMENTATION
//   #include "bluebird-parser.h"

#ifndef _BLUEBIRD_PARSER_H_
#define _BLUEBIRD_PARSER_H_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

// The bluebird_tree struct represents an entire parse tree.  Use the
// bluebird_tree_create_...() functions to create a tree, then call
// bluebird_tree_root() to get the root bluebird_id.
struct bluebird_tree;

// Creates a bluebird_tree from a string.  The tree may directly reference
// pieces of the string -- you're responsible for keeping it around until
// bluebird_tree_destroy() is called.
struct bluebird_tree *bluebird_tree_create_from_string(const char *string);

// Creates a bluebird_tree by reading from a file.
struct bluebird_tree *bluebird_tree_create_from_file(FILE *file);

// Destroys a bluebird_tree, freeing its resources back to the system.
void bluebird_tree_destroy(struct bluebird_tree *);

// Prints a representation of the tree to standard output.
void bluebird_tree_print(struct bluebird_tree *);

// A bluebird_node represents an node in the parse tree.  Use the
// parsed_..._get() function corresponding to the element type to unpack the
// node into its appropriate type of parsed_... element struct.
struct bluebird_node {
    struct bluebird_tree *_tree;
    size_t _offset;
    uint32_t _type;
    bool empty;
};

// The bluebird_next function returns the next sibling node.
struct bluebird_node bluebird_next(struct bluebird_node);

// Tests two nodes for equality.
bool bluebird_nodes_equal(struct bluebird_node a, struct bluebird_node b);

// Returns the root bluebird_node.
struct bluebird_node bluebird_tree_root_node(struct bluebird_tree *tree);

// As a shortcut, returns the parsed_grammar struct corresponding to the root node.
struct parsed_grammar bluebird_tree_get_parsed_grammar(struct bluebird_tree *tree);

// The range of text corresponding to a tree element.
struct source_range {
    size_t start;
    size_t end;
};

enum bluebird_error {
    // No error -- everything's fine!
    ERROR_NONE,

    // The file passed to bluebird_tree_create_from_file wasn't valid because
    // - it was NULL,
    // - it doesn't support fseek/ftell, or
    // - there was an error while reading it.
    ERROR_INVALID_FILE,

    // A piece of text couldn't be matched as a token.
    ERROR_INVALID_TOKEN,

    // The parser encountered an out-of-place token that doesn't fit the grammar.
    ERROR_UNEXPECTED_TOKEN,

    // The input is valid so far, but incomplete; more tokens could be added to
    // complete it.
    ERROR_MORE_INPUT_NEEDED,
};
// Returns an error code, or ERROR_NONE if there wasn't an error.
// The error_range parameter can be null.
enum bluebird_error bluebird_tree_get_error(struct bluebird_tree *tree, struct source_range *error_range);

enum parsed_type {
    PARSED_IDENT = 1,
    PARSED_CHOICE,
    PARSED_PARENS,
    PARSED_FLAT_OP,
    PARSED_LEFT_OP,
    PARSED_LITERAL,
    PARSED_INFIX_OP,
    PARSED_OPTIONAL,
    PARSED_RIGHT_OP,
    PARSED_BRACKETED,
    PARSED_PREFIX_OP,
    PARSED_POSTFIX_OP,
    PARSED_NONASSOC_OP,
    PARSED_ONE_OR_MORE,
    PARSED_ZERO_OR_MORE,
    PARSED_CONCATENATION,
};

struct parsed_grammar {
    struct source_range range;
    struct bluebird_node rule;
    struct bluebird_node comment_token;
};

struct parsed_rule {
    struct source_range range;
    struct bluebird_node identifier;
    struct bluebird_node body;
};

struct parsed_body {
    struct source_range range;
    struct bluebird_node expr;
    struct bluebird_node identifier;
    struct bluebird_node operators;
};

struct parsed_operators {
    struct source_range range;
    struct bluebird_node fixity;
    struct bluebird_node operator;
};

struct parsed_fixity {
    struct source_range range;
    enum parsed_type type;
    struct bluebird_node assoc;
};

struct parsed_assoc {
    struct source_range range;
    enum parsed_type type;
};

struct parsed_operator {
    struct source_range range;
    struct bluebird_node expr;
    struct bluebird_node identifier;
};

struct parsed_expr {
    struct source_range range;
    enum parsed_type type;
    struct bluebird_node identifier;
    struct bluebird_node exception;
    struct bluebird_node rename;
    struct bluebird_node string;
    struct bluebird_node expr;
    struct bluebird_node begin_token;
    struct bluebird_node end_token;
    struct bluebird_node operand;
};

struct parsed_comment_token {
    struct source_range range;
    struct bluebird_node string;
};

struct parsed_identifier {
    struct source_range range;
    const char *identifier;
    size_t length;
};

struct parsed_number {
    struct source_range range;
    double number;
};

struct parsed_string {
    struct source_range range;
    const char *string;
    size_t length;
    bool has_escapes;
};

struct parsed_grammar parsed_grammar_get(struct bluebird_node);
struct parsed_rule parsed_rule_get(struct bluebird_node);
struct parsed_body parsed_body_get(struct bluebird_node);
struct parsed_operators parsed_operators_get(struct bluebird_node);
struct parsed_fixity parsed_fixity_get(struct bluebird_node);
struct parsed_assoc parsed_assoc_get(struct bluebird_node);
struct parsed_operator parsed_operator_get(struct bluebird_node);
struct parsed_expr parsed_expr_get(struct bluebird_node);
struct parsed_comment_token parsed_comment_token_get(struct bluebird_node);
struct parsed_identifier parsed_identifier_get(struct bluebird_node);
struct parsed_number parsed_number_get(struct bluebird_node);
struct parsed_string parsed_string_get(struct bluebird_node);

#endif

#ifdef BLUEBIRD_PARSER_IMPLEMENTATION
// Code implementing the parser.  This might get a bit messy!
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct bluebird_tree {
    const char *string;
    bool owns_string;
    uint8_t *parse_tree;
    size_t parse_tree_size;
    size_t next_offset;
    enum bluebird_error error;
    struct source_range error_range;
    size_t root_offset;
    struct {
        const char *identifier;
        size_t length;
        struct source_range range;
    } *identifier_tokens;
    size_t number_of_identifier_tokens;
    size_t used_identifier_tokens;
    size_t identifier_tokens_capacity;
    struct {
        double number;
        struct source_range range;
    } *number_tokens;
    size_t number_of_number_tokens;
    size_t used_number_tokens;
    size_t number_tokens_capacity;
    struct {
        const char *string;
        size_t length;
        bool has_escapes;
        struct source_range range;
    } *string_tokens;
    size_t number_of_string_tokens;
    size_t used_string_tokens;
    size_t string_tokens_capacity;
};
static void add_identifier_token(struct bluebird_tree *tree, size_t start, size_t end, const char *identifier_param, size_t length_param) {
    size_t index = tree->number_of_identifier_tokens++;
    if (tree->number_of_identifier_tokens > tree->identifier_tokens_capacity) {
        size_t capacity = (tree->identifier_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->identifier_tokens, sizeof(tree->identifier_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->identifier_tokens_capacity = capacity;
        tree->identifier_tokens = tokens;
    }
    tree->identifier_tokens[index].range.start = start;
    tree->identifier_tokens[index].range.end = end;
    tree->identifier_tokens[index].identifier = identifier_param;
    tree->identifier_tokens[index].length = length_param;
}
static void add_number_token(struct bluebird_tree *tree, size_t start, size_t end, double number_param) {
    size_t index = tree->number_of_number_tokens++;
    if (tree->number_of_number_tokens > tree->number_tokens_capacity) {
        size_t capacity = (tree->number_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->number_tokens, sizeof(tree->number_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->number_tokens_capacity = capacity;
        tree->number_tokens = tokens;
    }
    tree->number_tokens[index].range.start = start;
    tree->number_tokens[index].range.end = end;
    tree->number_tokens[index].number = number_param;
}
static void add_string_token(struct bluebird_tree *tree, size_t start, size_t end, const char *string_param, size_t length_param, bool has_escapes_param) {
    size_t index = tree->number_of_string_tokens++;
    if (tree->number_of_string_tokens > tree->string_tokens_capacity) {
        size_t capacity = (tree->string_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->string_tokens, sizeof(tree->string_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->string_tokens_capacity = capacity;
        tree->string_tokens = tokens;
    }
    tree->string_tokens[index].range.start = start;
    tree->string_tokens[index].range.end = end;
    tree->string_tokens[index].string = string_param;
    tree->string_tokens[index].length = length_param;
    tree->string_tokens[index].has_escapes = has_escapes_param;
}
// Reserve 10 bytes for each entry (the maximum encoded size of a 64-bit value).
#define RESERVATION_AMOUNT 10
static inline uint64_t read_tree(size_t *offset, struct bluebird_tree *tree) {
    uint8_t *parse_tree = tree->parse_tree;
    size_t parse_tree_size = tree->parse_tree_size;
    size_t i = *offset;
    if (i + RESERVATION_AMOUNT >= parse_tree_size)
        return 0;
    uint64_t result = 0;
    int shift_amount = 0;
    while ((parse_tree[i] & 0x80) != 0 && shift_amount < 64) {
        result |= (parse_tree[i] & 0x7f) << shift_amount;
        shift_amount += 7;
        i++;
    }
    result |= (parse_tree[i] & 0x7f) << shift_amount;
    i++;
    *offset = i;
    return result;
}
static bool grow_tree(struct bluebird_tree *tree, size_t size)
{
    size_t n = tree->parse_tree_size;
    while (n < size || n < 4096)
        n = (n + 1) * 3 / 2;
    uint8_t *parse_tree = realloc(tree->parse_tree, n);
    if (!parse_tree)
        return false;
    tree->parse_tree_size = n;
    tree->parse_tree = parse_tree;
    return true;
}
static void write_tree(struct bluebird_tree *tree, uint64_t value)
{
    size_t reserved_size = tree->next_offset + RESERVATION_AMOUNT;
    if (tree->parse_tree_size <= reserved_size && !grow_tree(tree, reserved_size))
        abort();
    while (value >> 7 != 0) {
        tree->parse_tree[tree->next_offset++] = 0x80 | (value & 0x7f);
        value >>= 7;
    }
    tree->parse_tree[tree->next_offset++] = value & 0x7f;
}
struct parsed_grammar parsed_grammar_get(struct bluebird_node node) {
    if (node.empty || node._type != 0) {
        return (struct parsed_grammar){
            .rule.empty = true,
            .comment_token.empty = true,
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_grammar result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.rule._tree = node._tree;
    result.rule._offset = read_tree(&offset, node._tree);
    result.rule._type = 1;
    result.rule.empty = result.rule._offset == 0;
    result.comment_token._tree = node._tree;
    result.comment_token._offset = read_tree(&offset, node._tree);
    result.comment_token._type = 8;
    result.comment_token.empty = result.comment_token._offset == 0;
    return result;
}
struct parsed_rule parsed_rule_get(struct bluebird_node node) {
    if (node.empty || node._type != 1) {
        return (struct parsed_rule){
            .identifier.empty = true,
            .body.empty = true,
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_rule result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.identifier._tree = node._tree;
    result.identifier._offset = read_tree(&offset, node._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    result.body._tree = node._tree;
    result.body._offset = read_tree(&offset, node._tree);
    result.body._type = 2;
    result.body.empty = result.body._offset == 0;
    return result;
}
struct parsed_body parsed_body_get(struct bluebird_node node) {
    if (node.empty || node._type != 2) {
        return (struct parsed_body){
            .expr.empty = true,
            .identifier.empty = true,
            .operators.empty = true,
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_body result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.expr._tree = node._tree;
    result.expr._offset = read_tree(&offset, node._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.identifier._tree = node._tree;
    result.identifier._offset = read_tree(&offset, node._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    result.operators._tree = node._tree;
    result.operators._offset = read_tree(&offset, node._tree);
    result.operators._type = 3;
    result.operators.empty = result.operators._offset == 0;
    return result;
}
struct parsed_operators parsed_operators_get(struct bluebird_node node) {
    if (node.empty || node._type != 3) {
        return (struct parsed_operators){
            .fixity.empty = true,
            .operator.empty = true,
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_operators result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.fixity._tree = node._tree;
    result.fixity._offset = read_tree(&offset, node._tree);
    result.fixity._type = 4;
    result.fixity.empty = result.fixity._offset == 0;
    result.operator._tree = node._tree;
    result.operator._offset = read_tree(&offset, node._tree);
    result.operator._type = 6;
    result.operator.empty = result.operator._offset == 0;
    return result;
}
struct parsed_fixity parsed_fixity_get(struct bluebird_node node) {
    if (node.empty || node._type != 4) {
        return (struct parsed_fixity){
            .assoc.empty = true,
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_fixity result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&offset, node._tree),
    };
    result.assoc._tree = node._tree;
    result.assoc._offset = read_tree(&offset, node._tree);
    result.assoc._type = 5;
    result.assoc.empty = result.assoc._offset == 0;
    return result;
}
struct parsed_assoc parsed_assoc_get(struct bluebird_node node) {
    if (node.empty || node._type != 5) {
        return (struct parsed_assoc){
        0
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_assoc result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&offset, node._tree),
    };
    return result;
}
struct parsed_operator parsed_operator_get(struct bluebird_node node) {
    if (node.empty || node._type != 6) {
        return (struct parsed_operator){
            .expr.empty = true,
            .identifier.empty = true,
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_operator result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.expr._tree = node._tree;
    result.expr._offset = read_tree(&offset, node._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.identifier._tree = node._tree;
    result.identifier._offset = read_tree(&offset, node._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    return result;
}
struct parsed_expr parsed_expr_get(struct bluebird_node node) {
    if (node.empty || node._type != 7) {
        return (struct parsed_expr){
            .identifier.empty = true,
            .exception.empty = true,
            .rename.empty = true,
            .string.empty = true,
            .expr.empty = true,
            .begin_token.empty = true,
            .end_token.empty = true,
            .operand.empty = true,
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_expr result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&offset, node._tree),
    };
    result.identifier._tree = node._tree;
    result.identifier._offset = read_tree(&offset, node._tree);
    result.identifier._type = 9;
    result.identifier.empty = result.identifier._offset == 0;
    result.exception._tree = node._tree;
    result.exception._offset = read_tree(&offset, node._tree);
    result.exception._type = 9;
    result.exception.empty = result.exception._offset == 0;
    result.rename._tree = node._tree;
    result.rename._offset = read_tree(&offset, node._tree);
    result.rename._type = 9;
    result.rename.empty = result.rename._offset == 0;
    result.string._tree = node._tree;
    result.string._offset = read_tree(&offset, node._tree);
    result.string._type = 11;
    result.string.empty = result.string._offset == 0;
    result.expr._tree = node._tree;
    result.expr._offset = read_tree(&offset, node._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.begin_token._tree = node._tree;
    result.begin_token._offset = read_tree(&offset, node._tree);
    result.begin_token._type = 11;
    result.begin_token.empty = result.begin_token._offset == 0;
    result.end_token._tree = node._tree;
    result.end_token._offset = read_tree(&offset, node._tree);
    result.end_token._type = 11;
    result.end_token.empty = result.end_token._offset == 0;
    result.operand._tree = node._tree;
    result.operand._offset = read_tree(&offset, node._tree);
    result.operand._type = 7;
    result.operand.empty = result.operand._offset == 0;
    return result;
}
struct parsed_comment_token parsed_comment_token_get(struct bluebird_node node) {
    if (node.empty || node._type != 8) {
        return (struct parsed_comment_token){
            .string.empty = true,
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, node._tree);
    size_t end_location = read_tree(&offset, node._tree);
    struct parsed_comment_token result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.string._tree = node._tree;
    result.string._offset = read_tree(&offset, node._tree);
    result.string._type = 11;
    result.string.empty = result.string._offset == 0;
    return result;
}
struct parsed_identifier parsed_identifier_get(struct bluebird_node node) {
    if (node.empty || node._type != 9) {
        return (struct parsed_identifier){
        0
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t token_index = read_tree(&offset, node._tree);
    struct parsed_identifier result = {
        .identifier = node._tree->identifier_tokens[token_index].identifier,
        .length = node._tree->identifier_tokens[token_index].length,
        .range = node._tree->identifier_tokens[token_index].range,
    };
    return result;
}
struct parsed_number parsed_number_get(struct bluebird_node node) {
    if (node.empty || node._type != 10) {
        return (struct parsed_number){
        0
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t token_index = read_tree(&offset, node._tree);
    struct parsed_number result = {
        .number = node._tree->number_tokens[token_index].number,
        .range = node._tree->number_tokens[token_index].range,
    };
    return result;
}
struct parsed_string parsed_string_get(struct bluebird_node node) {
    if (node.empty || node._type != 11) {
        return (struct parsed_string){
        0
        };
    }
    size_t offset = node._offset;
    read_tree(&offset, node._tree); // Read and ignore the 'next offset' field.
    size_t token_index = read_tree(&offset, node._tree);
    struct parsed_string result = {
        .string = node._tree->string_tokens[token_index].string,
        .length = node._tree->string_tokens[token_index].length,
        .has_escapes = node._tree->string_tokens[token_index].has_escapes,
        .range = node._tree->string_tokens[token_index].range,
    };
    return result;
}
static size_t finish_node(uint32_t rule, uint32_t choice, size_t next_sibling, size_t *slots, size_t start_location, size_t end_location, void *info) {
    struct bluebird_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling);
    write_tree(tree, start_location);
    write_tree(tree, end_location);
    switch (rule) {
    case 0: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 1: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 2: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        break;
    }
    case 3: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 4: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_POSTFIX_OP);
            break;
        case 1:
            write_tree(tree, PARSED_PREFIX_OP);
            break;
        case 2:
            write_tree(tree, PARSED_INFIX_OP);
            break;
        }
        write_tree(tree, slots[0]);
        break;
    }
    case 5: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_FLAT_OP);
            break;
        case 1:
            write_tree(tree, PARSED_LEFT_OP);
            break;
        case 2:
            write_tree(tree, PARSED_RIGHT_OP);
            break;
        case 3:
            write_tree(tree, PARSED_NONASSOC_OP);
            break;
        }
        break;
    }
    case 6: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 7: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_IDENT);
            break;
        case 1:
            write_tree(tree, PARSED_LITERAL);
            break;
        case 2:
            write_tree(tree, PARSED_PARENS);
            break;
        case 3:
            write_tree(tree, PARSED_BRACKETED);
            break;
        case 4:
            write_tree(tree, PARSED_ZERO_OR_MORE);
            break;
        case 5:
            write_tree(tree, PARSED_ONE_OR_MORE);
            break;
        case 6:
            write_tree(tree, PARSED_OPTIONAL);
            break;
        case 7:
            write_tree(tree, PARSED_CONCATENATION);
            break;
        case 8:
            write_tree(tree, PARSED_CHOICE);
            break;
        }
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        write_tree(tree, slots[3]);
        write_tree(tree, slots[4]);
        write_tree(tree, slots[5]);
        write_tree(tree, slots[6]);
        write_tree(tree, slots[7]);
        break;
    }
    case 8: {
        write_tree(tree, slots[0]);
        break;
    }
    default:
        break;
    }
    return offset;
}
static size_t finish_token(uint32_t rule, size_t next_sibling, void *info) {
    struct bluebird_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling);
    switch (rule) {
    case 9: {
        tree->used_identifier_tokens++;
        if (tree->used_identifier_tokens > tree->number_of_identifier_tokens)
            abort();
        size_t token_index = tree->number_of_identifier_tokens - tree->used_identifier_tokens;
        write_tree(tree, token_index);
        break;
    }
    case 10: {
        tree->used_number_tokens++;
        if (tree->used_number_tokens > tree->number_of_number_tokens)
            abort();
        size_t token_index = tree->number_of_number_tokens - tree->used_number_tokens;
        write_tree(tree, token_index);
        break;
    }
    case 11: {
        tree->used_string_tokens++;
        if (tree->used_string_tokens > tree->number_of_string_tokens)
            abort();
        size_t token_index = tree->number_of_string_tokens - tree->used_string_tokens;
        write_tree(tree, token_index);
        break;
    }
    default:
        break;
    }
    return offset;
}
static void check_for_error(struct bluebird_tree *tree) {
    if (tree->error == ERROR_NONE)
        return;
    fprintf(stderr, "parse error: ");
    switch (tree->error) {
    case ERROR_INVALID_FILE:
        fprintf(stderr, "invalid file\n");
        break;
    case ERROR_INVALID_TOKEN:
        fprintf(stderr, "invalid token\n");
        break;
    case ERROR_UNEXPECTED_TOKEN:
        fprintf(stderr, "unexpected token\n");
        break;
    case ERROR_MORE_INPUT_NEEDED:
        fprintf(stderr, "more input needed\n");
        break;
    default:
        break;
    }
    exit(-1);
}
static void parsed_grammar_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_rule_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_body_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_operators_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_fixity_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_assoc_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_operator_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_expr_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_comment_token_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_identifier_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_number_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_string_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent);
static void parsed_grammar_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_grammar it = parsed_grammar_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("grammar");
        if (strcmp("grammar", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_rule_print(tree, it.rule, "rule", indent + 1);
        parsed_comment_token_print(tree, it.comment_token, "comment_token", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_rule_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_rule it = parsed_rule_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("rule");
        if (strcmp("rule", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_body_print(tree, it.body, "body", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_body_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_body it = parsed_body_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("body");
        if (strcmp("body", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_operators_print(tree, it.operators, "operators", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_operators_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_operators it = parsed_operators_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operators");
        if (strcmp("operators", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_fixity_print(tree, it.fixity, "fixity", indent + 1);
        parsed_operator_print(tree, it.operator, "operator", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_fixity_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_fixity it = parsed_fixity_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("fixity");
        if (strcmp("fixity", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_POSTFIX_OP:
            printf(" : POSTFIX_OP");
            break;
        case PARSED_PREFIX_OP:
            printf(" : PREFIX_OP");
            break;
        case PARSED_INFIX_OP:
            printf(" : INFIX_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_assoc_print(tree, it.assoc, "assoc", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_assoc_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_assoc it = parsed_assoc_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("assoc");
        if (strcmp("assoc", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_FLAT_OP:
            printf(" : FLAT_OP");
            break;
        case PARSED_LEFT_OP:
            printf(" : LEFT_OP");
            break;
        case PARSED_RIGHT_OP:
            printf(" : RIGHT_OP");
            break;
        case PARSED_NONASSOC_OP:
            printf(" : NONASSOC_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        node = bluebird_next(node);
    }
}
static void parsed_operator_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_operator it = parsed_operator_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operator");
        if (strcmp("operator", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_expr_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_expr it = parsed_expr_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("expr");
        if (strcmp("expr", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_IDENT:
            printf(" : IDENT");
            break;
        case PARSED_LITERAL:
            printf(" : LITERAL");
            break;
        case PARSED_PARENS:
            printf(" : PARENS");
            break;
        case PARSED_BRACKETED:
            printf(" : BRACKETED");
            break;
        case PARSED_ZERO_OR_MORE:
            printf(" : ZERO_OR_MORE");
            break;
        case PARSED_ONE_OR_MORE:
            printf(" : ONE_OR_MORE");
            break;
        case PARSED_OPTIONAL:
            printf(" : OPTIONAL");
            break;
        case PARSED_CONCATENATION:
            printf(" : CONCATENATION");
            break;
        case PARSED_CHOICE:
            printf(" : CHOICE");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_identifier_print(tree, it.exception, "exception", indent + 1);
        parsed_identifier_print(tree, it.rename, "rename", indent + 1);
        parsed_string_print(tree, it.string, "string", indent + 1);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_string_print(tree, it.begin_token, "begin_token", indent + 1);
        parsed_string_print(tree, it.end_token, "end_token", indent + 1);
        parsed_expr_print(tree, it.operand, "operand", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_comment_token_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_comment_token it = parsed_comment_token_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("comment_token");
        if (strcmp("comment_token", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_string_print(tree, it.string, "string", indent + 1);
        node = bluebird_next(node);
    }
}
static void parsed_identifier_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_identifier it = parsed_identifier_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("identifier");
        if (strcmp("identifier", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.identifier);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        node = bluebird_next(node);
    }
}
static void parsed_number_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_number it = parsed_number_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("number");
        if (strcmp("number", slot_name))
            printf("@%s", slot_name);
        printf(" - %f", it.number);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        node = bluebird_next(node);
    }
}
static void parsed_string_print(struct bluebird_tree *tree, struct bluebird_node node, const char *slot_name, int indent) {
    while (!node.empty) {
        struct parsed_string it = parsed_string_get(node);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("string");
        if (strcmp("string", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.string);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        node = bluebird_next(node);
    }
}
void bluebird_tree_print(struct bluebird_tree *tree) {
    check_for_error(tree);
    parsed_grammar_print(tree, bluebird_tree_root_node(tree), "grammar", 0);
}
struct bluebird_node bluebird_next(struct bluebird_node node) {
    size_t offset = read_tree(&node._offset, node._tree);
    return (struct bluebird_node){
        ._tree = node._tree,
        ._offset = offset,
        ._type = node._type,
        .empty = offset == 0,
    };
}
bool bluebird_nodes_equal(struct bluebird_node a, struct bluebird_node b) {
    return a._tree == b._tree && a._offset == b._offset;
}
struct bluebird_node bluebird_tree_root_node(struct bluebird_tree *tree) {
    check_for_error(tree);
    return (struct bluebird_node){
        ._tree = tree,
        ._offset = tree->root_offset,
        ._type = 0,
        .empty = tree->root_offset == 0,
    };
}
struct parsed_grammar bluebird_tree_get_parsed_grammar(struct bluebird_tree *tree) {
    check_for_error(tree);
    return parsed_grammar_get(bluebird_tree_root_node(tree));
}
#define IGNORE_TOKEN_WRITE(...)
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info);
static void write_identifier_token(size_t offset, size_t length, void *info) {
    struct bluebird_tree *tree = info;
    add_identifier_token(tree, offset, offset + length, tree->string + offset, length);
}
static void write_number_token(size_t offset, size_t length, double number, void *info) {
    struct bluebird_tree *tree = info;
    add_number_token(tree, offset, offset + length, number);
}
static void write_string_token(size_t offset, size_t length, const char *string, size_t string_length, bool has_escapes, void *info) {
    struct bluebird_tree *tree = info;
    add_string_token(tree, offset, offset + length, string, string_length, has_escapes);
}
struct bluebird_token_run {
    struct bluebird_token_run *prev;
    uint16_t number_of_tokens;
    uint16_t lengths_size;
    uint8_t lengths[4096 * 2];
    uint32_t tokens[4096];
    uint32_t states[4096];
};
struct bluebird_default_tokenizer {
    const char *text;
    size_t offset;
    size_t whitespace;
    uint32_t identifier_token;
    uint32_t number_token;
    uint32_t string_token;
    void *info;
};
static bool char_is_whitespace(char c) {
    switch (c) {
    case ' ':
    case '\t':
    case '\r':
    case '\n':
        return true;
    default:
        return false;
    }
}
static bool char_is_numeric(char c) {
    return c >= '0' && c <= '9';
}
static bool char_is_alphabetic(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}
static bool char_starts_identifier(char c) {
    return char_is_alphabetic(c) || c == '_';
}
static bool char_continues_identifier(char c, void *info) {
    if (true && c == '-') return true;
    return char_is_numeric(c) || char_starts_identifier(c);
}
static bool encode_length(struct bluebird_token_run *run, uint16_t *lengths_size, size_t length) {
    uint8_t mark = 0;
    while (*lengths_size < sizeof(run->lengths)) {
        run->lengths[*lengths_size] = mark | (length & 0x7f);
        mark = 0x80;
        length >>= 7;
        (*lengths_size)++;
        if (length == 0) return true;
    }
    return false;
}
static bool encode_token_length(struct bluebird_token_run *run, uint16_t *lengths_size, size_t length, size_t whitespace) {
    uint16_t size = *lengths_size;
    if (encode_length(run, lengths_size, length) && encode_length(run, lengths_size, whitespace)) return true;
    *lengths_size = size;
    return false;
}
static size_t decode_length(struct bluebird_token_run *run, uint16_t *length_offset) {
    size_t length = 0;
    while (*length_offset < sizeof(run->lengths)) {
        size_t l = run->lengths[(*length_offset)--];
        length <<= 7;
        length += l & 0x7f;
        if (!(l & 0x80)) return length;
    }
    abort();
}
static size_t decode_token_length(struct bluebird_token_run *run, uint16_t *length_offset, size_t *string_offset) {
    size_t whitespace = decode_length(run, length_offset);
    size_t length = decode_length(run, length_offset);
    *string_offset -= whitespace + length;
    return length;
}
static bool bluebird_default_tokenizer_advance(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run **previous_run) {
    struct bluebird_token_run *run = malloc(sizeof(struct bluebird_token_run));
    if (!run) return false;
    uint16_t number_of_tokens = 0;
    uint16_t lengths_size = 0;
    const char *text = tokenizer->text;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset;
    while (number_of_tokens < 4096) {
        char c = text[offset];
        if (c == '\0') break;
        if (char_is_whitespace(c)) {
            whitespace++;
            offset++;
            continue;
        }
        uint32_t token;
        bool is_token = false;
        bool end_token = false;
        bool comment = false;
        bool has_escapes = false;
        size_t token_length = read_keyword_token(&token, &end_token, text + offset, tokenizer->info);
        if (token_length > 0) {
            is_token = true;
            if (token == 0xffffffff) comment = true;
        }
        double number = 0;
        if (char_is_numeric(c) || (c == '.' && char_is_numeric(text[offset + 1]))) {
            const char *start = (const char *)text + offset;
            char *rest = 0;
            number = strtod(start, &rest);
            if (rest > start && rest - start > token_length) {
                token_length = rest - start;
                is_token = true;
                end_token = false;
                comment = false;
                token = 22;
            }
        }
        else if (c == '\'' || c == '"') {
            size_t string_offset = offset + 1;
            while (text[string_offset] != '\0') {
                if (text[string_offset] == c) {
                    token_length = string_offset + 1 - offset;
                    is_token = true;
                    end_token = false;
                    comment = false;
                    token = 23;
                    break;
                }
                if (text[string_offset] == '\\') {
                    has_escapes = true;
                    string_offset++;
                    if (text[string_offset] == '\0') break;
                }
                string_offset++;
            }
        }
        else if (char_starts_identifier(c)) {
            size_t identifier_offset = offset + 1;
            while (char_continues_identifier(text[identifier_offset], tokenizer->info)) identifier_offset++;
            if (identifier_offset - offset > token_length) {
                token_length = identifier_offset - offset;
                is_token = true;
                end_token = false;
                comment = false;
                token = 21;
            }
        }
        if (comment) {
            while (text[offset] != '\0' && text[offset] != '\n') {
                whitespace++;
                offset++;
            }
            continue;
        }
        else if (!is_token || token == 0xffffffff) {
            tokenizer->offset = offset;
            tokenizer->whitespace = whitespace;
            free(run);
            return false;
        }
        if (end_token && number_of_tokens + 1 >= 4096) break;
        if (!encode_token_length(run, &lengths_size, token_length, whitespace)) break;
        if (token == 21) {
            write_identifier_token(offset, token_length, tokenizer->info);
        }
        else if (token == 22) {
            write_number_token(offset, token_length, number, tokenizer->info);
        }
        else if (token == 23) {
            size_t content_offset = offset + 1;
            size_t content_length = token_length - 2;
            const char *string = text + content_offset;
            size_t string_length = content_length;
            if (has_escapes) {
                for (size_t i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') {
                        string_length--;
                        i++;
                    }
                }
                char *unescaped = malloc(string_length);
                size_t j = 0;
                for (size_t i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') i++;
                    unescaped[j++] = text[content_offset + i];
                }
                string = unescaped;
            }
            write_string_token(offset, token_length, string, string_length, has_escapes, tokenizer->info);
        }
        run->tokens[number_of_tokens] = token;
        whitespace = 0;
        number_of_tokens++;
        offset += token_length;
        if (end_token) {
            assert(number_of_tokens < 4096);
            run->tokens[number_of_tokens] = 4294967295U;
            number_of_tokens++;
        }
    }
    if (number_of_tokens == 0) {
        tokenizer->offset = offset;
        tokenizer->whitespace = whitespace;
        free(run);
        return false;
    }
    tokenizer->offset = offset;
    tokenizer->whitespace = whitespace;
    run->prev = *previous_run;
    run->number_of_tokens = number_of_tokens;
    run->lengths_size = lengths_size;
    *previous_run = run;
    return true;
}
static void find_token_range(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run *run, uint16_t index, size_t *start, size_t *end) {
    size_t offset = tokenizer->offset - tokenizer->whitespace;
    size_t last_offset = offset;
    size_t len = 0;
    uint16_t length_offset = run->lengths_size - 1;
    for (uint16_t j = index;
    j < run->number_of_tokens;
    ++j) {
        if (run->tokens[j] == 4294967295U) continue;
        last_offset = offset;
        len = decode_token_length(run, &length_offset, &offset);
    }
    *start = last_offset - len;
    *end = last_offset;
}
static void estimate_next_token_range(struct bluebird_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset;
    size_t i = tokenizer->offset + 1;
    while (tokenizer->text[i] != '\0' && !char_is_whitespace(tokenizer->text[i]) && !char_continues_identifier(tokenizer->text[i], tokenizer->info)) i++;
    *end = i;
}
static void find_end_range(struct bluebird_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset - tokenizer->whitespace - 1;
    *end = tokenizer->offset - tokenizer->whitespace;
    if (*start > *end) {
        *start = *end;
        *end += 1;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context);
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context);
static size_t number_of_slots_lookup(uint32_t rule, void *context);
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context);
enum construct_fixity_associativity {
CONSTRUCT_PREFIX, CONSTRUCT_POSTFIX, CONSTRUCT_INFIX_LEFT, CONSTRUCT_INFIX_RIGHT, CONSTRUCT_INFIX_FLAT, };
struct construct_node {
    struct construct_node *next;
    size_t number_of_slots;
    size_t *slots;
    uint32_t rule;
    uint16_t slot_index;
    uint16_t choice_index;
    enum construct_fixity_associativity fixity_associativity;
    int precedence;
    size_t start_location;
    size_t end_location;
};
struct construct_expression {
    struct construct_expression *parent;
    struct construct_node *first_operator;
    struct construct_node *first_value;
    uint32_t operand_slot_index;
    uint32_t left_slot_index;
    uint32_t right_slot_index;
    uint32_t rule;
    uint16_t slot_index;
};
enum construct_root_type {
CONSTRUCT_NORMAL_ROOT, CONSTRUCT_EXPRESSION_ROOT, };
struct construct_state {
    enum construct_root_type root_type;
    struct construct_node *under_construction;
    struct construct_expression *current_expression;
    struct construct_node *node_freelist;
    struct construct_expression *expression_freelist;
    void *info;
};
static struct construct_node *construct_node_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_node *node;
    size_t number_of_slots = number_of_slots_lookup(rule, s->info);
    if (s->node_freelist) {
        node = s->node_freelist;
        s->node_freelist = node->next;
        size_t *slots = node->slots;
        if (number_of_slots > node->number_of_slots) {
            slots = realloc(slots, number_of_slots * sizeof(size_t));
            if (!slots) abort();
        }
        memset(node, 0, sizeof(struct construct_node));
        memset(slots, 0, number_of_slots * sizeof(size_t));
        node->slots = slots;
    }
    else {
        node = calloc(1, sizeof(struct construct_node));
        if (!node) abort();
        node->slots = calloc(number_of_slots, sizeof(size_t));
        if (!node->slots) abort();
    }
    node->rule = rule;
    node->number_of_slots = number_of_slots;
    return node;
}
static struct construct_expression *construct_expression_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_expression *expr;
    if (s->expression_freelist) {
        expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        memset(expr, 0, sizeof(struct construct_expression));
    }
    else {
        expr = calloc(1, sizeof(struct construct_expression));
        if (!expr) abort();
    }
    (left_right_operand_slots_lookup(rule, &(expr->left_slot_index), &(expr->right_slot_index), &(expr->operand_slot_index), s->info));
    expr->rule = rule;
    return expr;
}
static void construct_node_free(struct construct_state *state, struct construct_node *node) {
    node->next = state->node_freelist;
    state->node_freelist = node;
}
static void construct_expression_free(struct construct_state *state, struct construct_expression *expr) {
    expr->parent = state->expression_freelist;
    state->expression_freelist = expr;
}
static bool construct_expression_should_reduce(struct construct_state *s, struct construct_expression *expr, struct construct_node *node) {
    if (node->fixity_associativity == CONSTRUCT_POSTFIX) return false;
    struct construct_node *top = expr->first_operator;
    if (!top) return false;
    return node->precedence < top->precedence || (node->precedence == top->precedence && node->fixity_associativity == CONSTRUCT_INFIX_RIGHT);
}
static void construct_expression_reduce(struct construct_state *s, struct construct_expression *expr) {
    struct construct_node *op = expr->first_operator;
    if (op->fixity_associativity == CONSTRUCT_INFIX_FLAT) {
        struct construct_node *first_value = expr->first_value;
        struct construct_node *last_value = first_value;
        struct construct_node *last_operator = op;
        size_t operand = op->slots[expr->operand_slot_index];
        struct construct_node *combined_op = construct_node_alloc(s, op->rule);
        combined_op->choice_index = op->choice_index;
        combined_op->slot_index = op->slot_index;
        combined_op->fixity_associativity = op->fixity_associativity;
        combined_op->precedence = op->precedence;
        struct construct_node *reversed_values = 0;
        while (last_operator && last_operator->choice_index == op->choice_index) {
            struct construct_node *next_op = last_operator->next;
            construct_node_free(s, last_operator);
            last_operator = next_op;
            assert(last_value);
            struct construct_node *next_value = last_value->next;
            last_value->next = reversed_values;
            reversed_values = last_value;
            last_value = next_value;
        }
        combined_op->start_location = first_value->start_location;
        combined_op->end_location = last_value->end_location;
        assert(last_value);
        operand = (finish_node((last_value)->rule, (last_value)->choice_index, operand, (last_value)->slots, (last_value)->start_location, (last_value)->end_location, s->info));
        combined_op->next = last_value->next;
        construct_node_free(s, last_value);
        while (reversed_values) {
            operand = (finish_node((reversed_values)->rule, (reversed_values)->choice_index, operand, (reversed_values)->slots, (reversed_values)->start_location, (reversed_values)->end_location, s->info));
            struct construct_node *next_value = reversed_values->next;
            construct_node_free(s, reversed_values);
            reversed_values = next_value;
        }
        expr->first_operator = last_operator;
        expr->first_value = combined_op;
        combined_op->slots[expr->operand_slot_index] = operand;
    }
    else if (op->fixity_associativity == CONSTRUCT_INFIX_LEFT || op->fixity_associativity == CONSTRUCT_INFIX_RIGHT) {
        expr->first_operator = op->next;
        struct construct_node *left = expr->first_value;
        struct construct_node *right = left->next;
        op->next = right->next;
        expr->first_value = op;
        op->start_location = left->start_location;
        op->end_location = right->end_location;
        op->slots[expr->left_slot_index] = (finish_node((left)->rule, (left)->choice_index, op->slots[expr->left_slot_index], (left)->slots, (left)->start_location, (left)->end_location, s->info));
        op->slots[expr->right_slot_index] = (finish_node((right)->rule, (right)->choice_index, op->slots[expr->right_slot_index], (right)->slots, (right)->start_location, (right)->end_location, s->info));
        construct_node_free(s, left);
        construct_node_free(s, right);
    }
    else {
        expr->first_operator = op->next;
        struct construct_node *value = expr->first_value;
        op->next = value->next;
        expr->first_value = op;
        if (value->start_location < op->start_location) op->start_location = value->start_location;
        if (value->end_location > op->end_location) op->end_location = value->end_location;
        op->slots[expr->operand_slot_index] = (finish_node((value)->rule, (value)->choice_index, op->slots[expr->operand_slot_index], (value)->slots, (value)->start_location, (value)->end_location, s->info));
        construct_node_free(s, value);
    }
}
static void construct_begin(struct construct_state *s, size_t offset, enum construct_root_type type) {
    s->root_type = type;
    uint32_t r = 0;
    if (type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = construct_expression_alloc(s, r);
        expr->parent = s->current_expression;
        s->current_expression = expr;
    }
    else {
        struct construct_node *node = construct_node_alloc(s, r);
        node->next = s->under_construction;
        node->end_location = offset;
        s->under_construction = node;
    }
}
static size_t construct_finish(struct construct_state *s, size_t offset) {
    size_t finished = 0;
    if (s->root_type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = s->current_expression;
        s->current_expression = expr->parent;
        while (expr->first_operator) construct_expression_reduce(s, expr);
        struct construct_node *node = expr->first_value;
        if (node) {
            finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            assert(node->next == 0);
            construct_node_free(s, node);
        }
        construct_expression_free(s, expr);
    }
    else {
        struct construct_node *node = s->under_construction;
        s->under_construction = node->next;
        node->start_location = offset;
        finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
        construct_node_free(s, node);
    }
    while (s->node_freelist) {
        struct construct_node *node = s->node_freelist;
        s->node_freelist = node->next;
        free(node->slots);
        free(node);
    }
    while (s->expression_freelist) {
        struct construct_expression *expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        free(expr);
    }
    return finished;
}
static void construct_action_apply(struct construct_state *s, uint16_t action, size_t offset) {
    switch ((((action) >> 12) & 0xf)) {
    case 8:
        {
            struct construct_node *node = construct_node_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            node->next = s->under_construction;
            node->slot_index = ((action) & 0xfff);
            node->end_location = offset;
            s->under_construction = node;
            break;
        }
    case 9:
        {
            struct construct_expression *expr = construct_expression_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            expr->parent = s->current_expression;
            s->current_expression = expr;
            expr->slot_index = ((action) & 0xfff);
            break;
        }
    case 1:
        {
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            size_t *finished;
            finished = &s->under_construction->slots[node->slot_index];
            *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            construct_node_free(s, node);
            break;
        }
    case 2:
        {
            struct construct_expression *expr = s->current_expression;
            s->current_expression = expr->parent;
            while (expr->first_operator) construct_expression_reduce(s, expr);
            size_t *finished;
            finished = &s->under_construction->slots[expr->slot_index];
            struct construct_node *node = expr->first_value;
            if (node) {
                *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
                assert(node->next == 0);
                construct_node_free(s, node);
            }
            construct_expression_free(s, expr);
            break;
        }
    case 3:
        s->under_construction->choice_index = ((action) & 0xfff);
        break;
    case 4:
        {
            uint16_t slot = ((action) & 0xfff);
            size_t *finished = &s->under_construction->slots[slot];
            *finished = finish_token(rule_lookup(s->under_construction->rule, slot, s->info), *finished, s->info);
            break;
        }
    case 10:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 11:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            enum construct_fixity_associativity fixity_associativity;
            int precedence;
            do {
                int local;
                fixity_associativity_precedence_lookup(&local, &precedence, expr->rule, ((action) & 0xfff), s->info);
                fixity_associativity = local;
            }
            while (0);
            node->fixity_associativity = fixity_associativity;
            node->precedence = precedence;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 5:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            node->next = expr->first_value;
            expr->first_value = node;
            break;
        }
    case 6:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            while (construct_expression_should_reduce(s, expr, node)) construct_expression_reduce(s, expr);
            node->next = expr->first_operator;
            expr->first_operator = node;
            if (node->fixity_associativity == CONSTRUCT_PREFIX) construct_expression_reduce(s, expr);
            break;
        }
    }
}

struct fill_run_continuation;
struct fill_run_state {
    void (*state_func)(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
    uint32_t reachability_mask[1];
    struct fill_run_continuation *cont;
};
struct fill_run_continuation {
    struct fill_run_state *stack;
    uint32_t top_index;
    uint32_t capacity;
    bool error;
};
static void continuation_stack_push(struct fill_run_state **top) {
    struct fill_run_continuation *cont = (*top)->cont;
    cont->top_index++;
    if (cont->top_index >= cont->capacity) {
        size_t new_capacity = (cont->capacity + 2) * 3 / 2;
        if (new_capacity <= cont->capacity)
            abort();
        struct fill_run_state *new_states = realloc(cont->stack, new_capacity * sizeof(struct fill_run_state));
        if (!new_states)
            abort();
        cont->stack = new_states;
        cont->capacity = new_capacity;
        *top = &cont->stack[cont->top_index];
    } else
        (*top)++;
    (*top)->cont = cont;
}
static void state_func_0(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_1(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_2(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_3(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_4(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_5(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_6(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_7(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_8(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_9(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_10(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_11(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_12(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_13(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_14(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_15(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_16(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_17(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_18(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_19(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_20(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_21(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_22(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_23(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_24(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_25(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_26(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_27(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_28(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_29(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_30(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_31(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_32(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_33(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_34(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_35(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_36(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_37(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_38(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_39(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_40(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_41(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_42(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_43(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_44(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_45(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_46(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_47(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_48(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_49(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_50(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_51(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_52(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_53(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_54(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_55(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_56(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_57(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_58(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_59(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_60(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_61(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_62(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_63(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_64(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_65(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_66(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_67(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_68(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_69(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_70(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_71(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_72(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_73(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_74(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_75(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_76(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_77(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_78(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_79(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_80(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_81(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_82(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_83(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_84(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_85(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_86(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_87(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_88(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_89(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_90(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_91(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index);
static void state_func_0(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 0;
    switch (token) {
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_2; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_1(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 1;
    switch (token) {
    case 23: top->state_func = state_func_58; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_2(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 2;
    switch (token) {
    case 0: top->state_func = state_func_3; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_3(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 3;
    switch (token) {
    case 21: top->state_func = state_func_4; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_4(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 4;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 10: top->state_func = state_func_14; return;
    case 11: top->state_func = state_func_15; return;
    case 16: top->state_func = state_func_9; return;
    case 17: top->state_func = state_func_10; return;
    case 18: top->state_func = state_func_11; return;
    case 19: top->state_func = state_func_12; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_13; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_5(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 5;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_9; return;
    case 17: top->state_func = state_func_10; return;
    case 18: top->state_func = state_func_11; return;
    case 19: top->state_func = state_func_12; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_13; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_6(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 6;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_9; return;
    case 17: top->state_func = state_func_10; return;
    case 18: top->state_func = state_func_11; return;
    case 19: top->state_func = state_func_12; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_13; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_7(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 7;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_9; return;
    case 17: top->state_func = state_func_10; return;
    case 18: top->state_func = state_func_11; return;
    case 19: top->state_func = state_func_12; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_13; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_8(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 8;
    switch (token) {
    case 21: top->state_func = state_func_19; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_9(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 9;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_9; return;
    case 17: top->state_func = state_func_10; return;
    case 18: top->state_func = state_func_11; return;
    case 19: top->state_func = state_func_12; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_13; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_10(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 10;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_9; return;
    case 17: top->state_func = state_func_10; return;
    case 18: top->state_func = state_func_11; return;
    case 19: top->state_func = state_func_12; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_13; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_11(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 11;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_9; return;
    case 17: top->state_func = state_func_10; return;
    case 18: top->state_func = state_func_11; return;
    case 19: top->state_func = state_func_12; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_13; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_12(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 12;
    switch (token) {
    case 21: top->state_func = state_func_4; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_13(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 13;
    switch (token) {
    case 0: top->state_func = state_func_3; return;
    case 1: top->state_func = state_func_8; return;
    case 10: top->state_func = state_func_14; return;
    case 11: top->state_func = state_func_15; return;
    case 16: top->state_func = state_func_9; return;
    case 17: top->state_func = state_func_10; return;
    case 18: top->state_func = state_func_11; return;
    case 19: top->state_func = state_func_12; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_13; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_14(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 14;
    switch (token) {
    case 1: top->state_func = state_func_17; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_15(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 15;
    switch (token) {
    case 21: top->state_func = state_func_16; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_16(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 16;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_9; return;
    case 17: top->state_func = state_func_10; return;
    case 18: top->state_func = state_func_11; return;
    case 19: top->state_func = state_func_12; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_13; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_17(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 17;
    switch (token) {
    case 21: top->state_func = state_func_18; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_18(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 18;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 10: top->state_func = state_func_14; return;
    case 11: top->state_func = state_func_15; return;
    case 16: top->state_func = state_func_9; return;
    case 17: top->state_func = state_func_10; return;
    case 18: top->state_func = state_func_11; return;
    case 19: top->state_func = state_func_12; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_13; return;
    case 23: top->state_func = state_func_5; return;
    case 24: top->state_func = state_func_6; return;
    case 25: top->state_func = state_func_7; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_19(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 19;
    switch (token) {
    case 2: top->state_func = state_func_20; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_21; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_20(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 20;
    switch (token) {
    case 3: top->state_func = state_func_35; return;
    case 4: top->state_func = state_func_36; return;
    case 5: top->state_func = state_func_37; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_21(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 21;
    switch (token) {
    case 0: top->state_func = state_func_3; return;
    case 1: top->state_func = state_func_8; return;
    case 10: top->state_func = state_func_30; return;
    case 11: top->state_func = state_func_31; return;
    case 16: top->state_func = state_func_25; return;
    case 17: top->state_func = state_func_26; return;
    case 18: top->state_func = state_func_27; return;
    case 19: top->state_func = state_func_28; return;
    case 21: top->state_func = state_func_29; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_22(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 22;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_25; return;
    case 17: top->state_func = state_func_26; return;
    case 18: top->state_func = state_func_27; return;
    case 19: top->state_func = state_func_28; return;
    case 21: top->state_func = state_func_29; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_23(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 23;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_25; return;
    case 17: top->state_func = state_func_26; return;
    case 18: top->state_func = state_func_27; return;
    case 19: top->state_func = state_func_28; return;
    case 21: top->state_func = state_func_29; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_24(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 24;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_25; return;
    case 17: top->state_func = state_func_26; return;
    case 18: top->state_func = state_func_27; return;
    case 19: top->state_func = state_func_28; return;
    case 21: top->state_func = state_func_29; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_25(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 25;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_25; return;
    case 17: top->state_func = state_func_26; return;
    case 18: top->state_func = state_func_27; return;
    case 19: top->state_func = state_func_28; return;
    case 21: top->state_func = state_func_29; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_26(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 26;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_25; return;
    case 17: top->state_func = state_func_26; return;
    case 18: top->state_func = state_func_27; return;
    case 19: top->state_func = state_func_28; return;
    case 21: top->state_func = state_func_29; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_27(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 27;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_25; return;
    case 17: top->state_func = state_func_26; return;
    case 18: top->state_func = state_func_27; return;
    case 19: top->state_func = state_func_28; return;
    case 21: top->state_func = state_func_29; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_28(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 28;
    switch (token) {
    case 21: top->state_func = state_func_29; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_29(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 29;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 10: top->state_func = state_func_30; return;
    case 11: top->state_func = state_func_31; return;
    case 16: top->state_func = state_func_25; return;
    case 17: top->state_func = state_func_26; return;
    case 18: top->state_func = state_func_27; return;
    case 19: top->state_func = state_func_28; return;
    case 21: top->state_func = state_func_29; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_30(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 30;
    switch (token) {
    case 1: top->state_func = state_func_33; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_31(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 31;
    switch (token) {
    case 21: top->state_func = state_func_32; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_32(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 32;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 16: top->state_func = state_func_25; return;
    case 17: top->state_func = state_func_26; return;
    case 18: top->state_func = state_func_27; return;
    case 19: top->state_func = state_func_28; return;
    case 21: top->state_func = state_func_29; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_33(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 33;
    switch (token) {
    case 21: top->state_func = state_func_34; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_34(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 34;
    switch (token) {
    case 1: top->state_func = state_func_8; return;
    case 10: top->state_func = state_func_30; return;
    case 11: top->state_func = state_func_31; return;
    case 16: top->state_func = state_func_25; return;
    case 17: top->state_func = state_func_26; return;
    case 18: top->state_func = state_func_27; return;
    case 19: top->state_func = state_func_28; return;
    case 21: top->state_func = state_func_29; return;
    case 23: top->state_func = state_func_22; return;
    case 24: top->state_func = state_func_23; return;
    case 25: top->state_func = state_func_24; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_35(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 35;
    switch (token) {
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_36(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 36;
    switch (token) {
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_37(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 37;
    switch (token) {
    case 6: top->state_func = state_func_38; return;
    case 7: top->state_func = state_func_39; return;
    case 8: top->state_func = state_func_40; return;
    case 9: top->state_func = state_func_41; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_38(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 38;
    switch (token) {
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_39(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 39;
    switch (token) {
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_40(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 40;
    switch (token) {
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_41(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 41;
    switch (token) {
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_42(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 42;
    switch (token) {
    case 1: top->state_func = state_func_46; return;
    case 10: top->state_func = state_func_53; return;
    case 11: top->state_func = state_func_54; return;
    case 16: top->state_func = state_func_47; return;
    case 17: top->state_func = state_func_48; return;
    case 18: top->state_func = state_func_49; return;
    case 19: top->state_func = state_func_50; return;
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_43(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 43;
    switch (token) {
    case 1: top->state_func = state_func_46; return;
    case 16: top->state_func = state_func_47; return;
    case 17: top->state_func = state_func_48; return;
    case 18: top->state_func = state_func_49; return;
    case 19: top->state_func = state_func_50; return;
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_44(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 44;
    switch (token) {
    case 1: top->state_func = state_func_46; return;
    case 16: top->state_func = state_func_47; return;
    case 17: top->state_func = state_func_48; return;
    case 18: top->state_func = state_func_49; return;
    case 19: top->state_func = state_func_50; return;
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_45(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 45;
    switch (token) {
    case 1: top->state_func = state_func_46; return;
    case 16: top->state_func = state_func_47; return;
    case 17: top->state_func = state_func_48; return;
    case 18: top->state_func = state_func_49; return;
    case 19: top->state_func = state_func_50; return;
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_46(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 46;
    switch (token) {
    case 21: top->state_func = state_func_51; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_47(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 47;
    switch (token) {
    case 1: top->state_func = state_func_46; return;
    case 16: top->state_func = state_func_47; return;
    case 17: top->state_func = state_func_48; return;
    case 18: top->state_func = state_func_49; return;
    case 19: top->state_func = state_func_50; return;
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_48(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 48;
    switch (token) {
    case 1: top->state_func = state_func_46; return;
    case 16: top->state_func = state_func_47; return;
    case 17: top->state_func = state_func_48; return;
    case 18: top->state_func = state_func_49; return;
    case 19: top->state_func = state_func_50; return;
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_49(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 49;
    switch (token) {
    case 1: top->state_func = state_func_46; return;
    case 16: top->state_func = state_func_47; return;
    case 17: top->state_func = state_func_48; return;
    case 18: top->state_func = state_func_49; return;
    case 19: top->state_func = state_func_50; return;
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_50(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 50;
    switch (token) {
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_51(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 51;
    switch (token) {
    case 2: top->state_func = state_func_20; return;
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_52; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_52(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 52;
    switch (token) {
    case 0: top->state_func = state_func_3; return;
    case 1: top->state_func = state_func_46; return;
    case 10: top->state_func = state_func_53; return;
    case 11: top->state_func = state_func_54; return;
    case 16: top->state_func = state_func_47; return;
    case 17: top->state_func = state_func_48; return;
    case 18: top->state_func = state_func_49; return;
    case 19: top->state_func = state_func_50; return;
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_53(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 53;
    switch (token) {
    case 1: top->state_func = state_func_56; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_54(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 54;
    switch (token) {
    case 21: top->state_func = state_func_55; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_55(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 55;
    switch (token) {
    case 1: top->state_func = state_func_46; return;
    case 16: top->state_func = state_func_47; return;
    case 17: top->state_func = state_func_48; return;
    case 18: top->state_func = state_func_49; return;
    case 19: top->state_func = state_func_50; return;
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_56(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 56;
    switch (token) {
    case 21: top->state_func = state_func_57; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_57(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 57;
    switch (token) {
    case 1: top->state_func = state_func_46; return;
    case 10: top->state_func = state_func_53; return;
    case 11: top->state_func = state_func_54; return;
    case 16: top->state_func = state_func_47; return;
    case 17: top->state_func = state_func_48; return;
    case 18: top->state_func = state_func_49; return;
    case 19: top->state_func = state_func_50; return;
    case 21: top->state_func = state_func_42; return;
    case 23: top->state_func = state_func_43; return;
    case 24: top->state_func = state_func_44; return;
    case 25: top->state_func = state_func_45; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_58(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 58;
    switch (token) {
    case 20: top->state_func = state_func_1; return;
    case 21: top->state_func = state_func_2; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_59(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(3 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 59;
    switch (token) {
    case 12: top->state_func = state_func_60; return;
    case 14: top->state_func = state_func_61; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_60(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 60;
    switch (token) {
    case 21: top->state_func = state_func_78; return;
    case 23: top->state_func = state_func_79; return;
    case 24: top->state_func = state_func_80; return;
    case 25: top->state_func = state_func_81; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_61(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 61;
    switch (token) {
    case 23: top->state_func = state_func_62; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_62(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 62;
    switch (token) {
    case 21: top->state_func = state_func_63; return;
    case 23: top->state_func = state_func_64; return;
    case 24: top->state_func = state_func_65; return;
    case 25: top->state_func = state_func_66; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_63(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 63;
    switch (token) {
    case 10: top->state_func = state_func_73; return;
    case 11: top->state_func = state_func_74; return;
    case 16: top->state_func = state_func_67; return;
    case 17: top->state_func = state_func_68; return;
    case 18: top->state_func = state_func_69; return;
    case 19: top->state_func = state_func_70; return;
    case 21: top->state_func = state_func_63; return;
    case 23: top->state_func = state_func_71; return;
    case 24: top->state_func = state_func_65; return;
    case 25: top->state_func = state_func_66; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_64(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 64;
    switch (token) {
    case 15: top->state_func = state_func_72; return;
    case 16: top->state_func = state_func_67; return;
    case 17: top->state_func = state_func_68; return;
    case 18: top->state_func = state_func_69; return;
    case 19: top->state_func = state_func_70; return;
    case 21: top->state_func = state_func_63; return;
    case 23: top->state_func = state_func_71; return;
    case 24: top->state_func = state_func_65; return;
    case 25: top->state_func = state_func_66; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_65(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 65;
    switch (token) {
    case 16: top->state_func = state_func_67; return;
    case 17: top->state_func = state_func_68; return;
    case 18: top->state_func = state_func_69; return;
    case 19: top->state_func = state_func_70; return;
    case 21: top->state_func = state_func_63; return;
    case 23: top->state_func = state_func_71; return;
    case 24: top->state_func = state_func_65; return;
    case 25: top->state_func = state_func_66; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_66(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 66;
    switch (token) {
    case 16: top->state_func = state_func_67; return;
    case 17: top->state_func = state_func_68; return;
    case 18: top->state_func = state_func_69; return;
    case 19: top->state_func = state_func_70; return;
    case 21: top->state_func = state_func_63; return;
    case 23: top->state_func = state_func_71; return;
    case 24: top->state_func = state_func_65; return;
    case 25: top->state_func = state_func_66; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_67(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 67;
    switch (token) {
    case 16: top->state_func = state_func_67; return;
    case 17: top->state_func = state_func_68; return;
    case 18: top->state_func = state_func_69; return;
    case 19: top->state_func = state_func_70; return;
    case 21: top->state_func = state_func_63; return;
    case 23: top->state_func = state_func_71; return;
    case 24: top->state_func = state_func_65; return;
    case 25: top->state_func = state_func_66; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_68(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 68;
    switch (token) {
    case 16: top->state_func = state_func_67; return;
    case 17: top->state_func = state_func_68; return;
    case 18: top->state_func = state_func_69; return;
    case 19: top->state_func = state_func_70; return;
    case 21: top->state_func = state_func_63; return;
    case 23: top->state_func = state_func_71; return;
    case 24: top->state_func = state_func_65; return;
    case 25: top->state_func = state_func_66; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_69(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 69;
    switch (token) {
    case 16: top->state_func = state_func_67; return;
    case 17: top->state_func = state_func_68; return;
    case 18: top->state_func = state_func_69; return;
    case 19: top->state_func = state_func_70; return;
    case 21: top->state_func = state_func_63; return;
    case 23: top->state_func = state_func_71; return;
    case 24: top->state_func = state_func_65; return;
    case 25: top->state_func = state_func_66; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_70(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(0 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 70;
    switch (token) {
    default: top->cont->error = true; return;
    }
}
static void state_func_71(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 71;
    switch (token) {
    case 15: top->state_func = state_func_72; return;
    case 16: top->state_func = state_func_67; return;
    case 17: top->state_func = state_func_68; return;
    case 18: top->state_func = state_func_69; return;
    case 19: top->state_func = state_func_70; return;
    case 21: top->state_func = state_func_63; return;
    case 23: top->state_func = state_func_71; return;
    case 24: top->state_func = state_func_65; return;
    case 25: top->state_func = state_func_66; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_72(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    if (top->cont->top_index == 0) {
        top->cont->error = true;
        return;
    }
    top->cont->top_index--;
    top--;
    run->tokens[token_index] = 25;
    top->state_func(run, top, token_index);
    return;
}
static void state_func_73(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 73;
    switch (token) {
    case 1: top->state_func = state_func_76; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_74(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 74;
    switch (token) {
    case 21: top->state_func = state_func_75; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_75(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 75;
    switch (token) {
    case 16: top->state_func = state_func_67; return;
    case 17: top->state_func = state_func_68; return;
    case 18: top->state_func = state_func_69; return;
    case 19: top->state_func = state_func_70; return;
    case 21: top->state_func = state_func_63; return;
    case 23: top->state_func = state_func_71; return;
    case 24: top->state_func = state_func_65; return;
    case 25: top->state_func = state_func_66; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_76(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 76;
    switch (token) {
    case 21: top->state_func = state_func_77; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_77(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 77;
    switch (token) {
    case 10: top->state_func = state_func_73; return;
    case 11: top->state_func = state_func_74; return;
    case 16: top->state_func = state_func_67; return;
    case 17: top->state_func = state_func_68; return;
    case 18: top->state_func = state_func_69; return;
    case 19: top->state_func = state_func_70; return;
    case 21: top->state_func = state_func_63; return;
    case 23: top->state_func = state_func_71; return;
    case 24: top->state_func = state_func_65; return;
    case 25: top->state_func = state_func_66; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_78(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 78;
    switch (token) {
    case 10: top->state_func = state_func_87; return;
    case 11: top->state_func = state_func_88; return;
    case 13: top->state_func = state_func_82; return;
    case 16: top->state_func = state_func_83; return;
    case 17: top->state_func = state_func_84; return;
    case 18: top->state_func = state_func_85; return;
    case 19: top->state_func = state_func_86; return;
    case 21: top->state_func = state_func_78; return;
    case 23: top->state_func = state_func_79; return;
    case 24: top->state_func = state_func_80; return;
    case 25: top->state_func = state_func_81; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_79(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 79;
    switch (token) {
    case 13: top->state_func = state_func_82; return;
    case 16: top->state_func = state_func_83; return;
    case 17: top->state_func = state_func_84; return;
    case 18: top->state_func = state_func_85; return;
    case 19: top->state_func = state_func_86; return;
    case 21: top->state_func = state_func_78; return;
    case 23: top->state_func = state_func_79; return;
    case 24: top->state_func = state_func_80; return;
    case 25: top->state_func = state_func_81; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_80(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 80;
    switch (token) {
    case 13: top->state_func = state_func_82; return;
    case 16: top->state_func = state_func_83; return;
    case 17: top->state_func = state_func_84; return;
    case 18: top->state_func = state_func_85; return;
    case 19: top->state_func = state_func_86; return;
    case 21: top->state_func = state_func_78; return;
    case 23: top->state_func = state_func_79; return;
    case 24: top->state_func = state_func_80; return;
    case 25: top->state_func = state_func_81; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_81(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 81;
    switch (token) {
    case 13: top->state_func = state_func_82; return;
    case 16: top->state_func = state_func_83; return;
    case 17: top->state_func = state_func_84; return;
    case 18: top->state_func = state_func_85; return;
    case 19: top->state_func = state_func_86; return;
    case 21: top->state_func = state_func_78; return;
    case 23: top->state_func = state_func_79; return;
    case 24: top->state_func = state_func_80; return;
    case 25: top->state_func = state_func_81; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_82(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    if (top->cont->top_index == 0) {
        top->cont->error = true;
        return;
    }
    top->cont->top_index--;
    top--;
    run->tokens[token_index] = 24;
    top->state_func(run, top, token_index);
    return;
}
static void state_func_83(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 83;
    switch (token) {
    case 13: top->state_func = state_func_82; return;
    case 16: top->state_func = state_func_83; return;
    case 17: top->state_func = state_func_84; return;
    case 18: top->state_func = state_func_85; return;
    case 19: top->state_func = state_func_86; return;
    case 21: top->state_func = state_func_78; return;
    case 23: top->state_func = state_func_79; return;
    case 24: top->state_func = state_func_80; return;
    case 25: top->state_func = state_func_81; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_84(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 84;
    switch (token) {
    case 13: top->state_func = state_func_82; return;
    case 16: top->state_func = state_func_83; return;
    case 17: top->state_func = state_func_84; return;
    case 18: top->state_func = state_func_85; return;
    case 19: top->state_func = state_func_86; return;
    case 21: top->state_func = state_func_78; return;
    case 23: top->state_func = state_func_79; return;
    case 24: top->state_func = state_func_80; return;
    case 25: top->state_func = state_func_81; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_85(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 85;
    switch (token) {
    case 13: top->state_func = state_func_82; return;
    case 16: top->state_func = state_func_83; return;
    case 17: top->state_func = state_func_84; return;
    case 18: top->state_func = state_func_85; return;
    case 19: top->state_func = state_func_86; return;
    case 21: top->state_func = state_func_78; return;
    case 23: top->state_func = state_func_79; return;
    case 24: top->state_func = state_func_80; return;
    case 25: top->state_func = state_func_81; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_86(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 86;
    switch (token) {
    case 21: top->state_func = state_func_78; return;
    case 23: top->state_func = state_func_79; return;
    case 24: top->state_func = state_func_80; return;
    case 25: top->state_func = state_func_81; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_87(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 87;
    switch (token) {
    case 1: top->state_func = state_func_90; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_88(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 88;
    switch (token) {
    case 21: top->state_func = state_func_89; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_89(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 89;
    switch (token) {
    case 13: top->state_func = state_func_82; return;
    case 16: top->state_func = state_func_83; return;
    case 17: top->state_func = state_func_84; return;
    case 18: top->state_func = state_func_85; return;
    case 19: top->state_func = state_func_86; return;
    case 21: top->state_func = state_func_78; return;
    case 23: top->state_func = state_func_79; return;
    case 24: top->state_func = state_func_80; return;
    case 25: top->state_func = state_func_81; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static void state_func_90(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 90;
    switch (token) {
    case 21: top->state_func = state_func_91; return;
    default: top->cont->error = true; return;
    }
}
static void state_func_91(struct bluebird_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = true;
        return;
    }
    uint32_t token = run->tokens[token_index];
    run->states[token_index] = 91;
    switch (token) {
    case 10: top->state_func = state_func_87; return;
    case 11: top->state_func = state_func_88; return;
    case 13: top->state_func = state_func_82; return;
    case 16: top->state_func = state_func_83; return;
    case 17: top->state_func = state_func_84; return;
    case 18: top->state_func = state_func_85; return;
    case 19: top->state_func = state_func_86; return;
    case 21: top->state_func = state_func_78; return;
    case 23: top->state_func = state_func_79; return;
    case 24: top->state_func = state_func_80; return;
    case 25: top->state_func = state_func_81; return;
    default:
        continuation_stack_push(&top);
        top->reachability_mask[0] = 3;
        state_func_59(run, top, token_index);
        return;
    }
}
static bool fill_run_states(struct bluebird_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index);
static size_t build_parse_tree(struct bluebird_default_tokenizer *, struct bluebird_token_run *, struct bluebird_tree *);

static struct bluebird_tree *bluebird_tree_create_empty(void) {
    return calloc(1, sizeof(struct bluebird_tree));
}

struct bluebird_tree *bluebird_tree_create_from_string(const char *string) {
    struct bluebird_tree *tree = bluebird_tree_create_empty();
    tree->string = string;
    tree->next_offset = 1;
    struct bluebird_default_tokenizer tokenizer = {
        .text = string,
        .info = tree,
    };
    struct bluebird_token_run *token_run = 0;
    struct fill_run_continuation c = {
        .capacity = 8,
        .top_index = 0,
    };
    c.stack = calloc(c.capacity, sizeof(struct fill_run_state));
    c.stack[0].state_func = state_func_0;
    c.stack[0].cont = &c;
    uint16_t failing_index = 0;
    while (bluebird_default_tokenizer_advance(&tokenizer, &token_run)) {
        if (!fill_run_states(token_run, &c, &failing_index)) {
            free(c.stack);
            tree->error = ERROR_UNEXPECTED_TOKEN;
            find_token_range(&tokenizer, token_run, failing_index, &tree->error_range.start, &tree->error_range.end);
            return tree;
        }
    }
    struct fill_run_state top = c.stack[c.top_index];
    free(c.stack);
    if (string[tokenizer.offset] != '\0') {
        tree->error = ERROR_INVALID_TOKEN;
        estimate_next_token_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        return tree;
    }
    if (top.state_func != state_func_0 && top.state_func != state_func_4 && top.state_func != state_func_5 && top.state_func != state_func_6 && top.state_func != state_func_7 && top.state_func != state_func_9 && top.state_func != state_func_10 && top.state_func != state_func_11 && top.state_func != state_func_13 && top.state_func != state_func_16 && top.state_func != state_func_18 && top.state_func != state_func_19 && top.state_func != state_func_51 && top.state_func != state_func_58) {
        tree->error = ERROR_MORE_INPUT_NEEDED;
        find_end_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        return tree;
    }
    tree->root_offset = build_parse_tree(&tokenizer, token_run, tree);
    return tree;
}
static struct bluebird_tree *bluebird_tree_create_with_error(enum bluebird_error e) {
    struct bluebird_tree *tree = bluebird_tree_create_empty();
    tree->error = e;
    return tree;
}
struct bluebird_tree *bluebird_tree_create_from_file(FILE *file) {
    if (!file)
        return bluebird_tree_create_with_error(ERROR_INVALID_FILE);
    char *str = 0;
    size_t len = 32;
    size_t off = 0;
    while (true) {
        len = len * 3 / 2;
        char *s = realloc(str, len * 3 / 2);
        if (!s) {
            free(str);
            return 0;
        }
        str = s;
        off += fread(str + off, 1, len - off, file);
        if (off < len) {
            str[off] = '\0';
            break;
        }
    }
    struct bluebird_tree *tree = bluebird_tree_create_from_string(str);
    if (!tree) {
        free(str);
        return 0;
    }
    tree->owns_string = true;
    return tree;
}
enum bluebird_error bluebird_tree_get_error(struct bluebird_tree *tree, struct source_range *error_range) {
    if (error_range)
        *error_range = tree->error_range;
    return tree->error;
}
void bluebird_tree_destroy(struct bluebird_tree *tree) {
    if (tree->owns_string)
        free((void *)tree->string);
    free(tree->parse_tree);
    free(tree->identifier_tokens);
    free(tree->number_tokens);
    for (uint32_t i = 0; i < tree->number_of_string_tokens; ++i) {
        if (tree->string_tokens[i].has_escapes)
            free((void *)tree->string_tokens[i].string);
    }
    free(tree->string_tokens);
    free(tree);
}
static bool fill_run_states(struct bluebird_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index) {
    uint16_t token_index = 0;
    uint16_t number_of_tokens = run->number_of_tokens;
    while (token_index < number_of_tokens) {
        struct fill_run_state *top = &cont->stack[cont->top_index];
        top->state_func(run, top, token_index);
        if (cont->error) {
            *failing_index = token_index;
            return false;
        }
        token_index++;
    }
    return true;
}
static const uint16_t actions[] = {
0,0,4096,0,4096,16385,0,4096,32768,32769,16385,0,4096,32768,32769,32770,32769,16385,0,4096,32768,32769,36864,40960,16384,0,4096,32768,32769,36864,
40960,16385,0,4096,32768,32769,36864,40960,16386,0,4096,32768,32769,36864,40961,16387,0,4096,32768,32769,36864,40962,0,4096,32768,32769,36864,40963,0,4096,
32768,32769,36864,45060,0,4096,32768,32769,36864,45061,0,4096,32768,32769,36864,45062,0,4096,32769,16384,0,4096,32770,32769,16385,0,16384,0,16385,0,
16389,0,16390,0,20480,8192,0,20480,8192,4096,0,20480,8192,4096,32768,12288,0,20480,8192,4096,32768,12289,0,20480,8192,4096,32768,12290,32768,12288,
0,20480,8192,4096,32768,12290,32768,12289,0,20480,8192,4096,32768,12290,32768,12290,0,20480,8192,4096,32768,12290,32768,12291,0,20480,8192,4096,32769,16385,
0,20480,8192,16385,0,20480,8192,16389,0,20480,45063,24576,40960,16384,0,20480,45063,24576,40960,16385,0,20480,45063,24576,40960,16386,0,20480,45063,24576,
40961,16387,0,20480,45063,24576,40962,0,20480,45063,24576,40963,0,20480,45063,24576,45060,0,20480,45063,24576,45061,0,20480,45063,24576,45062,0,20480,45064,
0,24576,40960,16384,0,24576,40960,16385,0,24576,40960,16386,0,24576,40961,16387,0,24576,40962,0,24576,40963,0,24576,45060,0,24576,45061,0,24576,
45062,0,32768,32769,16385,0,32768,32769,32770,32769,16385,0,32768,32769,36864,40960,16384,0,32768,32769,36864,40960,16385,0,32768,32769,36864,40960,16386,0,
32768,32769,36864,40961,16387,0,32768,32769,36864,40962,0,32768,32769,36864,40963,0,32768,32769,36864,45060,0,32768,32769,36864,45061,0,32768,32769,36864,45062,
0,32769,16384,0,36864,40960,16384,0,36864,40960,16385,0,36864,40960,16386,0,36864,40961,16387,0,36864,40962,0,36864,40963,0,36864,45060,0,36864,
45061,0,36864,45062,0,36868,40960,16384,0,36868,40960,16385,0,36868,40960,16386,0,36868,40961,16387,0,36868,40962,0,36868,40963,0,36868,45060,0,
36868,45061,0,36868,45062,0,};
struct action_table_entry {
    uint32_t target_nfa_state;
    uint32_t dfa_state;
    uint32_t dfa_symbol;
    uint32_t nfa_state;
    uint32_t actions;
    uint32_t push_nfa_state;
};
static const struct action_table_entry action_table[2048][2] = {
{{3670,84,23,28,347},},{0},{0},{{19,16,17,42,65},{19,5,16,42,59},},{0},{0},{{705,75,21,451,211},},{{451,68,25,3749,188,451},},{0},{0},{0},{{0,50,24,3739,183,0},
{0,39,25,3749,188,0},},{{350,18,21,3,304},},{{1,50,23,0,223},},{{42,12,21,3,211},{28,83,16,2408,193},},{{2408,83,25,3749,230,28},
{451,64,21,451,159},},{0},{{3702,10,20,19,0},},{{237,26,16,45,326},},{0},{{19,10,16,42,59},},{{0,57,17,1,198},},{0},{0},{{19,6,16,42,59},},
{{350,13,23,3,316},{5,25,24,3739,183,5},},{{2094,77,16,705,357},{42,4,25,3749,230,3},},{{21,18,21,3,252},},{{3670,83,16,2408,357},},
{{3690,55,21,0,86},},{{5,29,23,5,177},},{{3,16,21,3,159},},{{45,34,18,45,239},{45,24,16,45,233},},{{8,5,25,3749,281,3},},
{{1,55,21,0,211},},{{237,22,17,45,329},},{0},{0},{{3726,52,1,2,0},{28,86,25,3749,188,28},},{{1,51,24,3739,227,0},},{{3718,86,21,28,86},
{21,13,25,3749,281,3},},{0},{0},{0},{{705,65,21,451,211},},{{8,13,21,3,252},{0,41,25,3749,188,0},},{{5,22,24,3739,183,5},},{{1,42,21,0,211},},
{{28,60,21,28,159},{3,4,18,42,203},},{{0,45,25,3749,188,0},},{{2094,64,25,3749,354,451},{28,78,21,28,159},},{{5,26,21,5,159},},
{{705,77,25,3749,230,451},},{{451,74,21,3756,171},},{0},{{3725,68,23,2094,92},},{{1,52,24,3739,227,0},},{{705,63,18,705,239},},{{2,56,21,3762,308},},
{{28,85,23,28,177},},{{45,25,25,3749,230,5},},{0},{0},{0},{0},{{2,47,17,1,329},},{0},{{2094,71,23,451,347},{3,13,24,3739,183,3},},{{3757,78,10,3718,0},},
{{237,24,17,45,329},},{0},{0},{0},{0},{{0,40,23,0,177},},{0},{0},{{2408,89,17,2408,236},{45,21,24,3739,227,5},},{0},{{3670,85,17,2408,360},},{{3724,76,21,3767,88},
{5,27,23,5,177},},{{45,32,21,5,211},},{{19,4,24,3739,47,3},},{{3670,81,17,2408,360},},{{3,18,24,3739,183,3},},{0},{0},{0},{{42,9,18,42,239},
{28,84,21,28,159},},{{451,71,24,3739,183,451},},{{21,11,21,3,252},},{0},{{1,49,21,0,211},},{{28,80,24,3739,183,28},},{{451,67,23,451,177},},
{{0,55,21,0,159},},{{8,11,18,42,296},},{{705,71,18,705,239},{237,25,24,3739,320,5},},{{19,13,21,3,19},},{0},{0},{{3,6,25,3749,188,3},},
{{3754,63,10,3724,0},{3718,80,21,28,86},},{{19,9,24,3739,47,3},},{{5,24,16,45,193},},{0},{0},{{3749,64,15,3725,0},{3670,84,24,3739,351,28},},
{0},{0},{0},{{19,16,21,3,19},},{{3718,78,21,28,86},},{0},{{705,75,17,705,236},},{{2408,79,17,2408,236},{451,68,21,451,159},},{0},{{2094,63,25,3749,354,451},
{8,6,18,42,296},},{0},{0},{{350,18,17,42,329},{350,5,18,42,332},},{{1,45,24,3739,227,0},},{0},{{3726,49,1,2,0},},{{3670,91,24,3739,351,28},},
{{5,21,16,45,193},},{{3685,27,1,237,0},{1,41,23,0,223},},{0},{0},{{28,79,23,28,177},{3,7,16,42,193},},{{3706,24,21,5,86},},
{{0,42,24,3739,183,0},},{0},{0},{{451,77,17,705,198},{45,23,21,5,211},},{{21,18,17,42,291},{21,5,18,42,296},},{{8,18,23,3,270},},
{{3716,5,21,3,86},{2,57,23,0,316},},{{5,29,19,45,208},{1,38,24,3739,227,0},},{0},{{3718,90,21,3759,88},},{{3670,79,25,3749,354,28},},
{{1,55,25,3749,230,0},},{{237,22,21,5,304},},{{451,69,23,451,177},},{{8,9,21,3,252},},{0},{0},{{705,69,17,705,236},{21,13,21,3,252},},
{0},{{42,16,25,3749,230,3},},{{451,65,16,705,193},},{{705,65,17,705,236},},{{8,13,25,3749,281,3},{0,41,21,0,159},},{0},{{3764,61,23,3765,90},
{3725,64,23,2094,92},},{{19,11,21,3,19},},{0},{{2094,64,21,451,335},{28,78,25,3749,188,28},},{{5,26,17,45,198},},{{3685,13,1,350,0},},
{{2,39,25,3749,323,0},},{0},{{28,89,19,2408,208},},{0},{0},{0},{{3704,7,21,19,86},{28,85,19,2408,208},},{0},{{21,10,23,3,270},{0,48,24,3739,183,0},},
{{3670,78,23,28,347},},{0},{{451,66,16,705,193},{45,29,21,5,211},},{{2408,81,25,3749,230,28},{2,47,21,0,304},},{{0,52,23,0,177},},
{0},{{1,47,23,0,223},},{{2408,85,25,3749,230,28},{19,12,23,3,40},},{{350,16,25,3749,323,3},{5,19,21,5,159},},{0},{{3,9,23,3,177},},
{{237,28,21,5,304},},{0},{{5,23,24,3739,183,5},{1,43,16,1,233},},{{3759,87,1,3757,0},{42,6,25,3749,230,3},},{0},{{21,16,18,42,296},},
{{5,34,21,5,159},{5,27,24,3739,183,5},},{{3746,13,10,3716,0},},{{451,75,16,705,193},{45,32,17,45,236},},{{2408,60,23,28,223},},
{{3670,81,21,28,335},{8,3,25,3749,281,3},},{0},{0},{{2,42,23,0,316},},{0},{{28,84,25,3749,188,28},},{0},{{8,7,16,42,286},},{0},{{1,49,17,1,236},
{1,44,16,1,233},},{{3,10,17,42,198},},{{2408,80,23,28,223},},{{42,18,18,42,239},{42,13,17,42,236},},{0},{{3746,4,10,3716,0},},
{{19,13,25,3749,53,3},},{0},{{2094,66,25,3749,354,451},},{0},{{705,67,25,3749,230,451},{0,43,16,1,193},},{0},{0},{{42,5,23,3,223},},{{0,47,16,1,193},},
{0},{{350,10,25,3749,323,3},},{0},{0},{{3744,29,11,3706,0},},{{28,91,18,2408,203},},{0},{{237,21,23,5,316},},{{2408,79,21,28,211},{451,68,17,705,198},},
{{3760,58,4294967295U,3760,0,8},},{{3704,9,21,19,86},{45,27,18,45,239},},{{237,32,18,45,332},},{{705,68,23,451,223},},{{2,45,18,1,332},},
{0},{{451,64,24,3739,183,451},},{0},{{2094,69,18,705,363},},{0},{{237,26,24,3739,320,5},},{{2,49,21,0,304},},{{2094,65,18,705,363},},{{28,79,19,2408,208},},
{0},{{21,46,21,3726,246},},{{2408,91,18,2408,239},{19,6,24,3739,47,3},},{0},{{451,77,21,451,159},{45,23,17,45,236},},{0},{{3670,83,24,3739,351,28},},
{{3685,16,1,350,0},{350,9,23,3,316},},{{3,16,24,3739,183,3},},{{45,34,25,3749,230,5},},{{0,49,16,1,193},},{{3670,79,21,28,335},
{8,5,17,42,291},},{0},{{451,69,24,3739,183,451},},{0},{{8,9,17,42,291},},{0},{0},{{705,69,21,451,211},{21,13,17,42,291},},{0},{0},{0},{0},{0},{{237,27,17,45,329},
{1,42,24,3739,227,0},},{{3,4,25,3749,188,3},},{{19,11,17,42,65},{2,48,23,0,316},},{{3670,86,24,3739,351,28},{0,45,17,1,198},},
{{2094,64,17,705,360},},{{705,77,18,705,239},},{{19,18,16,42,59},{19,7,17,42,65},},{0},{0},{{28,89,23,28,177},},{{237,19,23,5,316},
{1,52,16,1,233},},{{2,43,21,0,304},},{{1,39,21,0,211},},{{42,10,18,42,239},},{{45,25,17,45,236},},{0},{0},{{237,23,16,45,326},
{1,35,24,3739,227,0},},{{45,29,17,45,236},},{{2408,81,21,28,211},{2,47,25,3749,323,0},},{{0,52,19,1,208},},{{1,47,24,3739,227,0},},
{0},{{451,62,25,3749,188,451},},{{350,16,21,3,304},{5,19,25,3749,188,5},},{{2094,67,23,451,347},},{{3,9,19,42,208},},{{0,40,24,3739,183,0},},
{{3690,40,21,0,86},},{0},{{42,6,21,3,211},{3,5,19,42,208},},{{2408,89,25,3749,230,28},{45,21,16,45,233},},{0},{{5,34,17,45,198},},
{{21,3,23,3,270},{1,36,24,3739,227,0},},{0},{{19,4,16,42,59},},{{3,18,19,42,208},},{0},{0},{{3758,78,11,3718,0},},{0},{0},{0},{{0,51,24,3739,183,0},},
{{350,6,18,42,332},},{0},{{28,80,16,2408,193},{3,10,21,3,159},},{{0,55,24,3739,183,0},},{{42,13,21,3,211},{8,11,25,3749,281,3},},
{0},{{237,25,16,45,326},},{{451,63,23,451,177},},{0},{0},{{237,29,16,45,326},{1,57,24,3739,227,0},},{{705,67,21,451,211},},{{3716,11,21,3,86},
{19,9,16,42,59},},{{5,24,24,3739,183,5},},{0},{0},{{3670,84,16,2408,357},},{{350,10,21,3,304},{5,28,24,3739,183,5},},{0},{{19,16,24,3739,47,3},
{19,5,25,3749,53,3},},{{3670,80,16,2408,357},{0,35,25,3749,188,0},},{0},{{3757,91,10,3718,0},{3702,18,20,19,0},},{{705,75,25,3749,230,451},},
{0},{0},{{3748,34,10,3706,0},},{0},{{0,39,21,0,159},},{{350,18,25,3749,323,3},},{0},{{2408,83,16,2408,233},},{{3744,21,11,3706,0},},{{3670,91,16,2408,357},},
{{5,21,24,3739,183,5},},{{45,19,25,3749,230,5},},{{2,49,17,1,329},},{{3752,19,2,3751,2},{0,57,24,3739,183,0},},{{3,7,24,3739,183,3},
{0,20,4,3752,107},},{{5,32,18,45,203},},{{19,6,23,3,40},},{{5,25,17,45,198},},{{42,4,18,42,239},},{{451,77,25,3749,188,451},
{3,3,23,3,177},},{{21,18,25,3749,281,3},},{0},{{1,38,23,0,223},},{0},{{45,34,21,5,211},{45,24,23,5,223},},{0},{{3670,79,17,2408,360},
{8,5,21,3,252},},{{237,22,24,3739,320,5},},{{2408,78,16,2408,233},},{0},{{2094,62,24,3739,351,451},},{{28,86,21,28,159},{3,12,24,3739,183,3},},
{0},{{2,44,23,0,316},},{0},{{42,16,17,42,236},},{{3726,45,1,2,0},{451,65,24,3739,183,451},},{{3739,79,13,3670,0},{705,65,25,3749,230,451},},
{{5,22,19,45,208},},{{237,27,21,5,304},},{{3,4,21,3,159},},{{2408,86,23,28,223},},{{0,45,21,0,159},},{0},{0},{{19,7,21,3,19},},
{0},{{2094,76,21,3767,339},},{{237,19,24,3739,320,5},{21,6,17,42,291},},{0},{{19,3,24,3739,47,3},{2,43,17,1,329},},{{1,39,25,3749,230,0},},
{0},{{45,25,21,5,211},},{{3670,78,24,3739,351,28},},{0},{0},{{451,66,24,3739,183,451},},{{2408,81,17,2408,236},},{{28,81,18,2408,203},{3,13,17,42,198},},
{0},{{237,24,24,3739,320,5},},{{2408,85,17,2408,236},{451,62,21,451,159},},{{350,16,17,42,329},},{0},{{705,66,18,705,239},{237,28,24,3739,320,5},},
{{3670,89,23,28,347},},{{2,55,18,1,332},},{{5,23,16,45,193},{1,43,24,3739,227,0},},{{42,6,17,42,236},{3,5,23,3,177},},
{0},{{3670,85,24,3739,351,28},},{{3690,49,21,0,86},{5,27,16,45,193},},{0},{{451,75,24,3739,183,451},{45,32,25,3749,230,5},},{{3670,81,24,3739,351,28},
{2094,75,18,705,363},},{{3,18,23,3,177},},{0},{0},{0},{{42,9,21,3,211},{28,84,18,2408,203},},{{451,71,17,705,198},},{0},{{8,7,24,3739,276,3},
{0,36,23,0,177},},{0},{{1,49,25,3749,230,0},{1,44,24,3739,227,0},},{{2408,80,24,3739,227,28},},{{3748,21,10,3706,0},},{{42,13,25,3749,230,3},
{8,11,21,3,252},},{{3724,64,21,451,86},{1,40,24,3739,227,0},},{0},{0},{{2094,66,18,705,363},},{{3,6,16,42,193},},{0},{{705,67,17,705,236},
{0,43,24,3739,183,0},},{{5,24,23,5,177},},{0},{0},{{21,4,18,42,296},{0,47,24,3739,183,0},},{0},{{350,10,17,42,329},},{0},{0},{{0,35,21,0,159},},
{{2094,74,21,3756,343},},{0},{{2408,79,24,3739,227,28},},{{3724,75,21,451,86},{2,41,25,3749,323,0},},{{2094,63,16,705,357},},{0},{{3706,32,21,5,86},},
{{350,5,21,3,304},{2,45,25,3749,323,0},},{{1,45,17,1,236},},{{3704,13,21,19,86},{3,11,16,42,193},},{{451,64,16,705,193},
{45,31,21,3744,219},},{{705,64,23,451,223},},{{8,10,23,3,270},},{{237,26,23,5,316},},{0},{0},{0},{0},{{0,42,17,1,198},},{{2408,91,25,3749,230,28},},
{{5,25,21,5,159},},{{2094,77,23,451,347},},{{3704,58,21,19,86},{45,23,25,3749,230,5},},{{8,18,16,42,286},},{0},{{5,29,24,3739,183,5},},
{{28,90,21,3759,165},{3,16,16,42,193},},{{45,34,17,45,236},},{{0,49,24,3739,183,0},},{{1,55,18,1,239},},{{21,9,23,3,270},},
{{451,69,16,705,193},},{0},{{8,9,25,3749,281,3},},{0},{0},{{3685,5,1,350,0},{350,4,23,3,316},},{0},{{42,16,21,3,211},},{0},{{3670,90,21,3759,339},
{8,13,16,42,286},},{{5,22,23,5,177},{2,35,25,3749,323,0},},{{237,27,25,3749,323,5},{1,42,16,1,233},},{{3,4,17,42,198},},
{{19,11,25,3749,53,3},},{{42,7,17,42,236},{28,78,18,2408,203},},{{5,26,24,3739,183,5},},{0},{{19,18,24,3739,47,3},{19,7,25,3749,53,3},},
{{2,52,18,1,332},{2,39,21,0,304},},{0},{{21,6,21,3,252},},{0},{{19,46,21,3726,12},},{0},{0},{{0,48,17,1,198},},{{8,4,16,42,286},},
{0},{{237,23,24,3739,320,5},{1,48,23,0,223},},{{45,29,25,3749,230,5},},{0},{{3,13,21,3,159},},{{1,47,16,1,233},},{0},{{2408,85,21,28,211},},
{0},{{3,9,24,3739,183,3},},{0},{0},{0},{{3,5,24,3739,183,3},},{0},{{21,16,25,3749,281,3},{0,44,16,1,193},},{0},{{3702,4,20,19,0},{5,34,25,3749,188,5},},
{0},{{350,11,17,42,329},},{0},{0},{0},{{21,7,18,42,296},},{{5,31,21,3744,171},},{{42,9,17,42,236},},{{451,71,21,451,159},{45,26,18,45,239},},
{{21,11,18,42,296},},{0},{{3685,22,1,237,0},{1,44,23,0,223},},{{3,10,24,3739,183,3},},{{451,67,24,3739,183,451},},{{0,55,16,1,193},},
{{8,11,17,42,291},},{{3702,11,20,19,0},},{{451,63,24,3739,183,451},{19,13,18,42,71},},{{3724,62,21,451,86},{3690,56,21,3762,88},},
{0},{0},{{237,29,24,3739,320,5},{1,57,16,1,233},},{0},{{5,24,19,45,208},},{0},{{3725,66,23,2094,92},},{{3748,29,10,3706,0},},{0},{0},{0},{{19,16,16,42,59},
{19,5,17,42,65},},{{3670,80,24,3739,351,28},},{0},{{21,8,21,3685,242},},{{3716,6,21,3,86},{451,68,24,3739,183,451},},{{2,41,21,0,304},},
{{8,6,23,3,270},},{0},{{0,50,25,3749,188,0},{0,39,24,3739,183,0},},{{350,18,18,42,332},{350,5,17,42,329},},{{1,45,21,0,211},},
{{28,83,19,2408,208},},{{2408,83,24,3739,227,28},},{{2094,69,21,451,335},{8,10,24,3739,276,3},},{{5,21,21,5,159},},{{1,41,24,3739,227,0},},
{0},{{19,10,23,3,40},{2,49,25,3749,323,0},},{{3726,42,1,2,0},{0,57,16,1,193},},{0},{{0,42,21,0,159},},{{2408,91,21,28,211},},
{{5,25,25,3749,188,5},},{0},{{21,5,23,3,270},},{{3670,83,23,28,347},{705,62,25,3749,230,451},},{0},{0},{{42,11,18,42,239},},{{0,49,23,0,177},},
{{8,5,24,3739,276,3},},{0},{{237,22,16,45,326},},{{2408,78,24,3739,227,28},{45,28,23,5,223},},{{2,40,23,0,316},},{{3,12,23,3,177},},
{{1,51,25,3749,230,0},},{{705,69,18,705,239},},{0},{0},{{451,65,21,451,159},},{{705,65,18,705,239},},{{2094,68,23,451,347},{0,41,24,3739,183,0},},
{{2,35,21,0,304},},{0},{{2,48,16,1,326},},{{0,45,24,3739,183,0},},{{42,7,21,3,211},},{{3702,5,20,19,0},},{0},{0},{0},{0},{{21,6,25,3749,281,3},
{1,52,23,0,223},},{0},{{3716,17,21,3761,88},{2,43,25,3749,323,0},},{{3,17,21,3761,165},},{0},{{0,48,21,0,159},},{{3670,78,16,2408,357},
{0,37,9,3763,137},},{{350,7,18,42,332},},{0},{{2,47,16,1,326},},{{0,52,24,3739,183,0},},{{3,13,25,3749,188,3},},{0},{{237,34,18,45,332},
{237,24,16,45,326},},{{350,3,25,3749,323,3},},{0},{0},{0},{0},{{1,43,21,0,211},},{0},{{2408,89,16,2408,233},{45,21,25,3749,230,5},},{{21,16,21,3,252},},
{{3670,85,16,2408,357},{8,16,23,3,270},},{0},{{451,75,21,451,159},},{{2408,60,24,3739,227,28},{350,11,21,3,304},},{{3670,81,16,2408,357},},
{0},{0},{{2,42,16,1,326},},{0},{0},{{451,71,25,3749,188,451},},{0},{{3690,36,21,0,86},},{{1,49,18,1,239},},{{28,80,25,3749,188,28},},{{2408,80,16,2408,233},},
{{3718,84,21,28,86},},{0},{{237,25,25,3749,323,5},},{{2408,84,16,2408,233},},{0},{{8,15,21,3741,264},},{{3,6,24,3739,183,3},},{{0,43,23,0,177},},
{{19,9,25,3749,53,3},},{{3741,4,11,3716,0},},{{42,5,18,42,239},},{{3751,46,21,3726,81},{45,22,23,5,223},},{{3670,84,25,3749,354,28},},
{{5,28,23,5,177},},{0},{0},{{19,5,21,3,19},},{{28,91,17,2408,198},},{0},{{705,75,18,705,239},{237,21,24,3739,320,5},},{{2408,79,16,2408,233},},
{0},{{2094,63,24,3739,351,451},},{{237,32,21,5,304},},{0},{{2,45,17,1,329},},{{1,45,25,3749,230,0},},{{28,83,23,28,177},{3,11,24,3739,183,3},},
{{0,54,21,3743,171},},{{2094,69,17,705,360},},{{5,21,17,45,198},},{0},{{45,19,21,5,211},},{{2094,65,17,705,360},},{{3,7,17,42,198},},
{{5,32,25,3749,188,5},},{{0,42,25,3749,188,0},},{{2408,91,17,2408,236},},{{350,13,18,42,332},},{{451,77,18,705,203},},{{21,18,16,42,286},},
{{705,62,21,451,211},{8,18,24,3739,276,3},},{{350,9,18,42,332},{2,36,23,0,316},},{{5,29,16,45,193},},{{19,17,21,3761,26},},
{{0,49,19,1,208},},{{3670,79,24,3739,351,28},},{0},{0},{{2,40,24,3739,320,0},},{0},{0},{{1,51,21,0,211},},{{21,13,18,42,296},{0,38,24,3739,183,0},},
{{19,15,21,3741,33},},{{42,3,21,3,211},},{{451,65,17,705,198},},{0},{{8,13,24,3739,276,3},},{0},{0},{{2408,86,24,3739,227,28},{19,11,18,42,71},},
{{3670,86,21,28,335},{3670,60,23,28,347},},{{42,7,25,3749,230,3},{8,17,21,3761,258},},{{5,26,16,45,193},},{{19,7,18,42,71},},
{{2,39,24,3739,320,0},},{0},{{28,89,18,2408,203},},{0},{{705,63,23,451,223},},{{3702,58,20,19,0},},{{3704,18,21,19,86},{28,85,18,2408,203},},
{{45,25,18,45,239},},{{0,48,25,3749,188,0},},{{8,4,24,3739,276,3},},{{237,23,21,5,304},},{{451,66,23,451,177},{45,29,18,45,239},},
{{2408,81,24,3739,227,28},},{0},{{3739,85,13,3670,0},{2094,71,18,705,363},},{0},{{3685,25,1,237,0},{2408,85,24,3739,227,28},},{{3724,65,21,451,86},
{2,51,25,3749,323,0},},{{2094,67,18,705,363},{8,12,23,3,270},},{{3,9,16,42,193},},{{3706,26,21,5,86},},{{350,15,21,3741,312},
{2,55,25,3749,323,0},},{{5,23,25,3749,188,5},{1,43,17,1,236},},{{3,5,16,42,193},},{{45,21,21,5,211},},{{21,16,17,42,291},
{0,44,24,3739,183,0},},{{5,27,25,3749,188,5},},{0},{{451,75,17,705,198},{45,32,16,45,233},},{{350,11,25,3749,323,3},{19,4,23,3,40},},
{{28,59,12,3760,94},{8,3,24,3739,276,3},},{0},{0},{0},{0},{{42,9,25,3749,230,3},},{0},{0},{0},{0},{{28,80,21,28,159},{3,10,16,42,193},},{{451,67,16,705,193},},
{{42,13,16,42,233},},{{1,40,23,0,223},},{{705,71,23,451,223},},{{451,63,16,705,193},},{{2,50,23,0,316},},{{3,6,23,3,177},},
{{237,29,21,5,304},},{{0,43,19,1,208},},{{3685,11,1,350,0},{19,9,21,3,19},},{0},{0},{{21,4,25,3749,281,3},{0,47,19,1,208},},
{0},{0},{0},{{3704,5,21,19,86},},{{3670,80,21,28,335},},{{28,91,21,28,159},},{0},{0},{{451,68,16,705,193},},{{2094,63,23,451,347},},{0},{{237,32,17,45,329},
{21,12,21,3,252},},{0},{{350,5,25,3749,323,3},{2,45,21,0,304},},{0},{{2408,83,23,28,223},},{0},{{8,10,16,42,286},},{0},{0},{0},{{2094,65,21,451,335},},
{{28,79,18,2408,203},{3,7,21,3,159},},{{5,32,21,5,159},},{{21,1,23,3702,301},},{{5,25,18,45,203},},{{42,4,23,3,223},},
{{45,23,18,45,239},{3,3,24,3739,183,3},},{{3706,28,21,5,86},},{0},{{2,57,18,1,332},},{0},{{45,34,24,3739,227,5},},{0},{{8,5,16,42,286},},
{0},{{2408,78,21,28,211},{451,69,25,3749,188,451},},{{3742,42,10,3690,0},},{{2094,62,21,451,335},{8,9,16,42,286},},{0},{0},{{350,4,16,42,326},},
{0},{0},{0},{{3739,80,13,3670,0},},{0},{{237,27,18,45,332},},{{3,4,24,3739,183,3},},{{2,48,24,3739,320,0},},{{3670,86,25,3749,354,28},{0,45,16,1,193},},
{{2094,64,18,705,363},},{0},{{19,18,23,3,40},},{{3690,50,21,0,86},},{0},{0},{{705,63,24,3739,227,451},},{0},{0},{0},{0},{{21,10,18,42,296},},{{3724,69,21,451,86},},
{{237,23,17,45,329},{1,35,25,3749,230,0},},{{3704,11,21,19,86},},{{2,47,24,3739,320,0},},{{0,52,16,1,193},},{{1,47,25,3749,230,0},},
{{237,34,25,3749,323,5},},{{3716,12,21,3,86},{451,62,24,3739,183,451},},{{2,51,21,0,304},},{0},{{705,66,17,705,236},},{{3670,89,18,2408,363},
{0,40,25,3749,188,0},},{0},{{5,23,21,5,159},},{{42,6,18,42,239},},{{2408,89,24,3739,227,28},{45,21,17,45,236},},{{8,16,24,3739,276,3},},
{{5,34,16,45,193},},{{21,3,24,3739,276,3},{1,36,23,0,223},},{0},{{2,38,24,3739,320,0},},{{3,18,18,42,203},},{0},{0},{{2,42,24,3739,320,0},},
{0},{{451,71,18,705,203},{45,26,21,5,211},},{0},{{8,7,23,3,270},{0,36,24,3739,183,0},},{0},{0},{{28,80,17,2408,198},},{0},{{42,18,23,3,223},
{8,11,24,3739,276,3},},{0},{{237,25,17,45,329},},{{2408,84,24,3739,227,28},},{{2094,66,23,451,347},},{{3,6,19,42,208},},{{237,29,17,45,329},
{1,57,25,3749,230,0},},{0},{{19,9,17,42,65},},{{42,5,25,3749,230,3},},{{3,2,0,3704,97},},{{0,47,23,0,177},},{{3670,84,17,2408,360},},
{{350,10,18,42,332},},{0},{0},{{3670,80,17,2408,360},{0,35,24,3739,183,0},},{{28,91,25,3749,188,28},},{0},{{237,21,16,45,326},},{{3690,52,21,0,86},},
{{8,6,24,3739,276,3},},{{45,27,23,5,223},},{{21,12,25,3749,281,3},},{{705,68,18,705,239},{0,50,21,0,159},},{{1,45,18,1,239},},
{{3,11,21,3,159},},{0},{{705,64,18,705,239},},{{3670,91,23,28,347},{2094,69,25,3749,354,451},},{{3690,42,21,0,86},{5,21,25,3749,188,5},},
{0},{{2,49,16,1,326},},{{2094,65,25,3749,354,451},{0,57,23,0,177},},{{3,7,25,3749,188,3},},{{5,32,17,45,198},},{{3716,10,21,3,86},},
{{350,13,25,3749,323,3},},{0},{0},{{21,18,24,3739,276,3},},{{350,9,25,3749,323,3},},{0},{{42,11,25,3749,230,3},},{0},{{3761,14,1,3746,0},},{{3670,79,16,2408,357},},
{{21,9,16,42,286},},{{2408,78,17,2408,236},},{0},{{2094,62,25,3749,354,451},},{{42,15,21,3741,219},},{{0,38,21,0,159},},{{350,17,21,3761,308},
{2,44,16,1,326},},{{3702,51,20,19,0},},{{42,16,18,42,239},},{{3726,48,1,2,0},{451,65,25,3749,188,451},},{{2094,68,16,705,357},},
{{5,22,18,45,203},},{0},{0},{0},{{0,56,21,3762,165},},{0},{{705,77,23,451,223},},{0},{{2,52,23,0,316},},{0},{{237,19,25,3749,323,5},{21,6,16,42,286},},
{0},{{19,3,25,3749,53,3},{2,43,16,1,326},},{0},{{42,10,23,3,223},},{{0,48,18,1,203},},{{3670,78,25,3749,354,28},{8,4,21,3,252},},
{{350,7,25,3749,323,3},},{{1,48,18,1,239},{1,35,21,0,211},},{0},{{2408,81,16,2408,233},},{{28,81,17,2408,198},{3,13,18,42,203},},
{0},{{237,34,21,5,304},{237,24,23,5,316},},{{2408,85,16,2408,233},},{{350,16,18,42,332},{350,3,21,3,304},},{{3739,81,13,3670,0},
{3725,77,23,2094,92},},{{705,66,21,451,211},},{0},{{2,55,17,1,329},},{{5,23,17,45,198},{1,43,25,3749,230,0},},{{2408,89,23,28,223},},
{{0,44,21,0,159},},{0},{{3690,44,21,0,86},{5,27,17,45,198},},{0},{{451,75,25,3749,188,451},{45,32,24,3739,227,5},},{{2094,75,17,705,360},
{8,3,23,3,270},},{0},{0},{{21,7,23,3,270},},{0},{{28,84,19,2408,208},},{{45,26,17,45,236},},{0},{{0,51,23,0,177},},{{350,6,23,3,316},},
{{3704,51,21,19,86},},{{2408,80,25,3749,230,28},},{{3726,47,1,2,0},},{{42,13,24,3739,227,3},},{0},{{237,25,21,5,304},},{{2,50,24,3739,320,0},},
{0},{0},{{1,57,21,0,211},},{{705,67,18,705,239},},{0},{0},{{2408,88,21,3758,219},},{{21,4,17,42,291},},{{3670,84,21,28,335},},{0},{0},{0},{0},{0},{0},{0},{{19,4294967295U,4294967295U,8,2,8},
{2,41,24,3739,320,0},},{0},{0},{{237,32,25,3749,323,5},},{{350,18,23,3,316},{2,45,24,3739,320,0},},{{1,50,21,0,211},},{{3725,75,23,2094,92},
{3,11,17,42,198},},{0},{0},{{3762,53,1,3742,0},},{0},{0},{{19,10,18,42,71},},{{0,57,19,1,208},},{0},{{705,76,21,3767,215},{0,42,18,1,203},},
{{2408,91,24,3739,227,28},{19,6,18,42,71},},{{350,13,21,3,304},},{0},{0},{{3670,83,18,2408,363},{8,18,17,42,291},},{{2,57,25,3749,323,0},
{2,36,24,3739,320,0},},{{5,29,25,3749,188,5},},{{42,11,21,3,211},{3,16,19,42,208},},{{45,34,16,45,233},{45,24,18,45,239},},
{0},{0},{0},{{451,69,17,705,198},},{0},{{8,9,24,3739,276,3},},{0},{{3718,60,21,28,86},},{{3758,91,11,3718,0},{350,4,24,3739,320,3},},{0},{{42,3,25,3749,230,3},},
{{705,65,23,451,223},},{{8,13,23,3,270},},{{2,35,24,3739,320,0},},{0},{{28,60,23,28,177},{3,4,16,42,193},},{0},{{42,7,16,42,233},
{28,78,19,2408,208},},{0},{{237,31,21,3744,312},},{0},{{350,12,23,3,316},},{{28,89,25,3749,188,28},},{0},{{705,63,16,705,233},},{{3754,77,10,3724,0},
{19,3,21,3,19},},{0},{0},{{3718,89,21,28,86},{21,10,25,3749,281,3},},{{8,4,17,42,291},},{{350,7,21,3,304},},{{237,23,25,3749,323,5},},
{0},{0},{{2094,71,25,3749,354,451},{28,81,21,28,159},},{{1,47,17,1,236},},{{237,34,17,45,329},},{0},{{2094,67,25,3749,354,451},},{{3,9,25,3749,188,3},},
{{705,66,25,3749,230,451},},{{3766,30,1,3748,0},},{{2,55,21,0,304},},{{3,5,25,3749,188,3},},{{19,8,21,3685,7},},{{21,16,24,3739,276,3},
{0,44,17,1,198},},{{3670,85,23,28,347},{8,16,16,42,286},},{{5,34,24,3739,183,5},{5,27,21,5,159},},{{45,32,23,5,223},},
{{350,11,16,42,326},{2,38,21,0,304},},{{2094,75,21,451,335},},{{3739,89,13,3670,0},},{0},{0},{0},{{42,9,16,42,233},{28,84,23,28,177},},
{0},{{3706,22,21,5,86},},{0},{{1,49,23,0,223},},{0},{{451,67,25,3749,188,451},},{{0,55,19,1,208},},{{8,11,16,42,286},},{{705,71,16,705,233},},
{{2408,84,21,28,211},{451,63,25,3749,188,451},},{0},{{3670,88,21,3758,343},},{0},{{237,29,25,3749,323,5},{1,57,17,1,236},},{0},{{5,24,18,45,203},},
{{42,5,17,42,236},},{{3725,63,23,2094,92},{45,22,18,45,239},},{{21,4,21,3,252},},{0},{{3706,29,21,5,86},{3685,34,1,237,0},},
{{45,33,21,3766,215},},{{19,5,18,42,71},},{{3670,80,25,3749,354,28},},{{1,54,21,3743,219},},{{705,75,23,451,223},},{0},{0},{{8,6,16,42,286},},
{{3,15,21,3741,171},},{0},{{350,5,16,42,326},},{{3724,71,21,451,86},{1,50,25,3749,230,0},},{{42,12,23,3,223},{28,83,18,2408,203},},
{{451,64,23,451,177},},{{8,10,25,3749,281,3},},{{5,21,18,45,203},},{{237,26,18,45,332},{1,41,25,3749,230,0},},{0},{{2,49,24,3739,320,0},},
{{28,79,21,28,159},{3,7,18,42,203},},{0},{0},{0},{{350,13,17,42,329},},{{2094,77,18,705,363},},{{21,18,23,3,270},},{{705,62,24,3739,227,451},
{8,18,21,3,252},},{{350,9,17,42,329},{2,57,21,0,304},},{{5,29,21,5,159},},{{42,11,17,42,236},{3,16,23,3,177},},
{0},{0},{{1,55,23,0,223},},{{21,9,24,3739,276,3},},{{2408,78,25,3749,230,28},{451,69,21,451,159},},{{8,9,23,3,270},},{{3743,57,11,3690,0},},
{0},{{21,13,23,3,270},},{{2,44,24,3739,320,0},},{0},{0},{0},{{2094,68,24,3739,351,451},{0,41,23,0,177},},{0},{{1,42,23,0,223},},{{19,11,23,3,40},
{2,48,17,1,329},},{0},{{28,78,23,28,177},},{{3724,77,21,451,86},{5,26,23,5,177},},{0},{{350,12,24,3739,320,3},},{0},{0},{{21,6,24,3739,276,3},},
{0},{{3716,4,21,3,86},{2,43,24,3739,320,0},},{{42,10,24,3739,227,3},{28,85,21,28,159},},{0},{{21,10,21,3,252},},{{3670,78,17,2408,360},
{0,37,8,3763,129},},{{350,7,17,42,329},},{{451,66,18,705,203},{45,29,23,5,223},},{{2,47,23,0,316},},{{8,8,21,3685,242},
{0,52,25,3749,188,0},},{{2094,71,21,451,335},{28,81,25,3749,188,28},},{{1,47,21,0,211},},{{3685,6,1,350,0},{19,12,21,3,19},},
{{350,3,24,3739,320,3},},{{8,12,24,3739,276,3},},{{3726,44,1,2,0},{3,9,21,3,159},},{{237,28,23,5,316},},{{0,40,21,0,159},},
{0},{{3725,65,23,2094,92},},{0},{0},{0},{0},{{451,75,18,705,203},},{{2408,60,25,3749,230,28},},{{3718,79,21,28,86},{2094,75,25,3749,354,451},},{0},{0},{{3716,16,21,3,86},
{2,42,17,1,329},},{0},{0},{{45,26,25,3749,230,5},},{{21,11,23,3,270},},{{350,6,24,3739,320,3},},{{1,44,18,1,239},},{{3,10,19,42,208},},
{{2408,80,17,2408,236},{451,67,21,451,159},},{{3756,63,11,3724,0},{0,55,23,0,177},},{0},{0},{{2408,84,17,2408,236},{19,13,23,3,40},},
{0},{0},{{3706,25,21,5,86},},{0},{0},{0},{{42,5,21,3,211},},{0},{0},{0},{0},{0},{{19,16,23,3,40},},{{28,91,16,2408,193},},{0},{{237,21,25,3749,323,5},},{{451,68,23,451,177},},
{0},{{45,27,16,45,233},},{0},{{705,68,25,3749,230,451},},{{2,45,16,1,326},},{0},{{3,11,25,3749,188,3},},{{705,64,25,3749,230,451},},{{2094,69,16,705,357},},
{0},{{1,41,21,0,211},},{0},{{2094,65,16,705,357},},{{28,79,17,2408,198},},{{5,32,24,3739,183,5},},{0},{{2408,91,16,2408,233},},{0},{{3739,91,13,3670,0},
{45,23,23,5,223},},{{3765,59,14,3760,0},{21,5,16,42,286},},{{8,18,25,3749,281,3},{0,46,21,3726,145},},{{350,9,21,3,304},
{2,57,17,1,329},},{{5,29,17,45,198},},{0},{{0,49,18,1,203},},{{3670,79,23,28,347},},{{3690,38,21,0,86},},{{237,22,23,5,316},},
{{2,40,25,3749,323,0},},{0},{0},{0},{{705,69,23,451,223},{0,38,25,3749,188,0},},{0},{0},{{451,65,18,705,203},},{0},{0},{0},{{28,60,24,3739,183,28},},{{2408,86,25,3749,230,28},
{2,48,21,0,304},},{{3670,60,24,3739,351,28},{0,45,19,1,208},},{{2094,64,23,451,347},{42,7,24,3739,227,3},},{{5,26,19,45,208},},
{{19,18,18,42,71},},{{3690,45,21,0,86},{2,52,24,3739,320,0},},{0},{{28,89,17,2408,198},},{{237,19,21,5,304},{1,52,18,1,239},},
{{3746,18,10,3716,0},{2,43,23,0,316},},{0},{{28,85,17,2408,198},},{0},{{21,10,17,42,291},},{{3670,78,21,28,335},{8,4,25,3749,281,3},},
{{1,48,25,3749,230,0},},{0},{{2408,81,23,28,223},},{{0,52,21,0,159},},{{2094,71,17,705,360},},{0},{0},{{5,19,23,5,177},{2,51,24,3739,320,0},},
{{2094,67,17,705,360},},{{3,9,17,42,198},},{{3670,89,17,2408,360},},{{2,55,24,3739,320,0},},{{1,56,21,3762,215},{1,43,18,1,239},},
{{42,6,23,3,223},{3,5,17,42,198},},{{45,21,18,45,239},},{{21,16,16,42,286},{0,44,25,3749,188,0},},{{5,34,23,5,177},
{5,8,21,3685,151},},{{21,3,21,3,252},},{0},{{2408,60,21,28,211},{350,11,24,3739,320,3},},{{3670,81,23,28,347},},{0},{{21,7,24,3739,276,3},},
{{2,42,21,0,304},},{0},{{42,9,24,3739,227,3},{3,52,0,3704,97},},{{21,11,24,3739,276,3},},{{3749,71,15,3725,0},{8,7,18,42,296},},
{0},{0},{{28,80,18,2408,203},{3,10,23,3,177},},{{2408,80,21,28,211},{451,67,17,705,198},},{{42,18,16,42,233},},{0},{{705,71,24,3739,227,451},
{237,25,18,45,332},},{{451,63,17,705,198},},{0},{0},{{237,29,18,45,332},},{{0,43,18,1,203},},{0},{0},{{451,76,21,3767,165},{45,22,25,3749,230,5},},
{{21,4,24,3739,276,3},{0,47,18,1,203},},{0},{{350,10,23,3,316},},{0},{{3704,16,21,19,86},},{0},{0},{0},{{237,21,21,5,304},},{{2408,79,23,28,223},},
{0},{0},{{237,32,16,45,326},},{{705,68,21,451,211},},{{3685,23,1,237,0},{350,5,24,3739,320,3},},{{28,83,25,3749,188,28},},{0},{{3718,83,21,28,86},},
{{3670,91,18,2408,363},{8,10,17,42,291},},{{3724,67,21,451,86},},{0},{{19,10,25,3749,53,3},{2,49,23,0,316},},{0},{0},{{21,4294967295U,4294967295U,8,1,8},},
{0},{{5,25,19,45,208},},{{2094,77,25,3749,354,451},{42,4,16,42,233},},{{451,77,23,451,177},{3,3,25,3749,188,3},},{0},{0},{{1,38,21,0,211},},
{{3725,71,23,2094,92},{3704,4,21,19,86},},{{45,24,25,3749,230,5},},{0},{{8,5,23,3,270},},{0},{{45,28,25,3749,230,5},},{0},{0},{0},{0},{{350,4,17,42,329},
{2,44,21,0,304},},{0},{0},{0},{0},{{3690,41,21,0,86},{5,22,17,45,198},},{{3685,9,1,350,0},},{0},{{2408,86,21,28,211},{2,48,25,3749,323,0},},
{{0,45,23,0,177},},{0},{{705,77,16,705,233},},{{19,7,23,3,40},},{0},{0},{{28,89,21,28,159},},{{705,63,25,3749,230,451},},{0},{{1,39,23,0,223},},
{{42,10,16,42,233},},{{45,25,23,5,223},},{0},{0},{{3706,23,21,5,86},{237,23,18,45,332},},{0},{0},{{0,52,17,1,198},},{0},{{237,34,24,3739,320,5},},
{{451,62,23,451,177},},{{350,16,23,3,316},},{{2094,67,21,451,335},},{{705,66,16,705,233},},{{3670,89,21,28,335},},{0},{0},{{3,5,21,3,159},},
{0},{{8,16,25,3749,281,3},},{{5,34,19,45,208},},{{21,3,25,3749,281,3},},{0},{{19,4,18,42,71},{2,38,25,3749,323,0},},{{3,18,17,42,198},},
{0},{0},{{2,42,25,3749,323,0},},{0},{0},{0},{{0,36,25,3749,188,0},},{{350,6,16,42,326},},{0},{0},{0},{{42,13,23,3,223},},{0},{{3685,26,1,237,0},},{{2408,84,25,3749,230,28},
{451,63,21,451,159},},{0},{{3,6,18,42,203},},{0},{{705,67,23,451,223},},{{19,9,18,42,71},},{{42,5,24,3739,227,3},},{0},{0},{{3670,84,18,2408,363},},
{{3690,48,21,0,86},},{{3751,8,21,3685,4},},{0},{{3670,80,18,2408,363},},{{28,91,24,3739,183,28},},{0},{{237,21,17,45,329},},{0},{{2094,63,18,705,363},
{8,6,25,3749,281,3},},{{45,27,24,3739,227,5},},{{21,12,24,3739,276,3},},{{705,68,17,705,236},{0,39,23,0,177},},{0},{{42,12,24,3739,227,3},
{3,11,18,42,203},},{{2408,83,18,2408,239},},{{3739,78,13,3670,0},{705,64,17,705,236},},{{2094,69,24,3739,351,451},{8,10,21,3,252},},
{{237,26,21,5,304},},{0},{0},{{2094,65,24,3739,351,451},},{{28,79,25,3749,188,28},},{{5,32,16,45,193},},{{19,6,21,3,19},},{{350,13,24,3739,320,3},
{5,25,23,5,177},},{{2094,77,21,451,335},{8,1,23,3702,301},},{{3,3,21,3,159},},{{21,5,24,3739,276,3},},{{350,9,24,3739,320,3},},
{0},{{42,11,24,3739,227,3},},{{45,34,23,5,223},{45,24,21,5,211},},{0},{{1,55,16,1,233},},{{21,9,17,42,291},},{{2408,78,18,2408,239},},
{{3716,18,21,3,86},},{0},{{28,86,23,28,177},},{{705,69,24,3739,227,451},},{{350,4,21,3,304},{2,44,17,1,329},},{0},{0},{0},{{2094,68,17,705,360},
{8,13,18,42,296},},{{5,22,21,5,159},},{{237,27,23,5,316},},{{3,4,23,3,177},},{0},{{28,78,16,2408,193},},{0},{0},{0},{{2,52,16,1,326},
{2,39,23,0,316},},{0},{{3706,19,21,5,86},},{0},{0},{0},{{28,85,25,3749,188,28},},{{0,48,19,1,208},},{{8,4,18,42,296},{0,37,7,3763,121},},
{{350,7,24,3739,320,3},},{{1,48,17,1,236},},{0},{{3,13,0,3704,97},},{{28,81,16,2408,193},{3,13,19,42,208},},{0},{0},{{2408,85,23,28,223},
{19,12,25,3749,53,3},},{0},{0},{0},{{3670,89,25,3749,354,28},},{{2,55,16,1,326},},{{5,23,18,45,203},},{0},{{0,44,18,1,203},},{0},{{5,27,18,45,203},},
{0},{0},{{2094,75,16,705,357},},{{8,4294967295U,4294967295U,8,0,8},{3,18,21,3,159},},{0},{{705,74,21,3756,219},{21,7,16,42,286},},{0},{{42,9,23,3,223},
{28,84,16,2408,193},},{{451,71,23,451,177},{45,26,16,45,233},},{{3706,33,21,3766,88},{21,11,16,42,286},},{{0,36,21,0,159},},
{0},{0},{{3756,77,11,3724,0},{3716,3,21,3,86},},{0},{{42,18,24,3739,227,3},{8,11,23,3,270},},{0},{{19,13,16,42,59},},{{2,50,25,3749,323,0},},
{{2094,66,16,705,357},},{0},{{1,57,18,1,239},},{0},{{5,24,21,5,159},},{0},{{45,22,17,45,236},},{{21,4,16,42,286},},{0},{0},{0},{0},{{0,35,23,0,177},},
{0},{0},{{19,1,23,3702,77},},{{3690,39,21,0,86},},{{8,6,21,3,252},},{0},{{237,32,24,3739,320,5},},{{350,5,23,3,316},},{{1,45,23,0,223},},
{{42,17,21,3761,215},{28,83,17,2408,198},},{{451,64,18,705,203},},{{705,64,21,451,211},},{{5,21,23,5,177},},{{237,26,17,45,329},},
{0},{{19,10,17,42,65},},{{0,57,18,1,203},},{0},{{0,42,19,1,208},},{{3741,18,11,3716,0},{19,6,17,42,65},},{0},{{2094,77,17,705,360},
{42,4,24,3739,227,3},},{{3725,67,23,2094,92},{3704,0,21,19,86},},{{3670,83,17,2408,360},{8,18,18,42,296},},{{2,57,24,3739,320,0},
{2,36,25,3749,323,0},},{0},{{3,16,18,42,203},},{{45,24,17,45,236},},{0},{0},{{21,9,21,3,252},},{{451,69,18,705,203},},{{2,40,21,0,304},},
{{28,86,24,3739,183,28},{3,12,21,3,159},},{0},{{21,13,24,3739,276,3},},{{350,4,25,3749,323,3},},{0},{{42,16,23,3,223},{42,3,24,3739,227,3},},
{0},{{2094,68,21,451,335},},{{5,22,25,3749,188,5},{2,35,23,0,316},},{{1,42,18,1,239},},{{3,4,19,42,208},},{0},{{2094,64,24,3739,351,451},
{42,7,23,3,223},},{0},{{705,77,24,3739,227,451},},{{2408,90,21,3759,215},},{0},{{28,89,24,3739,183,28},},{{21,6,23,3,270},{1,52,25,3749,230,0},},
{{705,63,17,705,236},},{0},{0},{{45,25,24,3739,227,5},},{{21,10,24,3739,276,3},{0,48,23,0,177},},{{3670,78,18,2408,363},},{0},{{1,48,21,0,211},},
{{2,47,18,1,332},},{0},{{2094,71,24,3739,351,451},{3,13,23,3,177},},{{1,47,18,1,239},},{{237,34,16,45,326},{237,24,18,45,332},},
{{3724,63,21,451,86},{3690,57,21,0,86},},{{2094,67,24,3739,351,451},},{0},{{705,66,24,3739,227,451},},{{3718,81,21,28,86},},{{3685,29,1,237,0},},
{0},{{2408,89,18,2408,239},},{{21,16,23,3,270},},{{8,16,17,42,291},},{0},{{3767,73,1,3754,0},{451,75,23,451,177},},{{350,11,23,3,316},
{19,4,25,3749,53,3},},{{3752,51,2,3751,2},},{{3,18,25,3749,188,3},},{0},{{3716,7,21,3,86},{2,42,18,1,332},},{0},{0},{{3704,6,21,19,86},},
{0},{0},{{1,44,21,0,211},},{0},{{2408,80,18,2408,239},},{{0,55,18,1,203},},{0},{{705,71,17,705,236},{21,15,21,3741,264},},{{2408,84,18,2408,239},},
{0},{{3742,52,10,3690,0},},{0},{{0,43,21,0,159},},{{2,54,21,3743,312},},{{5,24,17,45,198},},{{42,5,16,42,233},},{{45,22,21,5,211},},
{{21,17,21,3761,258},},{{3690,35,21,0,86},},{0},{0},{{19,16,18,42,71},},{{3718,91,21,28,86},},{0},{{705,75,16,705,233},},{0},{{2,41,23,0,316},},
{{8,6,17,42,291},},{{237,32,23,5,316},},{0},{{350,18,16,42,326},},{{1,50,24,3739,227,0},},{{28,83,21,28,159},},{0},{{3670,91,25,3749,354,28},
{2094,69,23,451,347},},{{5,21,19,45,208},},{{3763,20,5,3752,2},},{0},{{19,10,21,3,19},},{{3,7,19,42,208},},{0},{{0,42,23,0,177},},
{{2408,91,23,28,223},},{{350,13,16,42,326},},{{451,77,16,705,193},},{{21,5,21,3,252},},{{3670,83,21,28,335},},{{350,9,16,42,326},
{2,36,21,0,304},},{{5,29,18,45,203},{1,38,25,3749,230,0},},{{42,11,16,42,233},},{{0,49,21,0,159},},{0},{{1,55,24,3739,227,0},},
{{237,22,18,45,332},{21,9,25,3749,281,3},},{{45,28,21,5,211},},{0},{0},{{237,33,21,3766,308},},{{705,69,16,705,233},},{{2,44,25,3749,323,0},},
{{42,16,24,3739,227,3},{42,3,23,3,223},},{{451,65,23,451,177},},{{705,65,16,705,233},},{{2094,68,25,3749,354,451},},{0},{0},{{2,48,18,1,332},},
{{3670,86,23,28,347},{3670,60,21,28,335},},{{28,78,24,3739,183,28},},{0},{{3685,32,1,237,0},},{{350,12,25,3749,323,3},},{0},{0},{{1,52,21,0,211},},
{{705,63,21,451,211},},{0},{{42,10,25,3749,230,3},},{0},{0},{0},{{350,7,16,42,326},},{{451,66,17,705,198},},{0},{{3718,85,21,28,86},},{{28,81,24,3739,183,28},},
{0},{0},{{350,16,24,3739,320,3},},{{8,12,25,3749,281,3},},{0},{0},{0},{{1,43,23,0,223},},{{3725,62,23,3764,92},{42,6,24,3739,227,3},},{{45,21,23,5,223},},
{0},{{3670,85,18,2408,363},{8,16,21,3,252},},{0},{{45,32,18,45,239},},{{19,4,21,3,19},},{{3670,81,18,2408,363},{2094,75,24,3739,351,451},},
{0},{0},{{3685,18,1,350,0},},{{3702,19,20,19,0},},{{28,84,24,3739,183,28},},{{45,26,24,3739,227,5},},{{8,7,17,42,291},},{{350,6,25,3749,323,3},},
{{1,49,16,1,233},{1,44,17,1,236},},{{28,80,23,28,177},{3,10,18,42,203},},{{451,67,18,705,203},},{0},{0},{{705,71,21,451,211},},
{{451,63,18,705,203},{19,13,24,3739,47,3},},{0},{{2094,66,24,3739,351,451},},{{237,29,23,5,316},},{{705,67,24,3739,227,451},{0,43,17,1,198},},
{0},{0},{0},{{0,47,17,1,198},},{0},{{350,10,24,3739,320,3},{5,28,21,5,159},},{0},{0},{{19,5,23,3,40},},{{28,91,19,2408,208},},{0},{0},{{2408,79,18,2408,239},},
{0},{{45,27,17,45,236},},{{21,12,23,3,270},},{{705,68,24,3739,227,451},},{{3685,4,1,350,0},},{{3741,13,11,3716,0},},{{2408,83,21,28,211},
{451,64,25,3749,188,451},},{{705,64,24,3739,227,451},},{0},{0},{{237,26,25,3749,323,5},},{{45,19,23,5,223},},{0},{{28,79,16,2408,193},{3,7,23,3,177},},
{{5,32,23,5,177},},{0},{{19,6,25,3749,53,3},},{{42,4,21,3,211},},{{45,23,16,45,233},},{{21,18,18,42,296},{21,5,17,42,291},},
{{3670,83,25,3749,354,28},{705,62,23,451,223},},{{2,57,16,1,326},},{{3704,19,21,19,86},{3,16,25,3749,188,3},},{0},{{0,49,17,1,198},},
{{8,5,18,42,296},},{0},{0},{0},{{2094,62,23,451,347},{8,9,18,42,296},},{{3739,84,13,3670,0},},{{1,51,23,0,223},},{{21,13,16,42,286},},
{{3702,13,20,19,0},},{0},{0},{{3706,27,21,5,86},},{0},{{237,27,16,45,326},{1,42,25,3749,230,0},},{{28,60,25,3749,188,28},},{{3716,9,21,3,86},
{19,11,16,42,59},},{{3670,60,25,3749,354,28},{0,45,18,1,203},},{{2094,64,16,705,357},},{{5,33,21,3766,165},{5,26,18,45,203},},
{{19,18,17,42,65},{19,7,16,42,59},},{{2,52,25,3749,323,0},},{{3,21,0,3704,97},},{{28,89,16,2408,193},},{{1,52,17,1,236},},
{0},{0},{{28,85,16,2408,193},},{{45,25,16,45,233},},{{21,10,16,42,286},},{{3702,16,20,19,0},},{{237,23,23,5,316},{1,48,24,3739,227,0},},
{{451,66,21,451,159},{45,29,16,45,233},},{0},{{0,52,18,1,203},},{{2094,71,16,705,357},},{0},{0},{{5,19,24,3739,183,5},{2,51,23,0,316},},
{{2094,67,16,705,357},{8,12,21,3,252},},{{3,9,18,42,203},},{{3670,89,16,2408,357},},{0},{0},{{3,5,18,42,203},},{0},{0},{0},{{1,36,25,3749,230,0},},
{{3725,69,23,2094,92},},{{19,4,17,42,65},},{0},{0},{{21,7,25,3749,281,3},},{0},{0},{0},{{21,11,25,3749,281,3},},{{8,7,21,3,252},{0,51,25,3749,188,0},},
{{3724,68,21,451,86},},{0},{{3704,10,21,19,86},{28,80,19,2408,208},},{{0,55,25,3749,188,0},},{{42,18,17,42,236},{42,13,18,42,239},},
{{1,40,21,0,211},},{{705,71,25,3749,230,451},},{0},{{2,50,21,0,304},},{{3726,43,1,2,0},{3,6,21,3,159},},{0},{0},{{19,9,23,3,40},},
{{3690,47,21,0,86},{5,24,25,3749,188,5},},{{45,22,24,3739,227,5},},{{0,47,21,0,159},},{0},{{5,28,25,3749,188,5},},{0},{{19,16,25,3749,53,3},
{19,5,24,3739,47,3},},{{3670,80,23,28,347},},{{28,91,23,28,177},},{0},{{705,75,24,3739,227,451},{237,21,18,45,332},},{{451,68,18,705,203},},
{{2094,63,21,451,335},},{{45,27,21,5,211},},{0},{0},{{350,18,24,3739,320,3},{2,45,23,0,316},},{{28,83,24,3739,183,28},{3,11,23,3,177},},
{{2408,83,17,2408,236},},{0},{{3670,91,17,2408,360},{8,10,18,42,296},},{0},{{45,19,24,3739,227,5},},{{19,10,24,3739,47,3},},{{2094,65,23,451,347},
{0,57,25,3749,188,0},},{0},{{5,32,19,45,208},},{0},{{3690,51,21,0,86},{5,25,16,45,193},},{{2094,77,24,3739,351,451},{42,4,17,42,236},},
{{3726,57,1,2,0},{451,77,24,3739,183,451},},{0},{0},{0},{0},{{45,24,24,3739,227,5},},{0},{{3670,79,18,2408,363},},{{237,22,25,3749,323,5},{21,9,18,42,296},},
{{2408,78,23,28,223},{45,28,24,3739,227,5},},{0},{0},{{3743,42,11,3690,0},{3,12,25,3749,188,3},},{0},{{3716,13,21,3,86},{350,4,18,42,332},},
{0},{{42,16,16,42,233},},{0},{{705,65,24,3739,227,451},},{{3724,66,21,451,86},{5,22,16,45,193},},{0},{{451,61,23,3765,155},},{0},{0},{0},{{705,77,17,705,236},},
{{19,18,21,3,19},},{{2,52,21,0,304},},{0},{0},{0},{{2,43,18,1,332},},{{1,39,24,3739,227,0},},{{42,10,17,42,236},},{{3726,55,1,2,0},},
{{8,4,23,3,270},},{0},{{3706,34,21,5,86},{3685,21,1,237,0},},{{451,66,25,3749,188,451},},{{2408,81,18,2408,239},},{{28,81,19,2408,208},
{3,13,16,42,193},},{0},{{237,24,25,3749,323,5},},{{2408,85,18,2408,239},},{{350,16,16,42,326},{350,3,23,3,316},},{0},{{237,28,25,3749,323,5},},
{0},{0},{{5,23,23,5,177},},{{42,6,16,42,233},},{{0,44,23,0,177},},{{3670,85,25,3749,354,28},},{{5,34,18,45,203},},{{1,36,21,0,211},},
{0},{{3670,81,25,3749,354,28},{8,3,21,3,252},},{{28,88,21,3758,171},{3,18,16,42,193},},{0},{{21,7,21,3,252},},{0},{0},{{451,71,16,705,193},
{45,26,23,5,223},},{0},{{8,7,25,3749,281,3},{0,51,21,0,159},},{{350,6,17,42,329},},{{1,49,24,3739,227,0},{1,44,25,3749,230,0},},
{0},{0},{{42,18,21,3,211},},{{3690,43,21,0,86},{1,40,25,3749,230,0},},{{3685,7,1,350,0},{237,25,23,5,316},},{0},{{2094,66,21,451,335},},
{{3,6,17,42,198},},{{1,57,23,0,223},},{{705,67,16,705,233},{0,43,25,3749,188,0},},{0},{0},{0},{{0,47,25,3749,188,0},},{0},{{350,10,16,42,326},},
{0},{0},{0},{{3743,52,11,3690,0},},{0},{{2408,79,25,3749,230,28},},{0},{{2094,63,17,705,360},},{{45,27,25,3749,230,5},},{{3706,21,21,5,86},},{{705,68,16,705,233},
{0,50,23,0,177},},{{1,45,16,1,233},},{{42,12,25,3749,230,3},{3,11,19,42,208},},{{451,64,17,705,198},},{{3739,83,13,3670,0},
{705,64,16,705,233},},{{3670,91,21,28,335},},{0},{0},{{2,49,18,1,332},},{{0,57,21,0,159},},{{28,79,24,3739,183,28},{0,20,3,3752,101},},
{{0,42,16,1,193},},{0},{{3702,6,20,19,0},},{0},{{45,23,24,3739,227,5},},{{21,5,25,3749,281,3},},{0},{0},{{42,11,23,3,223},{3,16,17,42,198},},
{0},{{0,49,25,3749,188,0},},{{1,55,17,1,236},},{0},{0},{0},{0},{0},{{705,69,25,3749,230,451},{0,38,23,0,177},},{{3685,24,1,237,0},{2,44,18,1,332},},
{0},{0},{0},{{2094,68,18,705,363},{8,13,17,42,291},},{{3702,9,20,19,0},},{{237,27,24,3739,320,5},{1,42,17,1,236},},{0},{{19,11,24,3739,47,3},},
{{42,7,18,42,239},{28,78,17,2408,198},},{{5,26,25,3749,188,5},},{{705,77,21,451,211},},{{19,18,25,3749,53,3},{19,7,24,3739,47,3},},
{{350,12,21,3,304},{2,52,17,1,329},},{0},{{21,6,18,42,296},},{0},{{19,3,23,3,40},},{0},{{42,10,21,3,211},{28,85,24,3739,183,28},},
{{0,48,16,1,193},},{{0,37,6,3763,113},},{{350,7,23,3,316},},{{1,48,16,1,233},{1,35,23,0,223},},{{45,29,24,3739,227,5},},
{{8,46,21,3726,246},},{{28,81,23,28,177},},{0},{{237,34,23,5,316},{237,24,21,5,304},},{{19,12,24,3739,47,3},},{0},{{3744,34,11,3706,0},},
{{705,66,23,451,223},},{{3670,89,24,3739,351,28},},{{3685,10,1,350,0},{2,55,23,0,316},},{{5,23,19,45,208},},{{2408,89,21,28,211},},
{{0,44,19,1,208},},{{3670,85,21,28,335},{8,16,18,42,296},},{{5,27,19,45,208},},{0},{{350,11,18,42,332},{2,38,23,0,316},},
{{2094,75,23,451,347},},{0},{0},{{21,7,17,42,291},},{{3702,0,20,19,0},},{{3742,57,10,3690,0},{28,84,17,2408,198},},{0},{{21,11,17,42,291},},
{0},{{350,6,21,3,304},},{{3,10,25,3749,188,3},},{0},{{0,55,17,1,198},},{{42,18,25,3749,230,3},},{0},{{2408,84,23,28,223},{19,13,17,42,65},},
{0},{{2094,66,17,705,360},},{0},{0},{0},{{3702,7,20,19,0},},{0},{{45,22,16,45,233},},{{21,4,23,3,270},},};

static const struct action_table_entry *action_table_lookup(uint32_t nfa_state, uint32_t dfa_state, uint32_t token) {
    uint32_t index = ((((((0xe5aa55e5 ^ (nfa_state)) * 0xe5aa55e5) ^ (dfa_state)) * 0xe5aa55e5) ^ (token)) * 0xe5aa55e5) & 2047;
    uint32_t j = 0;
    const struct action_table_entry *entry = 0;
    for (; j < 2; ++j) {
        entry = &action_table[index][j];
        if (entry->target_nfa_state == nfa_state && entry->dfa_state == dfa_state && entry->dfa_symbol == token)
            break;
    }
    if (j >= 2)
        return 0;
    return entry;
}
static void apply_actions(struct construct_state *state, uint32_t index, size_t start, size_t end) {
    size_t offset = end;
    for (uint32_t i = index; actions[i]; ++i) {
        if (((((actions[i]) >> 12) & 0xf) & 8))
            offset = start;
        construct_action_apply(state, actions[i], offset);
    }
}
static size_t build_parse_tree(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run *run, struct bluebird_tree *tree) {
    struct construct_state construct_state = { .info = tree };
    uint32_t *state_stack = 0;
    uint32_t stack_depth = 0;
    size_t stack_capacity = 0;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset - whitespace;
    construct_begin(&construct_state, offset, CONSTRUCT_NORMAL_ROOT);
    uint32_t nfa_state = 21;
    while (run) {
        uint16_t length_offset = run->lengths_size - 1;
        uint16_t n = run->number_of_tokens;
        for (uint16_t i = n - 1; i < n; i--) {
            size_t end = offset;
            size_t len = 0;
            const struct action_table_entry *entry = action_table_lookup(nfa_state, run->states[i], run->tokens[i]);
            if (!entry)
                abort();
            if (entry->dfa_symbol < 24)
                len = decode_token_length(run, &length_offset, &offset);
            else {
                if (stack_depth >= stack_capacity) {
                    size_t new_capacity = (stack_capacity + 2) * 3 / 2;
                    if (new_capacity <= stack_capacity)
                        abort();
                    uint32_t *new_stack = realloc(state_stack, new_capacity * sizeof(uint32_t));
                    if (!new_stack)
                        abort();
                    state_stack = new_stack;
                    stack_capacity = new_capacity;
                }
                state_stack[stack_depth++] = entry->push_nfa_state;
            }
            apply_actions(&construct_state, entry->actions, end, end + whitespace);
            if (entry->dfa_state == 59) {
                if (stack_depth == 0)
                    abort();
                nfa_state = state_stack[--stack_depth];
            } else
                nfa_state = entry->nfa_state;
            whitespace = end - offset - len;
        }
        struct bluebird_token_run *old = run;
        run = run->prev;
        free(old);
    }
    const struct action_table_entry *entry = action_table_lookup(nfa_state, UINT32_MAX, UINT32_MAX);
    if (!entry)
        abort();
    apply_actions(&construct_state, entry->actions, offset, offset + whitespace);
    free(state_stack);
    return construct_finish(&construct_state, offset);
}
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info) {
    switch (text[0]) {
    case 35:
        *end_token = false;
        *token = 4294967295U;
        return 1;
    case 40:
        *end_token = false;
        *token = 12;
        return 1;
    case 41:
        *end_token = true;
        *token = 13;
        return 1;
    case 42:
        *end_token = false;
        *token = 16;
        return 1;
    case 43:
        *end_token = false;
        *token = 17;
        return 1;
    case 46:
        if (text[1] == 111 && text[2] == 112 && text[3] == 101 && text[4] == 114 && text[5] == 97 && text[6] == 116 && text[7] == 111 && text[8] == 114 && text[9] == 115) {
            *end_token = false;
            *token = 2;
            return 10;
        } else {
            return 0;
        }
    case 58:
        *end_token = false;
        *token = 1;
        return 1;
    case 61:
        *end_token = false;
        *token = 0;
        return 1;
    case 63:
        *end_token = false;
        *token = 18;
        return 1;
    case 64:
        *end_token = false;
        *token = 11;
        return 1;
    case 91:
        *end_token = false;
        *token = 14;
        return 1;
    case 92:
        *end_token = false;
        *token = 10;
        return 1;
    case 93:
        *end_token = true;
        *token = 15;
        return 1;
    case 102:
        if (text[1] == 108 && text[2] == 97 && text[3] == 116) {
            *end_token = false;
            *token = 6;
            return 4;
        } else {
            return 0;
        }
    case 105:
        if (text[1] == 110 && text[2] == 102 && text[3] == 105 && text[4] == 120) {
            *end_token = false;
            *token = 5;
            return 5;
        } else {
            return 0;
        }
    case 108:
        switch (text[1]) {
        case 101:
            if (text[2] == 102 && text[3] == 116) {
                *end_token = false;
                *token = 7;
                return 4;
            } else {
                return 0;
            }
        case 105:
            if (text[2] == 110 && text[3] == 101 && text[4] == 45 && text[5] == 99 && text[6] == 111 && text[7] == 109 && text[8] == 109 && text[9] == 101 && text[10] == 110 && text[11] == 116 && text[12] == 45 && text[13] == 116 && text[14] == 111 && text[15] == 107 && text[16] == 101 && text[17] == 110) {
                *end_token = false;
                *token = 20;
                return 18;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 110:
        if (text[1] == 111 && text[2] == 110 && text[3] == 97 && text[4] == 115 && text[5] == 115 && text[6] == 111 && text[7] == 99) {
            *end_token = false;
            *token = 9;
            return 8;
        } else {
            return 0;
        }
    case 112:
        switch (text[1]) {
        case 111:
            if (text[2] == 115 && text[3] == 116 && text[4] == 102 && text[5] == 105 && text[6] == 120) {
                *end_token = false;
                *token = 3;
                return 7;
            } else {
                return 0;
            }
        case 114:
            if (text[2] == 101 && text[3] == 102 && text[4] == 105 && text[5] == 120) {
                *end_token = false;
                *token = 4;
                return 6;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 114:
        if (text[1] == 105 && text[2] == 103 && text[3] == 104 && text[4] == 116) {
            *end_token = false;
            *token = 8;
            return 5;
        } else {
            return 0;
        }
    case 124:
        *end_token = false;
        *token = 19;
        return 1;
    default:
        return 0;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context) {
    switch (parent) {
    case 0:
        switch (slot) {
        case 0: return 1;
        case 1: return 8;
        default: break;
        }
        break;
    case 1:
        switch (slot) {
        case 0: return 9;
        case 1: return 2;
        default: break;
        }
        break;
    case 2:
        switch (slot) {
        case 0: return 7;
        case 1: return 9;
        case 2: return 3;
        default: break;
        }
        break;
    case 3:
        switch (slot) {
        case 0: return 4;
        case 1: return 6;
        default: break;
        }
        break;
    case 4:
        switch (slot) {
        case 0: return 5;
        default: break;
        }
        break;
    case 6:
        switch (slot) {
        case 0: return 7;
        case 1: return 9;
        default: break;
        }
        break;
    case 7:
        switch (slot) {
        case 0: return 9;
        case 1: return 9;
        case 2: return 9;
        case 3: return 11;
        case 4: return 7;
        case 5: return 11;
        case 6: return 11;
        case 7: return 7;
        default: break;
        }
        break;
    case 8:
        switch (slot) {
        case 0: return 11;
        default: break;
        }
        break;
    default: break;
    }
    return UINT32_MAX;
}
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context) {
    switch (rule) {
    case 7:
        switch (choice) {
        case 4:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 5:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 6:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 7:
            *precedence = -2;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        case 8:
            *precedence = -3;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        default: return;
        }
    default: return;
    }
}
static size_t number_of_slots_lookup(uint32_t rule, void *context) {
    switch (rule) {
    case 0: return 2;
    case 1: return 2;
    case 2: return 3;
    case 3: return 2;
    case 4: return 1;
    case 5: return 0;
    case 6: return 2;
    case 7: return 8;
    case 8: return 1;
    case 9: return 0;
    case 10: return 0;
    case 11: return 0;
    default: return 0;
    }
}
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context) {
    switch (rule) {
    case 0:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 1:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 2:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 3:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 4:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 5:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 6:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 7:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 7;
        break;
    case 8:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 9:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 10:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 11:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    }
}
#endif

