// -----------------------------------------------------------------------------
// This file was generated by the bluebird parsing tool.
// Make sure to #define BLUEBIRD_PARSER_IMPLEMENTATION somewhere so the parser
// is compiled properly.  Just two lines are enough -- a typical parser.c might
// look like:
//
//   #define BLUEBIRD_PARSER_IMPLEMENTATION
//   #include "bluebird-parser.h"

#ifndef _BLUEBIRD_PARSER_H_
#define _BLUEBIRD_PARSER_H_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

// A parsed_id represents an element in the parse tree.  Use the
// parsed_..._get() function corresponding to the element type to unpack the
// element into its appropriate type of parsed_... element struct.
typedef size_t parsed_id;

// The bluebird_tree struct represents an entire parse tree.  Use the
// bluebird_tree_create_...() functions to create a tree, then call
// bluebird_tree_root() to get the root bluebird_id.
struct bluebird_tree;

// Creates a bluebird_tree from a string.  The tree may directly reference
// pieces of the string -- you're responsible for keeping it around until
// bluebird_tree_destroy() is called.
struct bluebird_tree *bluebird_tree_create_from_string(const char *string);

// Creates a bluebird_tree by reading from a file.
struct bluebird_tree *bluebird_tree_create_from_file(FILE *file);

// Destroys a bluebird_tree, freeing its resources back to the system.
void bluebird_tree_destroy(struct bluebird_tree *);

// Prints a representation of the tree to standard output.
void bluebird_tree_print(struct bluebird_tree *);

// Returns the root parsed_id.
parsed_id bluebird_tree_root_id(struct bluebird_tree *tree);

// As a shortcut, returns the parsed_grammar struct corresponding to the root parsed_id.
struct parsed_grammar bluebird_tree_get_parsed_grammar(struct bluebird_tree *tree);

// The range of text corresponding to a tree element.
struct source_range {
    size_t start;
    size_t end;
};

enum bluebird_error {
    // No error -- everything's fine!
    ERROR_NONE,

    // The file passed to bluebird_tree_create_from_file wasn't valid because
    // - it was NULL,
    // - it doesn't support fseek/ftell, or
    // - there was an error while reading it.
    ERROR_INVALID_FILE,

    // A piece of text couldn't be matched as a token.
    ERROR_INVALID_TOKEN,

    // The parser encountered an out-of-place token that doesn't fit the grammar.
    ERROR_UNEXPECTED_TOKEN,

    // The input is valid so far, but incomplete; more tokens could be added to
    // complete it.
    ERROR_MORE_INPUT_NEEDED,
};
// Returns an error code, or ERROR_NONE if there wasn't an error.
// The error_range parameter can be null.
enum bluebird_error bluebird_tree_get_error(struct bluebird_tree *tree, struct source_range *error_range);

enum parsed_type {
    PARSED_IDENT = 1,
    PARSED_CHOICE,
    PARSED_PARENS,
    PARSED_FLAT_OP,
    PARSED_LEFT_OP,
    PARSED_LITERAL,
    PARSED_INFIX_OP,
    PARSED_OPTIONAL,
    PARSED_RIGHT_OP,
    PARSED_BRACKETED,
    PARSED_PREFIX_OP,
    PARSED_POSTFIX_OP,
    PARSED_NONASSOC_OP,
    PARSED_ONE_OR_MORE,
    PARSED_ZERO_OR_MORE,
    PARSED_CONCATENATION,
};

struct parsed_grammar {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id comment_token;
    parsed_id rule;
};

struct parsed_comment_token {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id string;
};

struct parsed_rule {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id identifier;
    parsed_id body;
};

struct parsed_body {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id expr;
    parsed_id identifier;
    parsed_id operators;
};

struct parsed_operators {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id fixity;
    parsed_id operator;
};

struct parsed_operator {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    parsed_id expr;
    parsed_id identifier;
};

struct parsed_fixity {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    enum parsed_type type;
    parsed_id assoc;
};

struct parsed_assoc {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    enum parsed_type type;
};

struct parsed_expr {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    enum parsed_type type;
    parsed_id identifier;
    parsed_id exception;
    parsed_id rename;
    parsed_id string;
    parsed_id expr;
    parsed_id begin_token;
    parsed_id end_token;
    parsed_id operand;
};

struct parsed_identifier {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    const char *identifier;
    size_t length;
};

struct parsed_number {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    double number;
};

struct parsed_string {
    struct bluebird_tree *_tree;
    parsed_id _next;
    struct source_range range;
    bool empty;
    const char *string;
    size_t length;
    bool has_escapes;
};

struct parsed_grammar parsed_grammar_get(struct bluebird_tree *, parsed_id);
struct parsed_comment_token parsed_comment_token_get(struct bluebird_tree *, parsed_id);
struct parsed_rule parsed_rule_get(struct bluebird_tree *, parsed_id);
struct parsed_body parsed_body_get(struct bluebird_tree *, parsed_id);
struct parsed_operators parsed_operators_get(struct bluebird_tree *, parsed_id);
struct parsed_operator parsed_operator_get(struct bluebird_tree *, parsed_id);
struct parsed_fixity parsed_fixity_get(struct bluebird_tree *, parsed_id);
struct parsed_assoc parsed_assoc_get(struct bluebird_tree *, parsed_id);
struct parsed_expr parsed_expr_get(struct bluebird_tree *, parsed_id);
struct parsed_identifier parsed_identifier_get(struct bluebird_tree *, parsed_id);
struct parsed_number parsed_number_get(struct bluebird_tree *, parsed_id);
struct parsed_string parsed_string_get(struct bluebird_tree *, parsed_id);

static inline struct parsed_grammar parsed_grammar_next(struct parsed_grammar parsed)
{
    return parsed_grammar_get(parsed._tree, parsed._next);
}
static inline struct parsed_comment_token parsed_comment_token_next(struct parsed_comment_token parsed)
{
    return parsed_comment_token_get(parsed._tree, parsed._next);
}
static inline struct parsed_rule parsed_rule_next(struct parsed_rule parsed)
{
    return parsed_rule_get(parsed._tree, parsed._next);
}
static inline struct parsed_body parsed_body_next(struct parsed_body parsed)
{
    return parsed_body_get(parsed._tree, parsed._next);
}
static inline struct parsed_operators parsed_operators_next(struct parsed_operators parsed)
{
    return parsed_operators_get(parsed._tree, parsed._next);
}
static inline struct parsed_operator parsed_operator_next(struct parsed_operator parsed)
{
    return parsed_operator_get(parsed._tree, parsed._next);
}
static inline struct parsed_fixity parsed_fixity_next(struct parsed_fixity parsed)
{
    return parsed_fixity_get(parsed._tree, parsed._next);
}
static inline struct parsed_assoc parsed_assoc_next(struct parsed_assoc parsed)
{
    return parsed_assoc_get(parsed._tree, parsed._next);
}
static inline struct parsed_expr parsed_expr_next(struct parsed_expr parsed)
{
    return parsed_expr_get(parsed._tree, parsed._next);
}
static inline struct parsed_identifier parsed_identifier_next(struct parsed_identifier parsed)
{
    return parsed_identifier_get(parsed._tree, parsed._next);
}
static inline struct parsed_number parsed_number_next(struct parsed_number parsed)
{
    return parsed_number_get(parsed._tree, parsed._next);
}
static inline struct parsed_string parsed_string_next(struct parsed_string parsed)
{
    return parsed_string_get(parsed._tree, parsed._next);
}

#endif

#ifdef BLUEBIRD_PARSER_IMPLEMENTATION
// Code implementing the parser.  This might get a bit messy!
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct bluebird_tree {
    const char *string;
    bool owns_string;
    uint8_t *parse_tree;
    size_t parse_tree_size;
    enum bluebird_error error;
    struct source_range error_range;
    parsed_id next_id;
    parsed_id root_id;
    struct {
        const char *identifier;
        size_t length;
        struct source_range range;
    } *identifier_tokens;
    size_t number_of_identifier_tokens;
    size_t used_identifier_tokens;
    size_t identifier_tokens_capacity;
    struct {
        double number;
        struct source_range range;
    } *number_tokens;
    size_t number_of_number_tokens;
    size_t used_number_tokens;
    size_t number_tokens_capacity;
    struct {
        const char *string;
        size_t length;
        bool has_escapes;
        struct source_range range;
    } *string_tokens;
    size_t number_of_string_tokens;
    size_t used_string_tokens;
    size_t string_tokens_capacity;
};
static void add_identifier_token(struct bluebird_tree *tree, size_t start, size_t end, const char *identifier_param, size_t length_param) {
    size_t index = tree->number_of_identifier_tokens++;
    if (tree->number_of_identifier_tokens > tree->identifier_tokens_capacity) {
        size_t capacity = (tree->identifier_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->identifier_tokens, sizeof(tree->identifier_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->identifier_tokens_capacity = capacity;
        tree->identifier_tokens = tokens;
    }
    tree->identifier_tokens[index].range.start = start;
    tree->identifier_tokens[index].range.end = end;
    tree->identifier_tokens[index].identifier = identifier_param;
    tree->identifier_tokens[index].length = length_param;
}
static void add_number_token(struct bluebird_tree *tree, size_t start, size_t end, double number_param) {
    size_t index = tree->number_of_number_tokens++;
    if (tree->number_of_number_tokens > tree->number_tokens_capacity) {
        size_t capacity = (tree->number_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->number_tokens, sizeof(tree->number_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->number_tokens_capacity = capacity;
        tree->number_tokens = tokens;
    }
    tree->number_tokens[index].range.start = start;
    tree->number_tokens[index].range.end = end;
    tree->number_tokens[index].number = number_param;
}
static void add_string_token(struct bluebird_tree *tree, size_t start, size_t end, const char *string_param, size_t length_param, bool has_escapes_param) {
    size_t index = tree->number_of_string_tokens++;
    if (tree->number_of_string_tokens > tree->string_tokens_capacity) {
        size_t capacity = (tree->string_tokens_capacity + 1) * 3 / 2;
        void *tokens = realloc(tree->string_tokens, sizeof(tree->string_tokens[0]) * capacity);
        if (!tokens)
            abort();
        tree->string_tokens_capacity = capacity;
        tree->string_tokens = tokens;
    }
    tree->string_tokens[index].range.start = start;
    tree->string_tokens[index].range.end = end;
    tree->string_tokens[index].string = string_param;
    tree->string_tokens[index].length = length_param;
    tree->string_tokens[index].has_escapes = has_escapes_param;
}
// Reserve 10 bytes for each entry (the maximum encoded size of a 64-bit value).
#define RESERVATION_AMOUNT 10
static inline uint64_t read_tree(parsed_id *id, struct bluebird_tree *tree) {
    uint8_t *parse_tree = tree->parse_tree;
    size_t parse_tree_size = tree->parse_tree_size;
    parsed_id i = *id;
    if (i + RESERVATION_AMOUNT >= parse_tree_size)
        return 0;
    uint64_t result = 0;
    int shift_amount = 0;
    while ((parse_tree[i] & 0x80) != 0 && shift_amount < 64) {
        result |= (parse_tree[i] & 0x7f) << shift_amount;
        shift_amount += 7;
        i++;
    }
    result |= (parse_tree[i] & 0x7f) << shift_amount;
    i++;
    *id = i;
    return result;
}
static bool grow_tree(struct bluebird_tree *tree, size_t size)
{
    size_t n = tree->parse_tree_size;
    while (n < size || n < 4096)
        n = (n + 1) * 3 / 2;
    uint8_t *parse_tree = realloc(tree->parse_tree, n);
    if (!parse_tree)
        return false;
    tree->parse_tree_size = n;
    tree->parse_tree = parse_tree;
    return true;
}
static void write_tree(struct bluebird_tree *tree, uint64_t value)
{
    size_t reserved_size = tree->next_id + RESERVATION_AMOUNT;
    if (tree->parse_tree_size <= reserved_size && !grow_tree(tree, reserved_size))
        abort();
    while (value >> 7 != 0) {
        tree->parse_tree[tree->next_id++] = 0x80 | (value & 0x7f);
        value >>= 7;
    }
    tree->parse_tree[tree->next_id++] = value & 0x7f;
}
struct parsed_grammar parsed_grammar_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_grammar){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_grammar){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .comment_token = read_tree(&id, tree),
        .rule = read_tree(&id, tree),
    };
}
struct parsed_comment_token parsed_comment_token_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_comment_token){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_comment_token){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .string = read_tree(&id, tree),
    };
}
struct parsed_rule parsed_rule_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_rule){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_rule){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .identifier = read_tree(&id, tree),
        .body = read_tree(&id, tree),
    };
}
struct parsed_body parsed_body_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_body){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_body){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .expr = read_tree(&id, tree),
        .identifier = read_tree(&id, tree),
        .operators = read_tree(&id, tree),
    };
}
struct parsed_operators parsed_operators_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_operators){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_operators){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .fixity = read_tree(&id, tree),
        .operator = read_tree(&id, tree),
    };
}
struct parsed_operator parsed_operator_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_operator){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_operator){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .expr = read_tree(&id, tree),
        .identifier = read_tree(&id, tree),
    };
}
struct parsed_fixity parsed_fixity_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_fixity){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_fixity){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&id, tree),
        .assoc = read_tree(&id, tree),
    };
}
struct parsed_assoc parsed_assoc_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_assoc){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_assoc){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&id, tree),
    };
}
struct parsed_expr parsed_expr_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_expr){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t start_location = read_tree(&id, tree);
    size_t end_location = read_tree(&id, tree);
    return (struct parsed_expr){
        ._tree = tree,
        ._next = next,
        .range.start = start_location,
        .range.end = end_location,
        .type = read_tree(&id, tree),
        .identifier = read_tree(&id, tree),
        .exception = read_tree(&id, tree),
        .rename = read_tree(&id, tree),
        .string = read_tree(&id, tree),
        .expr = read_tree(&id, tree),
        .begin_token = read_tree(&id, tree),
        .end_token = read_tree(&id, tree),
        .operand = read_tree(&id, tree),
    };
}
struct parsed_identifier parsed_identifier_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_identifier){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t token_index = read_tree(&id, tree);
    return (struct parsed_identifier){
        ._tree = tree,
        ._next = next,
        .identifier = tree->identifier_tokens[token_index].identifier,
        .length = tree->identifier_tokens[token_index].length,
        .range = tree->identifier_tokens[token_index].range,
    };
}
struct parsed_number parsed_number_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_number){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t token_index = read_tree(&id, tree);
    return (struct parsed_number){
        ._tree = tree,
        ._next = next,
        .number = tree->number_tokens[token_index].number,
        .range = tree->number_tokens[token_index].range,
    };
}
struct parsed_string parsed_string_get(struct bluebird_tree *tree, parsed_id id) {
    if (id == 0)
        return (struct parsed_string){ ._tree = tree, .empty = true };
    parsed_id next = read_tree(&id, tree);
    size_t token_index = read_tree(&id, tree);
    return (struct parsed_string){
        ._tree = tree,
        ._next = next,
        .string = tree->string_tokens[token_index].string,
        .length = tree->string_tokens[token_index].length,
        .has_escapes = tree->string_tokens[token_index].has_escapes,
        .range = tree->string_tokens[token_index].range,
    };
}
static parsed_id finish_node(uint32_t rule, uint32_t choice, parsed_id next_sibling, parsed_id *slots, size_t start_location, size_t end_location, void *info) {
    struct bluebird_tree *tree = info;
    parsed_id id = tree->next_id;
    write_tree(tree, next_sibling);
    write_tree(tree, start_location);
    write_tree(tree, end_location);
    switch (rule) {
    case 0: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 1: {
        write_tree(tree, slots[0]);
        break;
    }
    case 2: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 3: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        break;
    }
    case 4: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 5: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 6: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_POSTFIX_OP);
            break;
        case 1:
            write_tree(tree, PARSED_PREFIX_OP);
            break;
        case 2:
            write_tree(tree, PARSED_INFIX_OP);
            break;
        }
        write_tree(tree, slots[0]);
        break;
    }
    case 7: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_FLAT_OP);
            break;
        case 1:
            write_tree(tree, PARSED_LEFT_OP);
            break;
        case 2:
            write_tree(tree, PARSED_RIGHT_OP);
            break;
        case 3:
            write_tree(tree, PARSED_NONASSOC_OP);
            break;
        }
        break;
    }
    case 8: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_IDENT);
            break;
        case 1:
            write_tree(tree, PARSED_LITERAL);
            break;
        case 2:
            write_tree(tree, PARSED_PARENS);
            break;
        case 3:
            write_tree(tree, PARSED_BRACKETED);
            break;
        case 4:
            write_tree(tree, PARSED_ZERO_OR_MORE);
            break;
        case 5:
            write_tree(tree, PARSED_ONE_OR_MORE);
            break;
        case 6:
            write_tree(tree, PARSED_OPTIONAL);
            break;
        case 7:
            write_tree(tree, PARSED_CONCATENATION);
            break;
        case 8:
            write_tree(tree, PARSED_CHOICE);
            break;
        }
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        write_tree(tree, slots[3]);
        write_tree(tree, slots[4]);
        write_tree(tree, slots[5]);
        write_tree(tree, slots[6]);
        write_tree(tree, slots[7]);
        break;
    }
    default:
        break;
    }
    return id;
}
static parsed_id finish_token(uint32_t rule, parsed_id next_sibling, void *info) {
    struct bluebird_tree *tree = info;
    parsed_id id = tree->next_id;
    write_tree(tree, next_sibling);
    switch (rule) {
    case 9: {
        tree->used_identifier_tokens++;
        if (tree->used_identifier_tokens > tree->number_of_identifier_tokens)
            abort();
        size_t token_index = tree->number_of_identifier_tokens - tree->used_identifier_tokens;
        write_tree(tree, token_index);
        break;
    }
    case 10: {
        tree->used_number_tokens++;
        if (tree->used_number_tokens > tree->number_of_number_tokens)
            abort();
        size_t token_index = tree->number_of_number_tokens - tree->used_number_tokens;
        write_tree(tree, token_index);
        break;
    }
    case 11: {
        tree->used_string_tokens++;
        if (tree->used_string_tokens > tree->number_of_string_tokens)
            abort();
        size_t token_index = tree->number_of_string_tokens - tree->used_string_tokens;
        write_tree(tree, token_index);
        break;
    }
    default:
        break;
    }
    return id;
}
static void check_for_error(struct bluebird_tree *tree) {
    if (tree->error == ERROR_NONE)
        return;
    fprintf(stderr, "parse error: ");
    switch (tree->error) {
    case ERROR_INVALID_FILE:
        fprintf(stderr, "invalid file\n");
        break;
    case ERROR_INVALID_TOKEN:
        fprintf(stderr, "invalid token\n");
        break;
    case ERROR_UNEXPECTED_TOKEN:
        fprintf(stderr, "unexpected token\n");
        break;
    case ERROR_MORE_INPUT_NEEDED:
        fprintf(stderr, "more input needed\n");
        break;
    default:
        break;
    }
    exit(-1);
}
static void parsed_grammar_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_comment_token_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_rule_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_body_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_operators_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_operator_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_fixity_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_assoc_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_expr_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_identifier_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_number_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_string_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);
static void parsed_grammar_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_grammar it = parsed_grammar_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("grammar");
        if (strcmp("grammar", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_comment_token_print(tree, it.comment_token, "comment_token", indent + 1);
        parsed_rule_print(tree, it.rule, "rule", indent + 1);
        it = parsed_grammar_next(it);
    }
}
static void parsed_comment_token_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_comment_token it = parsed_comment_token_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("comment_token");
        if (strcmp("comment_token", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_string_print(tree, it.string, "string", indent + 1);
        it = parsed_comment_token_next(it);
    }
}
static void parsed_rule_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_rule it = parsed_rule_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("rule");
        if (strcmp("rule", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_body_print(tree, it.body, "body", indent + 1);
        it = parsed_rule_next(it);
    }
}
static void parsed_body_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_body it = parsed_body_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("body");
        if (strcmp("body", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_operators_print(tree, it.operators, "operators", indent + 1);
        it = parsed_body_next(it);
    }
}
static void parsed_operators_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_operators it = parsed_operators_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operators");
        if (strcmp("operators", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_fixity_print(tree, it.fixity, "fixity", indent + 1);
        parsed_operator_print(tree, it.operator, "operator", indent + 1);
        it = parsed_operators_next(it);
    }
}
static void parsed_operator_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_operator it = parsed_operator_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operator");
        if (strcmp("operator", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        it = parsed_operator_next(it);
    }
}
static void parsed_fixity_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_fixity it = parsed_fixity_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("fixity");
        if (strcmp("fixity", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_POSTFIX_OP:
            printf(" : POSTFIX_OP");
            break;
        case PARSED_PREFIX_OP:
            printf(" : PREFIX_OP");
            break;
        case PARSED_INFIX_OP:
            printf(" : INFIX_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_assoc_print(tree, it.assoc, "assoc", indent + 1);
        it = parsed_fixity_next(it);
    }
}
static void parsed_assoc_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_assoc it = parsed_assoc_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("assoc");
        if (strcmp("assoc", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_FLAT_OP:
            printf(" : FLAT_OP");
            break;
        case PARSED_LEFT_OP:
            printf(" : LEFT_OP");
            break;
        case PARSED_RIGHT_OP:
            printf(" : RIGHT_OP");
            break;
        case PARSED_NONASSOC_OP:
            printf(" : NONASSOC_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        it = parsed_assoc_next(it);
    }
}
static void parsed_expr_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_expr it = parsed_expr_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("expr");
        if (strcmp("expr", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_IDENT:
            printf(" : IDENT");
            break;
        case PARSED_LITERAL:
            printf(" : LITERAL");
            break;
        case PARSED_PARENS:
            printf(" : PARENS");
            break;
        case PARSED_BRACKETED:
            printf(" : BRACKETED");
            break;
        case PARSED_ZERO_OR_MORE:
            printf(" : ZERO_OR_MORE");
            break;
        case PARSED_ONE_OR_MORE:
            printf(" : ONE_OR_MORE");
            break;
        case PARSED_OPTIONAL:
            printf(" : OPTIONAL");
            break;
        case PARSED_CONCATENATION:
            printf(" : CONCATENATION");
            break;
        case PARSED_CHOICE:
            printf(" : CHOICE");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_identifier_print(tree, it.exception, "exception", indent + 1);
        parsed_identifier_print(tree, it.rename, "rename", indent + 1);
        parsed_string_print(tree, it.string, "string", indent + 1);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_string_print(tree, it.begin_token, "begin_token", indent + 1);
        parsed_string_print(tree, it.end_token, "end_token", indent + 1);
        parsed_expr_print(tree, it.operand, "operand", indent + 1);
        it = parsed_expr_next(it);
    }
}
static void parsed_identifier_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_identifier it = parsed_identifier_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("identifier");
        if (strcmp("identifier", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.identifier);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        it = parsed_identifier_next(it);
    }
}
static void parsed_number_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_number it = parsed_number_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("number");
        if (strcmp("number", slot_name))
            printf("@%s", slot_name);
        printf(" - %f", it.number);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        it = parsed_number_next(it);
    }
}
static void parsed_string_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {
    struct parsed_string it = parsed_string_get(tree, id);
    while (!it.empty) {
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("string");
        if (strcmp("string", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.string);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        it = parsed_string_next(it);
    }
}
void bluebird_tree_print(struct bluebird_tree *tree) {
    check_for_error(tree);
    parsed_grammar_print(tree, tree->root_id, "grammar", 0);
}
parsed_id bluebird_tree_root_id(struct bluebird_tree *tree) {
    check_for_error(tree);
    return tree->root_id;
}
struct parsed_grammar bluebird_tree_get_parsed_grammar(struct bluebird_tree *tree) {
    check_for_error(tree);
    return parsed_grammar_get(tree, tree->root_id);
}
#define IGNORE_TOKEN_WRITE(...)
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info);
static void write_identifier_token(size_t offset, size_t length, void *info) {
    struct bluebird_tree *tree = info;
    add_identifier_token(tree, offset, offset + length, tree->string + offset, length);
}
static void write_number_token(size_t offset, size_t length, double number, void *info) {
    struct bluebird_tree *tree = info;
    add_number_token(tree, offset, offset + length, number);
}
static void write_string_token(size_t offset, size_t length, const char *string, size_t string_length, bool has_escapes, void *info) {
    struct bluebird_tree *tree = info;
    add_string_token(tree, offset, offset + length, string, string_length, has_escapes);
}
struct bluebird_token_run {
    struct bluebird_token_run *prev;
    uint16_t number_of_tokens;
    uint16_t lengths_size;
    uint8_t lengths[4096 * 2];
    uint32_t tokens[4096];
    uint32_t states[4096];
};
struct bluebird_default_tokenizer {
    const char *text;
    size_t offset;
    size_t whitespace;
    uint32_t identifier_token;
    uint32_t number_token;
    uint32_t string_token;
    void *info;
};
static bool char_is_whitespace(char c) {
    switch (c) {
    case ' ':
    case '\t':
    case '\r':
    case '\n':
        return true;
    default:
        return false;
    }
}
static bool char_is_numeric(char c) {
    return c >= '0' && c <= '9';
}
static bool char_is_alphabetic(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}
static bool char_starts_identifier(char c) {
    return char_is_alphabetic(c) || c == '_';
}
static bool char_continues_identifier(char c, void *info) {
    if (true && c == '-') return true;
    return char_is_numeric(c) || char_starts_identifier(c);
}
static bool encode_length(struct bluebird_token_run *run, uint16_t *lengths_size, size_t length) {
    uint8_t mark = 0;
    while (*lengths_size < sizeof(run->lengths)) {
        run->lengths[*lengths_size] = mark | (length & 0x7f);
        mark = 0x80;
        length >>= 7;
        (*lengths_size)++;
        if (length == 0) return true;
    }
    return false;
}
static bool encode_token_length(struct bluebird_token_run *run, uint16_t *lengths_size, size_t length, size_t whitespace) {
    uint16_t size = *lengths_size;
    if (encode_length(run, lengths_size, length) && encode_length(run, lengths_size, whitespace)) return true;
    *lengths_size = size;
    return false;
}
static size_t decode_length(struct bluebird_token_run *run, uint16_t *length_offset) {
    size_t length = 0;
    while (*length_offset < sizeof(run->lengths)) {
        size_t l = run->lengths[(*length_offset)--];
        length <<= 7;
        length += l & 0x7f;
        if (!(l & 0x80)) return length;
    }
    abort();
}
static size_t decode_token_length(struct bluebird_token_run *run, uint16_t *length_offset, size_t *string_offset) {
    size_t whitespace = decode_length(run, length_offset);
    size_t length = decode_length(run, length_offset);
    *string_offset -= whitespace + length;
    return length;
}
static bool bluebird_default_tokenizer_advance(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run **previous_run) {
    struct bluebird_token_run *run = malloc(sizeof(struct bluebird_token_run));
    if (!run) return false;
    uint16_t number_of_tokens = 0;
    uint16_t lengths_size = 0;
    const char *text = tokenizer->text;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset;
    while (number_of_tokens < 4096) {
        char c = text[offset];
        if (c == '\0') break;
        if (char_is_whitespace(c)) {
            whitespace++;
            offset++;
            continue;
        }
        uint32_t token;
        bool is_token = false;
        bool end_token = false;
        bool comment = false;
        bool has_escapes = false;
        size_t token_length = read_keyword_token(&token, &end_token, text + offset, tokenizer->info);
        if (token_length > 0) {
            is_token = true;
            if (token == 0xffffffff) comment = true;
        }
        double number = 0;
        if (char_is_numeric(c) || (c == '.' && char_is_numeric(text[offset + 1]))) {
            const char *start = (const char *)text + offset;
            char *rest = 0;
            number = strtod(start, &rest);
            if (rest > start && rest - start > token_length) {
                token_length = rest - start;
                is_token = true;
                end_token = false;
                comment = false;
                token = 22;
            }
        }
        else if (c == '\'' || c == '"') {
            size_t string_offset = offset + 1;
            while (text[string_offset] != '\0') {
                if (text[string_offset] == c) {
                    token_length = string_offset + 1 - offset;
                    is_token = true;
                    end_token = false;
                    comment = false;
                    token = 23;
                    break;
                }
                if (text[string_offset] == '\\') {
                    has_escapes = true;
                    string_offset++;
                    if (text[string_offset] == '\0') break;
                }
                string_offset++;
            }
        }
        else if (char_starts_identifier(c)) {
            size_t identifier_offset = offset + 1;
            while (char_continues_identifier(text[identifier_offset], tokenizer->info)) identifier_offset++;
            if (identifier_offset - offset > token_length) {
                token_length = identifier_offset - offset;
                is_token = true;
                end_token = false;
                comment = false;
                token = 21;
            }
        }
        if (comment) {
            while (text[offset] != '\0' && text[offset] != '\n') {
                whitespace++;
                offset++;
            }
            continue;
        }
        else if (!is_token || token == 0xffffffff) {
            tokenizer->offset = offset;
            tokenizer->whitespace = whitespace;
            free(run);
            return false;
        }
        if (end_token && number_of_tokens + 1 >= 4096) break;
        if (!encode_token_length(run, &lengths_size, token_length, whitespace)) break;
        if (token == 21) {
            write_identifier_token(offset, token_length, tokenizer->info);
        }
        else if (token == 22) {
            write_number_token(offset, token_length, number, tokenizer->info);
        }
        else if (token == 23) {
            size_t content_offset = offset + 1;
            size_t content_length = token_length - 2;
            const char *string = text + content_offset;
            size_t string_length = content_length;
            if (has_escapes) {
                for (size_t i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') {
                        string_length--;
                        i++;
                    }
                }
                char *unescaped = malloc(string_length);
                size_t j = 0;
                for (size_t i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') i++;
                    unescaped[j++] = text[content_offset + i];
                }
                string = unescaped;
            }
            write_string_token(offset, token_length, string, string_length, has_escapes, tokenizer->info);
        }
        run->tokens[number_of_tokens] = token;
        whitespace = 0;
        number_of_tokens++;
        offset += token_length;
        if (end_token) {
            assert(number_of_tokens < 4096);
            run->tokens[number_of_tokens] = 4294967295U;
            number_of_tokens++;
        }
    }
    if (number_of_tokens == 0) {
        tokenizer->offset = offset;
        tokenizer->whitespace = whitespace;
        free(run);
        return false;
    }
    tokenizer->offset = offset;
    tokenizer->whitespace = whitespace;
    run->prev = *previous_run;
    run->number_of_tokens = number_of_tokens;
    run->lengths_size = lengths_size;
    *previous_run = run;
    return true;
}
static void find_token_range(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run *run, uint16_t index, size_t *start, size_t *end) {
    size_t offset = tokenizer->offset - tokenizer->whitespace;
    size_t last_offset = offset;
    size_t len = 0;
    uint16_t length_offset = run->lengths_size - 1;
    for (uint16_t j = index;
    j < run->number_of_tokens;
    ++j) {
        if (run->tokens[j] == 4294967295U) continue;
        last_offset = offset;
        len = decode_token_length(run, &length_offset, &offset);
    }
    *start = last_offset - len;
    *end = last_offset;
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context);
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context);
static size_t number_of_slots_lookup(uint32_t rule, void *context);
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context);
enum construct_fixity_associativity {
CONSTRUCT_PREFIX, CONSTRUCT_POSTFIX, CONSTRUCT_INFIX_LEFT, CONSTRUCT_INFIX_RIGHT, CONSTRUCT_INFIX_FLAT, };
struct construct_node {
    struct construct_node *next;
    size_t number_of_slots;
    parsed_id *slots;
    uint32_t rule;
    uint16_t slot_index;
    uint16_t choice_index;
    enum construct_fixity_associativity fixity_associativity;
    int precedence;
    size_t start_location;
    size_t end_location;
};
struct construct_expression {
    struct construct_expression *parent;
    struct construct_node *first_operator;
    struct construct_node *first_value;
    uint32_t operand_slot_index;
    uint32_t left_slot_index;
    uint32_t right_slot_index;
    uint32_t rule;
    uint16_t slot_index;
};
enum construct_root_type {
CONSTRUCT_NORMAL_ROOT, CONSTRUCT_EXPRESSION_ROOT, };
struct construct_state {
    enum construct_root_type root_type;
    struct construct_node *under_construction;
    struct construct_expression *current_expression;
    struct construct_node *node_freelist;
    struct construct_expression *expression_freelist;
    void *info;
};
static struct construct_node *construct_node_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_node *node;
    size_t number_of_slots = number_of_slots_lookup(rule, s->info);
    if (s->node_freelist) {
        node = s->node_freelist;
        s->node_freelist = node->next;
        parsed_id *slots = node->slots;
        if (number_of_slots > node->number_of_slots) {
            slots = realloc(slots, number_of_slots * sizeof(parsed_id));
            if (!slots) abort();
        }
        memset(node, 0, sizeof(struct construct_node));
        memset(slots, 0, number_of_slots * sizeof(parsed_id));
        node->slots = slots;
    }
    else {
        node = calloc(1, sizeof(struct construct_node));
        if (!node) abort();
        node->slots = calloc(number_of_slots, sizeof(parsed_id));
        if (!node->slots) abort();
    }
    node->rule = rule;
    node->number_of_slots = number_of_slots;
    return node;
}
static struct construct_expression *construct_expression_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_expression *expr;
    if (s->expression_freelist) {
        expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        memset(expr, 0, sizeof(struct construct_expression));
    }
    else {
        expr = calloc(1, sizeof(struct construct_expression));
        if (!expr) abort();
    }
    (left_right_operand_slots_lookup(rule, &(expr->left_slot_index), &(expr->right_slot_index), &(expr->operand_slot_index), s->info));
    expr->rule = rule;
    return expr;
}
static void construct_node_free(struct construct_state *state, struct construct_node *node) {
    node->next = state->node_freelist;
    state->node_freelist = node;
}
static void construct_expression_free(struct construct_state *state, struct construct_expression *expr) {
    expr->parent = state->expression_freelist;
    state->expression_freelist = expr;
}
static bool construct_expression_should_reduce(struct construct_state *s, struct construct_expression *expr, struct construct_node *node) {
    if (node->fixity_associativity == CONSTRUCT_POSTFIX) return false;
    struct construct_node *top = expr->first_operator;
    if (!top) return false;
    return node->precedence < top->precedence || (node->precedence == top->precedence && node->fixity_associativity == CONSTRUCT_INFIX_RIGHT);
}
static void construct_expression_reduce(struct construct_state *s, struct construct_expression *expr) {
    struct construct_node *op = expr->first_operator;
    if (op->fixity_associativity == CONSTRUCT_INFIX_FLAT) {
        struct construct_node *first_value = expr->first_value;
        struct construct_node *last_value = first_value;
        struct construct_node *last_operator = op;
        parsed_id operand = op->slots[expr->operand_slot_index];
        struct construct_node *combined_op = construct_node_alloc(s, op->rule);
        combined_op->choice_index = op->choice_index;
        combined_op->slot_index = op->slot_index;
        combined_op->fixity_associativity = op->fixity_associativity;
        combined_op->precedence = op->precedence;
        struct construct_node *reversed_values = 0;
        while (last_operator && last_operator->choice_index == op->choice_index) {
            struct construct_node *next_op = last_operator->next;
            construct_node_free(s, last_operator);
            last_operator = next_op;
            assert(last_value);
            struct construct_node *next_value = last_value->next;
            last_value->next = reversed_values;
            reversed_values = last_value;
            last_value = next_value;
        }
        combined_op->start_location = first_value->start_location;
        combined_op->end_location = last_value->end_location;
        assert(last_value);
        operand = (finish_node((last_value)->rule, (last_value)->choice_index, operand, (last_value)->slots, (last_value)->start_location, (last_value)->end_location, s->info));
        combined_op->next = last_value->next;
        construct_node_free(s, last_value);
        while (reversed_values) {
            operand = (finish_node((reversed_values)->rule, (reversed_values)->choice_index, operand, (reversed_values)->slots, (reversed_values)->start_location, (reversed_values)->end_location, s->info));
            struct construct_node *next_value = reversed_values->next;
            construct_node_free(s, reversed_values);
            reversed_values = next_value;
        }
        expr->first_operator = last_operator;
        expr->first_value = combined_op;
        combined_op->slots[expr->operand_slot_index] = operand;
    }
    else if (op->fixity_associativity == CONSTRUCT_INFIX_LEFT || op->fixity_associativity == CONSTRUCT_INFIX_RIGHT) {
        expr->first_operator = op->next;
        struct construct_node *left = expr->first_value;
        struct construct_node *right = left->next;
        op->next = right->next;
        expr->first_value = op;
        op->start_location = left->start_location;
        op->end_location = right->end_location;
        op->slots[expr->left_slot_index] = (finish_node((left)->rule, (left)->choice_index, op->slots[expr->left_slot_index], (left)->slots, (left)->start_location, (left)->end_location, s->info));
        op->slots[expr->right_slot_index] = (finish_node((right)->rule, (right)->choice_index, op->slots[expr->right_slot_index], (right)->slots, (right)->start_location, (right)->end_location, s->info));
        construct_node_free(s, left);
        construct_node_free(s, right);
    }
    else {
        expr->first_operator = op->next;
        struct construct_node *value = expr->first_value;
        op->next = value->next;
        expr->first_value = op;
        if (value->start_location < op->start_location) op->start_location = value->start_location;
        if (value->end_location > op->end_location) op->end_location = value->end_location;
        op->slots[expr->operand_slot_index] = (finish_node((value)->rule, (value)->choice_index, op->slots[expr->operand_slot_index], (value)->slots, (value)->start_location, (value)->end_location, s->info));
        construct_node_free(s, value);
    }
}
static void construct_begin(struct construct_state *s, size_t offset, enum construct_root_type type) {
    s->root_type = type;
    uint32_t r = 0;
    if (type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = construct_expression_alloc(s, r);
        expr->parent = s->current_expression;
        s->current_expression = expr;
    }
    else {
        struct construct_node *node = construct_node_alloc(s, r);
        node->next = s->under_construction;
        node->end_location = offset;
        s->under_construction = node;
    }
}
static parsed_id construct_finish(struct construct_state *s, size_t offset) {
    parsed_id finished = 0;
    if (s->root_type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = s->current_expression;
        s->current_expression = expr->parent;
        while (expr->first_operator) construct_expression_reduce(s, expr);
        struct construct_node *node = expr->first_value;
        if (node) {
            finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            assert(node->next == 0);
            construct_node_free(s, node);
        }
        construct_expression_free(s, expr);
    }
    else {
        struct construct_node *node = s->under_construction;
        s->under_construction = node->next;
        node->start_location = offset;
        finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
        construct_node_free(s, node);
    }
    while (s->node_freelist) {
        struct construct_node *node = s->node_freelist;
        s->node_freelist = node->next;
        free(node->slots);
        free(node);
    }
    while (s->expression_freelist) {
        struct construct_expression *expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        free(expr);
    }
    return finished;
}
static void construct_action_apply(struct construct_state *s, uint16_t action, size_t offset) {
    switch ((((action) >> 12) & 0xf)) {
    case 8:
        {
            struct construct_node *node = construct_node_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            node->next = s->under_construction;
            node->slot_index = ((action) & 0xfff);
            node->end_location = offset;
            s->under_construction = node;
            break;
        }
    case 9:
        {
            struct construct_expression *expr = construct_expression_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            expr->parent = s->current_expression;
            s->current_expression = expr;
            expr->slot_index = ((action) & 0xfff);
            break;
        }
    case 1:
        {
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            parsed_id *finished;
            finished = &s->under_construction->slots[node->slot_index];
            *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            construct_node_free(s, node);
            break;
        }
    case 2:
        {
            struct construct_expression *expr = s->current_expression;
            s->current_expression = expr->parent;
            while (expr->first_operator) construct_expression_reduce(s, expr);
            parsed_id *finished;
            finished = &s->under_construction->slots[expr->slot_index];
            struct construct_node *node = expr->first_value;
            if (node) {
                *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
                assert(node->next == 0);
                construct_node_free(s, node);
            }
            construct_expression_free(s, expr);
            break;
        }
    case 3:
        s->under_construction->choice_index = ((action) & 0xfff);
        break;
    case 4:
        {
            uint16_t slot = ((action) & 0xfff);
            parsed_id *finished = &s->under_construction->slots[slot];
            *finished = finish_token(rule_lookup(s->under_construction->rule, slot, s->info), *finished, s->info);
            break;
        }
    case 10:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 11:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            enum construct_fixity_associativity fixity_associativity;
            int precedence;
            do {
                int local;
                fixity_associativity_precedence_lookup(&local, &precedence, expr->rule, ((action) & 0xfff), s->info);
                fixity_associativity = local;
            }
            while (0);
            node->fixity_associativity = fixity_associativity;
            node->precedence = precedence;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 5:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            node->next = expr->first_value;
            expr->first_value = node;
            break;
        }
    case 6:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            while (construct_expression_should_reduce(s, expr, node)) construct_expression_reduce(s, expr);
            node->next = expr->first_operator;
            expr->first_operator = node;
            if (node->fixity_associativity == CONSTRUCT_PREFIX) construct_expression_reduce(s, expr);
            break;
        }
    }
}

struct fill_run_state {
    uint32_t state;
    uint32_t reachability_mask[1];
};
struct fill_run_continuation {
    struct fill_run_state *stack;
    uint32_t depth;
    uint32_t capacity;
};
static bool fill_run_states(struct bluebird_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index);
static parsed_id build_parse_tree(struct bluebird_default_tokenizer *, struct bluebird_token_run *, struct bluebird_tree *);

static struct bluebird_tree *bluebird_tree_create_empty(void) {
    return calloc(1, sizeof(struct bluebird_tree));
}

struct bluebird_tree *bluebird_tree_create_from_string(const char *string) {
    struct bluebird_tree *tree = bluebird_tree_create_empty();
    tree->string = string;
    tree->next_id = 1;
    struct bluebird_default_tokenizer tokenizer = {
        .text = string,
        .info = tree,
    };
    struct bluebird_token_run *token_run = 0;
    struct fill_run_continuation c = {
        .capacity = 8,
        .depth = 1,
    };
    c.stack = calloc(c.capacity, sizeof(struct fill_run_state));
    c.stack[0].state = 0;
    uint16_t failing_index = 0;
    while (bluebird_default_tokenizer_advance(&tokenizer, &token_run)) {
        if (!fill_run_states(token_run, &c, &failing_index)) {
            free(c.stack);
            tree->error = ERROR_UNEXPECTED_TOKEN;
            find_token_range(&tokenizer, token_run, failing_index, &tree->error_range.start, &tree->error_range.end);
            return tree;
        }
    }
    uint32_t final_state = c.stack[c.depth - 1].state;
    free(c.stack);
    if (string[tokenizer.offset] != '\0') {
        tree->error = ERROR_INVALID_TOKEN;
        tree->error_range.start = tokenizer.offset;
        tree->error_range.end = tokenizer.offset + 1;
        while (string[tree->error_range.end] != '\0' &&
         !char_is_whitespace(string[tree->error_range.end]) &&
         !char_continues_identifier(string[tree->error_range.end], tree))
            tree->error_range.end++;
        return tree;
    }
    switch (final_state) {
    case 0:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 11:
    case 13:
    case 16:
    case 18:
    case 19:
    case 51:
    case 58:
        break;
    default:
        tree->error = ERROR_MORE_INPUT_NEEDED;
        tree->error_range.start = tokenizer.offset - tokenizer.whitespace - 1;
        tree->error_range.end = tokenizer.offset - tokenizer.whitespace;
        if (tree->error_range.start > tree->error_range.end) {
            tree->error_range.start = tree->error_range.end;
            tree->error_range.end++;
        }
        return tree;
    }
    tree->root_id = build_parse_tree(&tokenizer, token_run, tree);
    return tree;
}
static struct bluebird_tree *bluebird_tree_create_with_error(enum bluebird_error e) {
    struct bluebird_tree *tree = bluebird_tree_create_empty();
    tree->error = e;
    return tree;
}
struct bluebird_tree *bluebird_tree_create_from_file(FILE *file) {
    if (!file)
        return bluebird_tree_create_with_error(ERROR_INVALID_FILE);
    char *str = 0;
    size_t len = 32;
    size_t off = 0;
    while (true) {
        len = len * 3 / 2;
        char *s = realloc(str, len * 3 / 2);
        if (!s) {
            free(str);
            return 0;
        }
        str = s;
        off += fread(str + off, 1, len - off, file);
        if (off < len) {
            str[off] = '\0';
            break;
        }
    }
    struct bluebird_tree *tree = bluebird_tree_create_from_string(str);
    if (!tree) {
        free(str);
        return 0;
    }
    tree->owns_string = true;
    return tree;
}
enum bluebird_error bluebird_tree_get_error(struct bluebird_tree *tree, struct source_range *error_range) {
    if (error_range)
        *error_range = tree->error_range;
    return tree->error;
}
void bluebird_tree_destroy(struct bluebird_tree *tree) {
    if (tree->owns_string)
        free((void *)tree->string);
    free(tree->parse_tree);
    free(tree->identifier_tokens);
    free(tree->number_tokens);
    for (uint32_t i = 0; i < tree->number_of_string_tokens; ++i) {
        if (tree->string_tokens[i].has_escapes)
            free((void *)tree->string_tokens[i].string);
    }
    free(tree->string_tokens);
    free(tree);
}
static void grow_cont_stack(struct fill_run_continuation *cont) {
    size_t new_capacity = (cont->capacity + 2) * 3 / 2;
    if (new_capacity <= cont->capacity)
        abort();
    struct fill_run_state *new_states = realloc(cont->stack, new_capacity * sizeof(struct fill_run_state));
    if (!new_states)
        abort();
    cont->stack = new_states;
    cont->capacity = new_capacity;
}
static bool fill_run_states(struct bluebird_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index) {
    uint16_t token_index = 0;
    uint16_t number_of_tokens = run->number_of_tokens;
    struct fill_run_state top = cont->stack[cont->depth - 1];
    if (top.state == 0) {
        // This is unnecessary, but it avoids a compiler warning about unused labels.
        goto state_0;
    }
start:
    switch (top.state) {
    case 0:
state_0: {
        if (token_index >= number_of_tokens) {
            top.state = 0;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 0;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 21: goto state_2;
        default: token_index--; break;
        }
        break;
    }
    case 1:
state_1: {
        if (token_index >= number_of_tokens) {
            top.state = 1;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 1;
        token_index++;
        switch (token) {
        case 23: goto state_58;
        default: token_index--; break;
        }
        break;
    }
    case 2:
state_2: {
        if (token_index >= number_of_tokens) {
            top.state = 2;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 2;
        token_index++;
        switch (token) {
        case 1: goto state_3;
        default: token_index--; break;
        }
        break;
    }
    case 3:
state_3: {
        if (token_index >= number_of_tokens) {
            top.state = 3;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 3;
        token_index++;
        switch (token) {
        case 21: goto state_4;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 3;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 4:
state_4: {
        if (token_index >= number_of_tokens) {
            top.state = 4;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 4;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 11: goto state_14;
        case 12: goto state_15;
        case 17: goto state_9;
        case 18: goto state_10;
        case 19: goto state_11;
        case 20: goto state_12;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 4;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 5:
state_5: {
        if (token_index >= number_of_tokens) {
            top.state = 5;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 5;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 17: goto state_9;
        case 18: goto state_10;
        case 19: goto state_11;
        case 20: goto state_12;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 5;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 6:
state_6: {
        if (token_index >= number_of_tokens) {
            top.state = 6;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 6;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 17: goto state_9;
        case 18: goto state_10;
        case 19: goto state_11;
        case 20: goto state_12;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 6;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 7:
state_7: {
        if (token_index >= number_of_tokens) {
            top.state = 7;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 7;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 17: goto state_9;
        case 18: goto state_10;
        case 19: goto state_11;
        case 20: goto state_12;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 7;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 8:
state_8: {
        if (token_index >= number_of_tokens) {
            top.state = 8;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 8;
        token_index++;
        switch (token) {
        case 21: goto state_19;
        default: token_index--; break;
        }
        break;
    }
    case 9:
state_9: {
        if (token_index >= number_of_tokens) {
            top.state = 9;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 9;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 17: goto state_9;
        case 18: goto state_10;
        case 19: goto state_11;
        case 20: goto state_12;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 9;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 10:
state_10: {
        if (token_index >= number_of_tokens) {
            top.state = 10;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 10;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 17: goto state_9;
        case 18: goto state_10;
        case 19: goto state_11;
        case 20: goto state_12;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 10;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 11:
state_11: {
        if (token_index >= number_of_tokens) {
            top.state = 11;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 11;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 17: goto state_9;
        case 18: goto state_10;
        case 19: goto state_11;
        case 20: goto state_12;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 11;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 12:
state_12: {
        if (token_index >= number_of_tokens) {
            top.state = 12;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 12;
        token_index++;
        switch (token) {
        case 21: goto state_4;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 12;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 13:
state_13: {
        if (token_index >= number_of_tokens) {
            top.state = 13;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 13;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 1: goto state_3;
        case 2: goto state_8;
        case 11: goto state_14;
        case 12: goto state_15;
        case 17: goto state_9;
        case 18: goto state_10;
        case 19: goto state_11;
        case 20: goto state_12;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 13;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 14:
state_14: {
        if (token_index >= number_of_tokens) {
            top.state = 14;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 14;
        token_index++;
        switch (token) {
        case 2: goto state_17;
        default: token_index--; break;
        }
        break;
    }
    case 15:
state_15: {
        if (token_index >= number_of_tokens) {
            top.state = 15;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 15;
        token_index++;
        switch (token) {
        case 21: goto state_16;
        default: token_index--; break;
        }
        break;
    }
    case 16:
state_16: {
        if (token_index >= number_of_tokens) {
            top.state = 16;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 16;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 17: goto state_9;
        case 18: goto state_10;
        case 19: goto state_11;
        case 20: goto state_12;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 16;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 17:
state_17: {
        if (token_index >= number_of_tokens) {
            top.state = 17;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 17;
        token_index++;
        switch (token) {
        case 21: goto state_18;
        default: token_index--; break;
        }
        break;
    }
    case 18:
state_18: {
        if (token_index >= number_of_tokens) {
            top.state = 18;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 18;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 2: goto state_8;
        case 11: goto state_14;
        case 12: goto state_15;
        case 17: goto state_9;
        case 18: goto state_10;
        case 19: goto state_11;
        case 20: goto state_12;
        case 21: goto state_13;
        case 23: goto state_5;
        case 24: goto state_6;
        case 25: goto state_7;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 18;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 19:
state_19: {
        if (token_index >= number_of_tokens) {
            top.state = 19;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 19;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 3: goto state_20;
        case 21: goto state_21;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 19;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 20:
state_20: {
        if (token_index >= number_of_tokens) {
            top.state = 20;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 20;
        token_index++;
        switch (token) {
        case 4: goto state_35;
        case 5: goto state_36;
        case 6: goto state_37;
        default: token_index--; break;
        }
        break;
    }
    case 21:
state_21: {
        if (token_index >= number_of_tokens) {
            top.state = 21;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 21;
        token_index++;
        switch (token) {
        case 1: goto state_3;
        case 2: goto state_8;
        case 11: goto state_30;
        case 12: goto state_31;
        case 17: goto state_25;
        case 18: goto state_26;
        case 19: goto state_27;
        case 20: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 21;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 22:
state_22: {
        if (token_index >= number_of_tokens) {
            top.state = 22;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 22;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 17: goto state_25;
        case 18: goto state_26;
        case 19: goto state_27;
        case 20: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 22;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 23:
state_23: {
        if (token_index >= number_of_tokens) {
            top.state = 23;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 23;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 17: goto state_25;
        case 18: goto state_26;
        case 19: goto state_27;
        case 20: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 23;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 24:
state_24: {
        if (token_index >= number_of_tokens) {
            top.state = 24;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 24;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 17: goto state_25;
        case 18: goto state_26;
        case 19: goto state_27;
        case 20: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 24;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 25:
state_25: {
        if (token_index >= number_of_tokens) {
            top.state = 25;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 25;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 17: goto state_25;
        case 18: goto state_26;
        case 19: goto state_27;
        case 20: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 25;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 26:
state_26: {
        if (token_index >= number_of_tokens) {
            top.state = 26;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 26;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 17: goto state_25;
        case 18: goto state_26;
        case 19: goto state_27;
        case 20: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 26;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 27:
state_27: {
        if (token_index >= number_of_tokens) {
            top.state = 27;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 27;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 17: goto state_25;
        case 18: goto state_26;
        case 19: goto state_27;
        case 20: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 27;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 28:
state_28: {
        if (token_index >= number_of_tokens) {
            top.state = 28;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 28;
        token_index++;
        switch (token) {
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 28;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 29:
state_29: {
        if (token_index >= number_of_tokens) {
            top.state = 29;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 29;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 11: goto state_30;
        case 12: goto state_31;
        case 17: goto state_25;
        case 18: goto state_26;
        case 19: goto state_27;
        case 20: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 29;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 30:
state_30: {
        if (token_index >= number_of_tokens) {
            top.state = 30;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 30;
        token_index++;
        switch (token) {
        case 2: goto state_33;
        default: token_index--; break;
        }
        break;
    }
    case 31:
state_31: {
        if (token_index >= number_of_tokens) {
            top.state = 31;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 31;
        token_index++;
        switch (token) {
        case 21: goto state_32;
        default: token_index--; break;
        }
        break;
    }
    case 32:
state_32: {
        if (token_index >= number_of_tokens) {
            top.state = 32;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 32;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 17: goto state_25;
        case 18: goto state_26;
        case 19: goto state_27;
        case 20: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 32;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 33:
state_33: {
        if (token_index >= number_of_tokens) {
            top.state = 33;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 33;
        token_index++;
        switch (token) {
        case 21: goto state_34;
        default: token_index--; break;
        }
        break;
    }
    case 34:
state_34: {
        if (token_index >= number_of_tokens) {
            top.state = 34;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 34;
        token_index++;
        switch (token) {
        case 2: goto state_8;
        case 11: goto state_30;
        case 12: goto state_31;
        case 17: goto state_25;
        case 18: goto state_26;
        case 19: goto state_27;
        case 20: goto state_28;
        case 21: goto state_29;
        case 23: goto state_22;
        case 24: goto state_23;
        case 25: goto state_24;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 34;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 35:
state_35: {
        if (token_index >= number_of_tokens) {
            top.state = 35;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 35;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 35;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 36:
state_36: {
        if (token_index >= number_of_tokens) {
            top.state = 36;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 36;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 36;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 37:
state_37: {
        if (token_index >= number_of_tokens) {
            top.state = 37;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 37;
        token_index++;
        switch (token) {
        case 7: goto state_38;
        case 8: goto state_39;
        case 9: goto state_40;
        case 10: goto state_41;
        default: token_index--; break;
        }
        break;
    }
    case 38:
state_38: {
        if (token_index >= number_of_tokens) {
            top.state = 38;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 38;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 38;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 39:
state_39: {
        if (token_index >= number_of_tokens) {
            top.state = 39;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 39;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 39;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 40:
state_40: {
        if (token_index >= number_of_tokens) {
            top.state = 40;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 40;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 40;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 41:
state_41: {
        if (token_index >= number_of_tokens) {
            top.state = 41;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 41;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 41;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 42:
state_42: {
        if (token_index >= number_of_tokens) {
            top.state = 42;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 42;
        token_index++;
        switch (token) {
        case 2: goto state_46;
        case 11: goto state_53;
        case 12: goto state_54;
        case 17: goto state_47;
        case 18: goto state_48;
        case 19: goto state_49;
        case 20: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 42;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 43:
state_43: {
        if (token_index >= number_of_tokens) {
            top.state = 43;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 43;
        token_index++;
        switch (token) {
        case 2: goto state_46;
        case 17: goto state_47;
        case 18: goto state_48;
        case 19: goto state_49;
        case 20: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 43;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 44:
state_44: {
        if (token_index >= number_of_tokens) {
            top.state = 44;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 44;
        token_index++;
        switch (token) {
        case 2: goto state_46;
        case 17: goto state_47;
        case 18: goto state_48;
        case 19: goto state_49;
        case 20: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 44;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 45:
state_45: {
        if (token_index >= number_of_tokens) {
            top.state = 45;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 45;
        token_index++;
        switch (token) {
        case 2: goto state_46;
        case 17: goto state_47;
        case 18: goto state_48;
        case 19: goto state_49;
        case 20: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 45;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 46:
state_46: {
        if (token_index >= number_of_tokens) {
            top.state = 46;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 46;
        token_index++;
        switch (token) {
        case 21: goto state_51;
        default: token_index--; break;
        }
        break;
    }
    case 47:
state_47: {
        if (token_index >= number_of_tokens) {
            top.state = 47;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 47;
        token_index++;
        switch (token) {
        case 2: goto state_46;
        case 17: goto state_47;
        case 18: goto state_48;
        case 19: goto state_49;
        case 20: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 47;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 48:
state_48: {
        if (token_index >= number_of_tokens) {
            top.state = 48;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 48;
        token_index++;
        switch (token) {
        case 2: goto state_46;
        case 17: goto state_47;
        case 18: goto state_48;
        case 19: goto state_49;
        case 20: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 48;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 49:
state_49: {
        if (token_index >= number_of_tokens) {
            top.state = 49;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 49;
        token_index++;
        switch (token) {
        case 2: goto state_46;
        case 17: goto state_47;
        case 18: goto state_48;
        case 19: goto state_49;
        case 20: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 49;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 50:
state_50: {
        if (token_index >= number_of_tokens) {
            top.state = 50;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 50;
        token_index++;
        switch (token) {
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 50;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 51:
state_51: {
        if (token_index >= number_of_tokens) {
            top.state = 51;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 51;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 3: goto state_20;
        case 21: goto state_52;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 51;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 52:
state_52: {
        if (token_index >= number_of_tokens) {
            top.state = 52;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 52;
        token_index++;
        switch (token) {
        case 1: goto state_3;
        case 2: goto state_46;
        case 11: goto state_53;
        case 12: goto state_54;
        case 17: goto state_47;
        case 18: goto state_48;
        case 19: goto state_49;
        case 20: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 52;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 53:
state_53: {
        if (token_index >= number_of_tokens) {
            top.state = 53;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 53;
        token_index++;
        switch (token) {
        case 2: goto state_56;
        default: token_index--; break;
        }
        break;
    }
    case 54:
state_54: {
        if (token_index >= number_of_tokens) {
            top.state = 54;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 54;
        token_index++;
        switch (token) {
        case 21: goto state_55;
        default: token_index--; break;
        }
        break;
    }
    case 55:
state_55: {
        if (token_index >= number_of_tokens) {
            top.state = 55;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 55;
        token_index++;
        switch (token) {
        case 2: goto state_46;
        case 17: goto state_47;
        case 18: goto state_48;
        case 19: goto state_49;
        case 20: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 55;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 56:
state_56: {
        if (token_index >= number_of_tokens) {
            top.state = 56;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 56;
        token_index++;
        switch (token) {
        case 21: goto state_57;
        default: token_index--; break;
        }
        break;
    }
    case 57:
state_57: {
        if (token_index >= number_of_tokens) {
            top.state = 57;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 57;
        token_index++;
        switch (token) {
        case 2: goto state_46;
        case 11: goto state_53;
        case 12: goto state_54;
        case 17: goto state_47;
        case 18: goto state_48;
        case 19: goto state_49;
        case 20: goto state_50;
        case 21: goto state_42;
        case 23: goto state_43;
        case 24: goto state_44;
        case 25: goto state_45;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 57;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 58:
state_58: {
        if (token_index >= number_of_tokens) {
            top.state = 58;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 58;
        token_index++;
        switch (token) {
        case 0: goto state_1;
        case 21: goto state_2;
        default: token_index--; break;
        }
        break;
    }
    case 59:
state_59: {
        if (!(3 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 59;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 59;
        token_index++;
        switch (token) {
        case 13: goto state_60;
        case 15: goto state_61;
        default: token_index--; break;
        }
        break;
    }
    case 60:
state_60: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 60;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 60;
        token_index++;
        switch (token) {
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 60;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 61:
state_61: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 61;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 61;
        token_index++;
        switch (token) {
        case 23: goto state_62;
        default: token_index--; break;
        }
        break;
    }
    case 62:
state_62: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 62;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 62;
        token_index++;
        switch (token) {
        case 21: goto state_63;
        case 23: goto state_64;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 62;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 63:
state_63: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 63;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 63;
        token_index++;
        switch (token) {
        case 11: goto state_74;
        case 12: goto state_75;
        case 17: goto state_67;
        case 18: goto state_68;
        case 19: goto state_69;
        case 20: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 63;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 64:
state_64: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 64;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 64;
        token_index++;
        switch (token) {
        case 16: goto state_72;
        case 17: goto state_67;
        case 18: goto state_68;
        case 19: goto state_69;
        case 20: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 64;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 65:
state_65: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 65;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 65;
        token_index++;
        switch (token) {
        case 17: goto state_67;
        case 18: goto state_68;
        case 19: goto state_69;
        case 20: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 65;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 66:
state_66: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 66;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 66;
        token_index++;
        switch (token) {
        case 17: goto state_67;
        case 18: goto state_68;
        case 19: goto state_69;
        case 20: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 66;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 67:
state_67: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 67;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 67;
        token_index++;
        switch (token) {
        case 17: goto state_67;
        case 18: goto state_68;
        case 19: goto state_69;
        case 20: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 67;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 68:
state_68: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 68;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 68;
        token_index++;
        switch (token) {
        case 17: goto state_67;
        case 18: goto state_68;
        case 19: goto state_69;
        case 20: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 68;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 69:
state_69: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 69;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 69;
        token_index++;
        switch (token) {
        case 17: goto state_67;
        case 18: goto state_68;
        case 19: goto state_69;
        case 20: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 69;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 70:
state_70: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 70;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 70;
        token_index++;
        switch (token) {
        case 21: goto state_63;
        case 23: goto state_73;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 70;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 71:
state_71: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 71;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 71;
        token_index++;
        switch (token) {
        case 16: goto state_72;
        case 17: goto state_67;
        case 18: goto state_68;
        case 19: goto state_69;
        case 20: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 71;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 72:
state_72: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (cont->depth == 0)
            break;
        cont->depth--;
        top = cont->stack[cont->depth - 1];
        run->tokens[token_index] = 25;
        goto start;
    }
    case 73:
state_73: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 73;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 73;
        token_index++;
        switch (token) {
        case 17: goto state_67;
        case 18: goto state_68;
        case 19: goto state_69;
        case 20: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 73;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 74:
state_74: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 74;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 74;
        token_index++;
        switch (token) {
        case 2: goto state_77;
        default: token_index--; break;
        }
        break;
    }
    case 75:
state_75: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 75;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 75;
        token_index++;
        switch (token) {
        case 21: goto state_76;
        default: token_index--; break;
        }
        break;
    }
    case 76:
state_76: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 76;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 76;
        token_index++;
        switch (token) {
        case 17: goto state_67;
        case 18: goto state_68;
        case 19: goto state_69;
        case 20: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 76;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 77:
state_77: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 77;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 77;
        token_index++;
        switch (token) {
        case 21: goto state_78;
        default: token_index--; break;
        }
        break;
    }
    case 78:
state_78: {
        if (!(2 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 78;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 78;
        token_index++;
        switch (token) {
        case 11: goto state_74;
        case 12: goto state_75;
        case 17: goto state_67;
        case 18: goto state_68;
        case 19: goto state_69;
        case 20: goto state_70;
        case 21: goto state_63;
        case 23: goto state_71;
        case 24: goto state_65;
        case 25: goto state_66;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 78;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 79:
state_79: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 79;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 79;
        token_index++;
        switch (token) {
        case 11: goto state_88;
        case 12: goto state_89;
        case 14: goto state_83;
        case 17: goto state_84;
        case 18: goto state_85;
        case 19: goto state_86;
        case 20: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 79;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 80:
state_80: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 80;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 80;
        token_index++;
        switch (token) {
        case 14: goto state_83;
        case 17: goto state_84;
        case 18: goto state_85;
        case 19: goto state_86;
        case 20: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 80;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 81:
state_81: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 81;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 81;
        token_index++;
        switch (token) {
        case 14: goto state_83;
        case 17: goto state_84;
        case 18: goto state_85;
        case 19: goto state_86;
        case 20: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 81;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 82:
state_82: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 82;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 82;
        token_index++;
        switch (token) {
        case 14: goto state_83;
        case 17: goto state_84;
        case 18: goto state_85;
        case 19: goto state_86;
        case 20: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 82;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 83:
state_83: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (cont->depth == 0)
            break;
        cont->depth--;
        top = cont->stack[cont->depth - 1];
        run->tokens[token_index] = 24;
        goto start;
    }
    case 84:
state_84: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 84;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 84;
        token_index++;
        switch (token) {
        case 14: goto state_83;
        case 17: goto state_84;
        case 18: goto state_85;
        case 19: goto state_86;
        case 20: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 84;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 85:
state_85: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 85;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 85;
        token_index++;
        switch (token) {
        case 14: goto state_83;
        case 17: goto state_84;
        case 18: goto state_85;
        case 19: goto state_86;
        case 20: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 85;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 86:
state_86: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 86;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 86;
        token_index++;
        switch (token) {
        case 14: goto state_83;
        case 17: goto state_84;
        case 18: goto state_85;
        case 19: goto state_86;
        case 20: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 86;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 87:
state_87: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 87;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 87;
        token_index++;
        switch (token) {
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 87;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 88:
state_88: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 88;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 88;
        token_index++;
        switch (token) {
        case 2: goto state_91;
        default: token_index--; break;
        }
        break;
    }
    case 89:
state_89: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 89;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 89;
        token_index++;
        switch (token) {
        case 21: goto state_90;
        default: token_index--; break;
        }
        break;
    }
    case 90:
state_90: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 90;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 90;
        token_index++;
        switch (token) {
        case 14: goto state_83;
        case 17: goto state_84;
        case 18: goto state_85;
        case 19: goto state_86;
        case 20: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 90;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    case 91:
state_91: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 91;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 91;
        token_index++;
        switch (token) {
        case 21: goto state_92;
        default: token_index--; break;
        }
        break;
    }
    case 92:
state_92: {
        if (!(1 & top.reachability_mask[0]))
            break;
        if (token_index >= number_of_tokens) {
            top.state = 92;
            cont->stack[cont->depth - 1] = top;
            return true;
        }
        uint32_t token = run->tokens[token_index];
        run->states[token_index] = 92;
        token_index++;
        switch (token) {
        case 11: goto state_88;
        case 12: goto state_89;
        case 14: goto state_83;
        case 17: goto state_84;
        case 18: goto state_85;
        case 19: goto state_86;
        case 20: goto state_87;
        case 21: goto state_79;
        case 23: goto state_80;
        case 24: goto state_81;
        case 25: goto state_82;
        default:
            if (cont->depth >= cont->capacity)
                grow_cont_stack(cont);
            top.state = 92;
            cont->stack[cont->depth - 1] = top;
            cont->depth++;
            top.reachability_mask[0] = 3;
            token_index--;
            goto state_59;
        }
        break;
    }
    }
    *failing_index = token_index;
    return false;
}
static const uint16_t actions[] = {
0,0,4096,0,4096,16385,0,4096,32768,16384,0,4096,32769,32769,16385,0,4096,32769,32769,32770,32769,16385,0,4096,32769,32769,36864,40960,16384,0,
4096,32769,32769,36864,40960,16385,0,4096,32769,32769,36864,40960,16386,0,4096,32769,32769,36864,40961,16387,0,4096,32769,32769,36864,40962,0,4096,32769,32769,
36864,40963,0,4096,32769,32769,36864,45060,0,4096,32769,32769,36864,45061,0,4096,32769,32769,36864,45062,0,4096,32770,32769,16385,0,16384,0,16385,0,
16389,0,16390,0,20480,8192,0,20480,8192,4096,0,20480,8192,4096,32768,12288,0,20480,8192,4096,32768,12289,0,20480,8192,4096,32768,12290,32768,12288,
0,20480,8192,4096,32768,12290,32768,12289,0,20480,8192,4096,32768,12290,32768,12290,0,20480,8192,4096,32768,12290,32768,12291,0,20480,8192,4096,32769,16385,
0,20480,8192,16385,0,20480,8192,16389,0,20480,45063,24576,40960,16384,0,20480,45063,24576,40960,16385,0,20480,45063,24576,40960,16386,0,20480,45063,24576,
40961,16387,0,20480,45063,24576,40962,0,20480,45063,24576,40963,0,20480,45063,24576,45060,0,20480,45063,24576,45061,0,20480,45063,24576,45062,0,20480,45064,
0,24576,40960,16384,0,24576,40960,16385,0,24576,40960,16386,0,24576,40961,16387,0,24576,40962,0,24576,40963,0,24576,45060,0,24576,45061,0,24576,
45062,0,32768,16384,0,32769,32769,16385,0,32769,32769,32770,32769,16385,0,32769,32769,36864,40960,16384,0,32769,32769,36864,40960,16385,0,32769,32769,36864,
40960,16386,0,32769,32769,36864,40961,16387,0,32769,32769,36864,40962,0,32769,32769,36864,40963,0,32769,32769,36864,45060,0,32769,32769,36864,45061,0,32769,
32769,36864,45062,0,36864,40960,16384,0,36864,40960,16385,0,36864,40960,16386,0,36864,40961,16387,0,36864,40962,0,36864,40963,0,36864,45060,0,36864,
45061,0,36864,45062,0,36868,40960,16384,0,36868,40960,16385,0,36868,40960,16386,0,36868,40961,16387,0,36868,40962,0,36868,40963,0,36868,45060,0,
36868,45061,0,36868,45062,0,};
struct action_table_entry {
    uint32_t target_nfa_state;
    uint32_t dfa_state;
    uint32_t dfa_symbol;
    uint32_t nfa_state;
    uint32_t actions;
    uint32_t push_nfa_state;
};
static const struct action_table_entry action_table[2048][3] = {
{{392,22,19,392,239},},{0},{{1815,82,18,1816,360},},{{19,63,18,19,236},},{{392,26,19,392,239},},{0},{0},{0},{0},{0},{{3,67,19,19,203},},{{0,50,24,1828,183,0},
{0,39,25,1835,188,0},},{0},{{1,50,23,0,316},},{{1816,80,19,1816,239},{42,12,21,8,255},},{0},{0},{{100,7,23,8,223},},{{26,67,18,19,360},},
{{1832,13,11,1823,0},{3,62,23,3,177},},{0},{{392,21,21,11,211},{0,57,17,2,193},},{{546,32,17,392,326},{26,71,18,19,360},},
{{0,42,20,2,208},},{0},{{1161,16,25,1835,323,8},{27,18,17,100,63},},{{76,86,21,76,159},{42,4,25,1835,284,8},},{{47,16,21,8,255},},
{{8,18,19,100,203},},{0},{0},{{1816,92,18,1816,236},{42,11,19,100,299},{3,68,17,19,193},},{0},{{1820,5,21,27,86},{8,5,25,1835,188,8},},
{{1,55,21,0,304},},{0},{{1815,87,21,76,335},{19,71,25,1835,230,3},},{0},{{3,64,24,1828,183,3},},{{26,78,18,19,360},{1,51,24,1828,320,0},},
{0},{0},{{27,6,18,100,69},},{0},{0},{{8,13,21,8,159},{0,41,25,1835,188,0},},{{100,6,25,1835,230,8},},{{1,42,21,0,304},},{{1815,79,25,1835,354,76},
{3,63,21,3,159},},{{0,45,25,1835,188,0},},{{76,85,18,1816,198},{3,77,21,1850,165},},{0},{{1827,48,2,1,0},{26,70,21,3,335},},
{0},{{76,81,18,1816,198},},{{1815,92,21,76,335},{3,73,24,1828,183,3},},{{546,22,17,392,326},{1,52,24,1828,320,0},},{{392,24,24,1828,227,11},},
{{2,56,21,1845,215},},{{1819,5,0,27,0},{3,69,24,1828,183,3},},{{1823,7,21,8,86},{11,23,25,1835,188,11},},{{0,48,20,2,208},},
{{392,28,23,11,223},{0,37,10,1846,137},},{{100,10,24,1828,227,8},},{0},{{2,47,17,2,233},},{0},{{1834,4,12,1823,0},{76,92,18,1816,198},},
{{1,47,19,2,332},},{{1827,57,2,1,0},{47,12,23,8,273},},{{1161,5,19,100,332},},{{76,79,17,1816,193},},{{11,31,21,1831,171},
{3,78,24,1828,183,3},},{{26,65,23,3,347},},{{392,19,24,1828,227,11},{0,40,23,0,177},},{0},{{1828,79,14,1815,0},},{{1824,63,23,26,92},
{11,27,24,1828,183,11},},{{392,23,24,1828,227,11},},{0},{{100,13,24,1828,227,8},},{0},{0},{{392,27,21,11,211},},{{1816,90,19,1816,239},{1816,79,18,1816,236},
{76,80,21,76,159},},{0},{{2,42,19,2,239},},{{100,9,23,8,223},},{{42,9,18,100,294},{3,66,20,19,208},},{{1815,81,18,1816,360},},
{{47,9,21,8,255},},{{1161,10,17,100,326},},{{1,49,21,0,304},},{{1819,19,0,27,0},{1816,81,25,1835,230,76},{1815,85,18,1816,360},},
{{19,69,17,19,233},},{{0,55,21,0,159},},{{8,11,18,100,198},},{0},{{19,65,17,19,233},{11,28,24,1828,183,11},},{0},{0},{{1816,85,21,76,211},},
{{0,43,20,2,208},},{0},{0},{{76,87,23,76,177},{42,5,19,100,299},},{{11,24,20,392,208},},{0},{0},{{26,68,18,19,360},},{0},{0},{{392,26,23,11,223},},
{0},{{47,10,18,100,294},},{0},{0},{{1828,86,14,1815,0},{8,6,18,100,198},},{{546,24,25,1835,323,11},},{0},{0},{{1,45,24,1828,320,0},},{{1816,80,23,76,223},},
{0},{0},{{1818,39,21,0,86},{100,7,19,100,239},},{{1,41,23,0,316},},{{11,29,20,392,208},},{0},{{3,76,23,3,177},},{{546,32,21,11,304},},
{{546,19,23,11,316},{0,42,24,1828,183,0},},{0},{{27,18,21,8,23},},{{11,25,21,11,159},},{{1826,85,21,76,86},{47,16,17,100,289},
{47,7,18,100,294},},{{8,18,23,8,177},},{{27,13,18,100,69},{2,57,23,0,223},},{{1,38,24,1828,320,0},},{0},{{0,49,20,2,208},},
{{76,82,18,1816,198},},{{1822,32,21,11,86},{1,55,25,1835,323,0},},{0},{0},{{8,9,21,8,159},},{0},{{1817,29,2,546,0},},{{47,15,21,1834,267},},
{0},{{42,16,25,1835,284,8},},{0},{0},{{8,13,25,1835,188,8},{0,41,21,0,159},},{0},{{11,26,19,392,203},},{{2,48,19,2,239},},{0},{{1816,87,24,1828,227,76},},
{0},{0},{{2,39,25,1835,230,0},},{0},{{1816,91,21,1842,215},{1815,92,25,1835,354,76},{3,73,20,19,208},},{0},{0},{0},{{1828,84,14,1815,0},},{0},{{0,48,24,1828,183,0},},
{0},{{546,26,18,392,329},{26,73,21,3,335},},{{11,19,21,11,159},},{{2,47,21,0,211},},{{392,32,19,392,239},{0,52,23,0,177},},
{{3,65,24,1828,183,3},},{{1,47,23,0,316},},{0},{{1161,5,23,8,316},},{{1816,82,24,1828,227,76},},{{3,78,20,19,208},},{{26,65,19,19,363},},
{{27,3,23,8,44},},{{100,18,24,1828,227,8},},{{42,6,25,1835,284,8},},{{11,34,17,392,193},{11,27,20,392,208},},{{47,18,18,100,294},},
{{1161,18,25,1835,323,8},{100,13,23,8,223},},{{26,62,21,3,335},},{0},{{27,16,24,1828,51,8},},{{392,27,17,392,233},{8,3,25,1835,188,8},},
{{1816,90,23,76,223},{76,80,17,1816,193},{3,70,24,1828,183,3},},{{1826,91,21,1842,88},},{{19,73,25,1835,230,3},{2,42,23,0,223},},
{0},{{3,66,24,1828,183,3},},{0},{0},{{1161,10,21,8,304},},{{1,49,17,2,326},},{{1816,81,21,76,211},},{{19,69,21,3,211},},{{42,18,18,100,294},
{42,13,17,100,289},},{{100,4,25,1835,230,8},},{{47,13,18,100,294},},{0},{{27,4,25,1835,57,8},},{0},{0},{0},{{19,78,23,3,223},},{0},{{42,5,23,8,273},},
{0},{{392,22,24,1828,227,11},},{{100,12,21,8,211},},{{1818,43,21,0,86},},{0},{{392,26,24,1828,227,11},},{{3,71,17,19,193},},{0},{{1827,42,2,1,0},},
{0},{0},{{1815,86,17,1816,357},{11,21,18,392,198},},{0},{0},{{2,45,18,2,236},},{{1161,11,18,100,329},},{{19,66,18,19,236},},{0},{0},{{1161,7,18,100,329},},
{{546,28,25,1835,323,11},},{{2,49,21,0,211},},{{392,21,24,1828,227,11},},{{3,76,19,19,203},},{{546,32,25,1835,323,11},},{{1821,70,21,3,86},},
{0},{{1833,34,11,1822,0},},{{1823,17,21,1844,88},{11,32,20,392,208},{11,25,17,392,193},},{{546,23,19,392,332},},{0},{{2,57,19,2,239},},
{{1828,85,14,1815,0},},{0},{0},{{8,5,17,100,193},},{0},{{19,71,18,19,236},},{{27,9,23,8,44},},{{8,9,17,100,193},},{0},{0},{0},{{1161,4,21,8,304},},
{0},{0},{{1847,61,23,1848,90},},{0},{{26,66,19,19,363},{1,42,24,1828,320,0},},{{1815,79,18,1816,360},{11,26,23,11,177},},{{2,48,23,0,223},},
{{0,45,17,2,193},},{0},{0},{0},{0},{0},{0},{{1817,6,2,1161,0},{546,22,25,1835,323,11},},{{27,10,17,100,63},{2,43,21,0,211},},{{1,39,21,0,304},},
{{42,10,18,100,294},},{{1837,19,3,1836,2},{11,23,17,392,193},},{{1821,76,21,3,86},},{{1161,9,23,8,316},{100,10,21,8,211},},
{{26,73,17,19,357},{1,35,24,1828,320,0},},{{1823,11,21,8,86},},{{19,68,23,3,223},{2,47,25,1835,230,0},},{{392,32,23,11,223},
{0,52,19,2,203},},{{1,47,24,1828,320,0},},{0},{0},{{27,7,19,100,75},},{{1828,92,14,1815,0},{1820,19,21,27,86},{76,79,25,1835,188,76},},
{0},{{392,19,23,11,223},{0,40,24,1828,183,0},},{0},{0},{{1816,86,23,76,223},{42,6,21,8,255},},{{11,34,21,11,159},},{{76,84,19,1816,203},},
{{100,13,19,100,239},},{{47,1,23,1819,242},{1,36,24,1828,320,0},},{0},{0},{{1816,90,24,1828,227,76},{1816,79,25,1835,230,76},{3,70,23,3,177},},
{{546,21,18,392,329},},{0},{{19,73,21,3,211},},{{27,11,18,100,69},},{0},{0},{{8,7,20,100,208},{0,51,24,1828,183,0},},{{1161,10,25,1835,323,8},},
{0},{{1816,81,17,1816,233},},{{0,55,24,1828,183,0},},{{42,13,21,8,255},{8,11,25,1835,188,8},},{0},{{546,29,19,392,332},},{{1815,90,18,1816,360},
{19,65,25,1835,230,3},},{0},{{1816,85,24,1828,227,76},},{{1,57,24,1828,320,0},},{0},{{19,78,19,19,239},},{0},{0},{{0,47,20,2,208},},{0},{{100,12,25,1835,230,8},},
{0},{{1833,29,11,1822,0},},{{0,35,25,1835,188,0},},{{3,71,21,3,159},},{0},{0},{0},{0},{{1815,86,21,76,335},{3,67,24,1828,183,3},},{{546,24,17,392,326},},
{{0,39,21,0,159},},{0},{{1828,82,14,1815,0},{1816,80,24,1828,227,76},},{0},{{1821,66,21,3,86},{392,34,24,1828,227,11},},{{1817,34,2,546,0},
{8,10,19,100,203},},{{100,16,24,1828,227,8},},{{1823,13,21,8,86},{11,29,25,1835,188,11},},{{2,49,17,2,233},},{{0,57,24,1828,183,0},},
{{1820,13,21,27,86},{0,20,4,1837,101},},{0},{0},{{1161,3,23,8,316},{27,18,24,1828,51,8},},{{42,4,18,100,294},},{{11,32,24,1828,183,11},},
{{546,23,23,11,316},{47,16,25,1835,284,8},},{{392,25,24,1828,227,11},},{{1,38,23,0,316},},{{1819,4,0,27,0},{3,68,24,1828,183,3},},
{{11,22,23,11,177},},{{392,29,24,1828,227,11},},{{8,5,21,8,159},},{{47,11,19,100,299},},{0},{{27,9,19,100,75},},{{392,33,21,1849,215},},
{{76,60,23,76,177},{3,64,20,19,208},},{0},{{2,44,23,0,223},},{{1161,4,17,100,326},{27,6,25,1835,57,8},},{{1820,58,21,27,86},
{42,16,17,100,289},},{0},{0},{{100,6,18,100,236},},{{26,66,23,3,347},},{{3,63,18,19,198},},{{1824,78,23,26,92},},{{0,45,21,0,159},},
{0},{0},{{19,76,18,19,236},},{0},{0},{{47,4,17,100,289},},{{392,24,17,392,233},},{{27,10,21,8,23},{2,43,17,2,233},},{{1161,13,19,100,332},
{1,39,25,1835,323,0},},{{3,69,20,19,208},},{{1815,80,18,1816,360},{11,23,21,11,159},},{{8,4,20,100,208},},{{1818,56,21,1845,88},
{1161,9,19,100,332},{100,10,17,100,233},},{{1,48,19,2,332},},{{1819,18,0,27,0},{1815,84,18,1816,360},},{{19,68,19,19,239},},
{{3,65,21,3,159},},{{26,77,21,1850,339},},{0},{{19,64,19,19,239},},{{27,7,23,8,44},},{0},{{546,34,25,1835,323,11},},{0},{{2,55,18,2,236},},
{{1,43,24,1828,320,0},},{{1816,86,19,1816,239},{42,6,17,100,289},},{{392,23,19,392,239},{0,44,20,2,208},},{{76,84,23,76,177},},
{{1161,18,17,100,326},},{{26,69,18,19,360},},{0},{0},{0},{0},{0},{{19,73,17,19,233},},{{42,9,21,8,255},{3,66,19,19,203},},{0},{0},{{8,7,24,1828,183,8},
{0,36,23,0,177},},{0},{{1,49,25,1835,323,0},{1,44,24,1828,320,0},},{0},{0},{{42,13,25,1835,284,8},{8,11,21,8,159},},{{100,4,17,100,233},
{1,40,24,1828,320,0},},{{546,29,23,11,316},{26,76,18,19,360},},{0},{{76,91,21,1842,165},},{0},{{26,64,18,19,360},},{{0,43,24,1828,183,0},},
{0},{{3,75,21,1839,171},},{0},{{47,6,18,100,294},{0,47,24,1828,183,0},},{0},{0},{{1815,82,21,76,335},},{0},{{0,35,21,0,159},},{{3,71,25,1835,188,3},},
{{1818,47,21,0,86},},{0},{{1822,33,21,1849,88},{2,41,25,1835,230,0},},{0},{{1815,86,25,1835,354,76},{3,67,20,19,208},},{{546,24,21,11,304},},
{{1831,29,12,1822,0},{2,45,25,1835,230,0},},{{1,45,17,2,326},},{0},{{1833,21,11,1822,0},},{0},{{8,10,23,8,177},},{{26,67,21,3,335},},
{0},{{27,5,24,1828,51,8},},{{0,57,20,2,208},},{{1816,84,24,1828,227,76},{76,90,18,1816,198},},{{1826,60,21,76,86},{0,42,17,2,193},},
{0},{0},{{1828,90,14,1815,0},{76,86,18,1816,198},},{{11,25,25,1835,188,11},},{{1817,5,2,1161,0},{392,25,23,11,223},},{0},{{1161,12,25,1835,323,8},},
{{1816,92,23,76,223},{3,68,20,19,208},},{{11,22,19,392,203},},{{0,49,24,1828,183,0},},{{1848,59,15,1843,0},{1,55,18,2,329},},
{{546,27,18,392,329},{47,11,23,8,273},},{0},{0},{{8,9,25,1835,188,8},},{{26,78,23,3,347},},{0},{{19,67,25,1835,230,3},{2,44,19,2,239},},
{{27,6,21,8,23},},{{42,16,21,8,255},},{0},{0},{{1822,27,21,11,86},{2,35,25,1835,230,0},},{0},{0},{0},{{76,85,21,76,159},{42,7,17,100,289},},
{0},{{26,63,19,19,363},},{0},{{2,52,18,2,236},{2,39,21,0,211},},{0},{{546,22,18,392,329},{47,4,21,8,255},},{{392,24,21,11,211},},
{{27,10,25,1835,57,8},},{{1161,13,23,8,316},},{0},{{0,48,17,2,193},},{{392,28,24,1828,227,11},},{0},{{26,73,25,1835,354,3},{1,48,23,0,316},},
{{11,19,25,1835,188,11},},{{392,32,24,1828,227,11},},{{3,65,17,19,193},},{{100,5,23,8,223},},{0},{{19,64,23,3,223},},{{1816,82,17,1816,233},
{76,79,20,1816,208},},{0},{0},{0},{0},{0},{{11,34,24,1828,183,11},},{{392,23,23,11,223},{47,18,25,1835,284,8},},{{8,16,19,100,203},},{{1161,18,21,8,304},},
{{26,62,25,1835,354,3},},{{27,16,19,100,75},},{{392,27,24,1828,227,11},},{{1816,79,17,1816,233},},{{1817,18,2,1161,0},},{{47,5,18,100,294},},
{{100,9,18,100,236},},{{42,9,17,100,289},{3,66,23,3,177},},{0},{{546,25,23,11,316},{47,9,18,100,294},},{0},{{1,44,23,0,316},},
{{1815,85,23,76,347},},{0},{0},{{8,11,17,100,193},},{{1161,6,18,100,329},{100,4,21,8,211},},{0},{0},{0},{0},{{1817,27,2,546,0},},{0},{0},{{3,61,23,1848,155},},
{{11,24,19,392,203},},{0},{0},{{26,68,23,3,347},},{{1815,82,17,1816,357},},{{1824,68,23,26,92},{19,63,19,19,239},},{0},{0},{{47,10,21,8,255},},
{0},{{2,41,21,0,211},},{{8,6,23,8,177},},{0},{{0,50,25,1835,188,0},{0,39,24,1828,183,0},},{0},{{1,45,21,0,304},},{0},{{1823,9,21,8,86},},
{{8,10,24,1828,183,8},},{{100,16,21,8,211},},{{26,67,17,19,357},{1,41,24,1828,320,0},},{{11,29,17,392,193},},{{2,49,25,1835,230,0},},
{0},{{546,32,18,392,329},{26,71,17,19,357},},{{0,42,21,0,159},},{{1831,21,12,1822,0},},{{1161,16,24,1828,320,8},{27,1,23,1819,7},},
{{1820,9,21,27,86},},{{47,7,23,8,273},},{{392,25,19,392,239},{8,18,20,100,208},},{0},{{1822,23,21,11,86},{1161,12,21,8,304},},
{{1816,92,19,1816,239},{42,11,18,100,294},},{{392,29,19,392,239},{0,49,23,0,177},},{{76,82,23,76,177},{8,5,24,1828,183,8},},
{0},{0},{0},{{2,40,23,0,223},},{{76,60,24,1828,183,76},},{{26,78,19,19,363},{1,51,25,1835,323,0},},{0},{{19,67,21,3,211},},{{1161,4,25,1835,323,8},
{27,6,17,100,63},},{0},{0},{{8,13,20,100,208},{0,41,24,1828,183,0},},{{2,35,21,0,211},},{{1840,92,11,1826,0},},{0},{{0,45,24,1828,183,0},},
{{1816,87,23,76,223},{76,85,17,1816,193},{42,7,21,8,255},},{0},{{26,63,23,3,347},},{{1824,66,23,26,92},{1823,3,21,8,86},},
{{76,81,17,1816,193},},{{3,73,25,1835,188,3},},{{47,4,25,1835,284,8},{1,52,23,0,316},},{{392,24,25,1835,230,11},},{{2,43,25,1835,230,0},},
{{3,69,25,1835,188,3},},{{1815,80,25,1835,354,76},},{{0,48,21,0,159},},{{0,37,9,1846,129},},{{100,10,25,1835,230,8},},{{1815,84,25,1835,354,76},},
{{1836,8,21,1817,4},},{{0,52,24,1828,183,0},},{{76,92,19,1816,203},},{{100,5,19,100,239},},{0},{{27,7,24,1828,51,8},},{{1816,82,21,76,211},},
{{3,78,23,3,177},},{{546,34,17,392,326},},{0},{{1,43,21,0,304},},{{1819,9,0,27,0},{1816,86,24,1828,227,76},},{{11,27,25,1835,188,11},},
{{47,18,21,8,255},},{{8,16,23,8,177},},{{26,69,25,1835,354,3},},{0},{{27,16,23,8,44},{19,62,25,1835,230,3},},{0},{{1816,79,21,76,211},
{76,80,18,1816,198},},{0},{{1827,45,2,1,0},},{{1818,40,21,0,86},},{{1820,7,21,27,86},},{{1815,81,19,1816,363},},{{546,25,19,392,332},},
{0},{{1,49,18,2,329},{1,44,19,2,332},},{{1816,81,24,1828,227,76},{1815,85,19,1816,363},},{{19,69,18,19,236},},{{0,55,20,2,208},},
{0},{{47,13,23,8,273},},{{1815,90,25,1835,354,76},{19,65,18,19,236},},{0},{{8,15,21,1834,171},},{0},{{0,43,23,0,177},},{0},{0},{{42,5,18,100,294},},
{{11,24,23,11,177},},{0},{{27,12,25,1835,57,8},},{{26,68,19,19,363},},{{1819,7,0,27,0},},{{19,63,23,3,223},},{{3,71,18,19,198},},
{0},{{47,10,17,100,289},},{{1823,5,21,8,86},},{{27,8,21,1817,11},},{{8,6,19,100,203},},{0},{0},{{2,45,17,2,233},},{{1161,11,23,8,316},
{1,45,25,1835,323,0},},{0},{{392,34,17,392,233},{0,54,21,1829,171},},{0},{{1818,50,21,0,86},{100,16,17,100,233},{100,7,18,100,236},},
{0},{{11,29,21,11,159},},{0},{{1816,84,21,76,211},{42,46,21,1827,249},},{{26,71,21,3,335},},{{0,42,25,1835,188,0},},{0},{0},{{11,32,19,392,203},},
{{47,7,19,100,299},},{{8,18,24,1828,183,8},},{{27,13,19,100,75},{2,36,23,0,223},},{0},{0},{{392,29,23,11,223},{0,49,19,2,203},},
{{76,82,19,1816,203},},{{100,11,19,100,239},},{0},{{2,40,24,1828,227,0},},{{8,9,20,100,208},},{0},{{1838,78,11,1821,0},{1,51,21,0,304},},
{{0,38,24,1828,183,0},},{{19,67,17,19,233},},{{42,3,21,8,255},},{0},{0},{{8,13,24,1828,183,8},},{0},{{1815,79,23,76,347},{11,26,18,392,198},},
{0},{0},{{42,7,25,1835,284,8},{8,17,21,1844,165},},{0},{{19,76,21,3,211},},{{2,39,24,1828,227,0},},{{76,81,21,76,159},},{{1815,92,24,1828,351,76},
{3,73,21,3,159},},{{1,52,19,2,332},},{0},{{1161,13,24,1828,320,8},},{0},{{1815,80,21,76,335},{11,23,18,392,198},},{{0,48,25,1835,188,0},},
{{8,4,24,1828,183,8},},{{1835,64,16,1824,0},{546,26,19,392,332},},{0},{0},{{0,52,20,2,208},},{{76,92,23,76,177},{3,65,25,1835,188,3},},
{{47,12,25,1835,284,8},},{0},{{2,51,25,1835,230,0},},{{1816,82,25,1835,230,76},{8,12,23,8,177},},{{76,59,13,1843,94},{3,78,19,19,203},},
{{546,34,21,11,304},{26,65,18,19,360},},{{2,55,25,1835,230,0},},{{100,18,25,1835,230,8},{1,43,17,2,326},},{0},{{11,27,21,11,159},},
{{1826,87,21,76,86},{47,18,17,100,289},{0,44,24,1828,183,0},},{{1818,52,21,0,86},{1161,18,24,1828,320,8},{47,4294967295U,4294967295U,42,1,42},},
{0},{0},{{19,62,21,3,211},},{{8,3,24,1828,183,8},},{{546,21,17,392,326},},{0},{0},{{27,11,23,8,44},},{{42,9,25,1835,284,8},},{{1815,81,23,76,347},},
{{8,7,19,100,203},},{0},{0},{0},{0},{{42,18,19,100,299},},{{1161,6,25,1835,323,8},{1,40,23,0,316},},{{1821,65,21,3,86},{47,13,19,100,299},},
{{1815,90,21,76,335},{11,28,23,11,177},},{{27,4,24,1828,51,8},{2,50,23,0,223},},{0},{0},{{0,43,19,2,203},},{0},{{1822,25,21,11,86},},
{0},{{47,6,25,1835,284,8},{0,47,19,2,203},},{{1817,4,2,1161,0},{392,22,25,1835,230,11},},{{27,12,21,8,23},},{0},{{1815,82,25,1835,354,76},},
{{392,26,25,1835,230,11},},{0},{0},{{26,75,21,1839,343},},{0},{0},{{11,21,19,392,203},},{0},{0},{{2,45,21,0,211},},{{1161,11,19,100,332},},{{19,66,17,19,233},},
{{392,34,21,11,211},},{{1817,13,2,1161,0},},{{1161,7,19,100,332},},{{26,67,25,1835,354,3},},{{27,5,17,100,63},},{0},{{1816,84,17,1816,233},
{8,52,1,1820,97},{3,76,18,19,198},},{{26,71,25,1835,354,3},},{{47,3,23,8,273},},{{1161,16,19,100,332},},{{42,4,23,8,273},},
{{11,32,23,11,177},{11,25,18,392,198},},{{546,23,18,392,329},},{0},{{27,13,23,8,44},{2,57,18,2,236},},{0},{0},{0},{0},{{1822,19,21,11,86},
{100,11,23,8,223},},{{19,71,19,19,239},},{0},{0},{{3,64,19,19,203},},{0},{0},{0},{0},{0},{0},{0},{0},{{1815,79,19,1816,363},},{{2,48,24,1828,227,0},},{0},{{76,85,25,1835,188,76},},
{{1821,71,21,3,86},},{{19,76,17,19,233},},{0},{{76,81,25,1835,188,76},},{{3,73,17,19,193},},{{392,24,18,392,236},},{0},{0},{{1816,60,23,76,223},
{42,10,19,100,299},{3,69,17,19,193},},{{1815,80,17,1816,357},},{0},{0},{{546,26,23,11,316},{1,35,25,1835,323,0},},{{1815,84,17,1816,357},},
{{2,47,24,1828,227,0},},{0},{{1817,32,2,546,0},{1,47,25,1835,323,0},},{0},{0},{{1161,5,24,1828,320,8},{2,51,21,0,211},},{{76,79,24,1828,183,76},},
{0},{{1817,26,2,546,0},{0,40,25,1835,188,0},},{0},{{100,18,21,8,211},},{{42,6,18,100,294},},{{11,34,20,392,208},{11,27,17,392,193},},
{{8,16,24,1828,183,8},},{{100,13,18,100,236},},{{26,69,17,19,357},{1,36,23,0,316},},{0},{{2,38,24,1828,227,0},},{{1816,90,25,1835,230,76},
{1816,79,24,1828,227,76},},{{546,21,21,11,304},},{0},{{2,42,24,1828,227,0},},{{27,11,19,100,75},},{{1815,81,24,1828,351,76},},{{1821,77,21,1850,88},},
{{8,7,23,8,177},{0,36,24,1828,183,0},},{{1161,10,24,1828,320,8},},{0},{0},{0},{{42,18,23,8,273},{8,11,24,1828,183,8},},{{1822,29,21,11,86},
{1161,6,21,8,304},{100,4,18,100,236},},{{546,29,18,392,329},{26,76,23,3,347},},{{1815,90,17,1816,357},},{{1820,18,21,27,86},},
{{1815,60,21,76,335},},{{1,57,25,1835,323,0},},{0},{{19,78,18,19,236},},{{42,5,25,1835,284,8},},{0},{{0,47,23,0,177},},{{392,22,21,11,211},},
{0},{0},{{19,63,24,1828,227,3},},{{0,35,24,1828,183,0},},{0},{0},{{47,10,25,1835,284,8},},{0},{{8,6,24,1828,183,8},},{{1829,52,12,1818,0},{11,21,23,11,177},
{3,67,25,1835,188,3},},{{546,24,18,392,329},},{{0,50,21,0,159},},{{1,45,18,2,329},},{{1816,80,25,1835,230,76},},{{19,66,21,3,211},},
{{392,34,25,1835,230,11},},{{8,10,20,100,208},},{{1161,7,23,8,316},{100,16,25,1835,230,8},},{0},{{27,5,21,8,23},},{{392,21,19,392,239},
{0,57,23,0,177},},{{76,90,23,76,177},{0,20,5,1837,107},},{0},{0},{{1161,16,23,8,316},{100,3,21,8,211},},{{42,4,19,100,299},},
{0},{{1834,13,12,1823,0},{47,16,24,1828,279,8},},{{27,13,24,1828,51,8},},{0},{{1816,92,24,1828,227,76},{42,11,25,1835,284,8},},{0},{0},{{8,5,20,100,208},},
{{546,27,21,11,304},},{{19,71,23,3,223},},{0},{0},{{42,15,21,1834,267},{3,64,23,3,177},},{{0,38,21,0,159},},{0},{{27,6,24,1828,51,8},},
{{42,16,18,100,294},},{0},{{8,13,19,100,203},},{{100,6,19,100,239},},{0},{{3,63,19,19,203},},{0},{{0,56,21,1845,165},{0,45,20,2,208},},
{0},{{1826,80,21,76,86},},{0},{{2,52,23,0,223},},{0},{{546,22,23,11,316},},{0},{{1827,44,2,1,0},},{0},{{42,10,23,8,273},{3,69,21,3,159},},
{{0,48,18,2,198},},{{1830,52,11,1818,0},{8,4,21,8,159},},{{100,10,18,100,236},},{{1,48,18,2,329},{1,35,21,0,304},},
{{1815,84,21,76,335},},{{19,68,18,19,236},},{{76,92,24,1828,183,76},},{0},{0},{{19,64,18,19,236},},{0},{0},{{26,65,25,1835,354,3},},{0},{{2,55,17,2,233},},
{{1818,48,21,0,86},{100,18,17,100,233},{1,43,25,1835,323,0},},{{1824,65,23,26,92},},{{392,23,18,392,236},{0,44,21,0,159},},
{{76,84,20,1816,208},},{0},{{26,69,21,3,335},},{{1819,6,0,27,0},},{{8,3,23,8,177},},{0},{{546,21,25,1835,323,11},},{{47,5,23,8,273},},
{{19,73,18,19,236},},{{3,66,18,19,198},},{{1823,4,21,8,86},},{0},{{0,51,23,0,177},},{0},{0},{0},{0},{{42,13,24,1828,279,8},{8,11,20,100,208},},
{{1161,6,17,100,326},},{{26,76,19,19,363},},{{27,4,23,8,44},{2,50,24,1828,227,0},},{0},{{1816,85,19,1816,239},{1815,60,25,1835,354,76},},
{{26,64,19,19,363},{1,57,21,0,304},},{0},{{1818,36,21,0,86},},{{1841,79,12,1826,0},{76,87,25,1835,188,76},},{0},{{47,6,17,100,289},},
{{392,22,17,392,233},},{0},{0},{0},{{392,26,17,392,233},},{0},{0},{{19,70,21,3,211},},{{1161,15,21,1834,312},{2,41,24,1828,227,0},},{{8,6,20,100,208},},
{{1815,86,24,1828,351,76},{3,67,21,3,159},},{0},{{2,45,24,1828,227,0},},{{1161,11,24,1828,320,8},{1,50,21,0,304},},{0},{{19,66,25,1835,230,3},},
{0},{{1161,7,24,1828,320,8},{100,7,21,8,211},},{{546,28,23,11,316},},{{3,62,25,1835,188,3},},{{27,5,25,1835,57,8},},{{392,21,23,11,223},
{0,57,19,2,203},},{{1816,84,25,1835,230,76},{76,90,19,1816,203},},{{47,3,24,1828,279,8},{0,42,18,2,198},},{0},{{100,3,25,1835,230,8},
{27,18,19,100,75},},{{76,86,19,1816,203},},{0},{{1817,16,2,1161,0},{8,18,17,100,193},},{{1843,58,4294967295U,1843,0,42},{2,57,25,1835,230,0},
{2,36,24,1828,227,0},},{{1161,12,24,1828,320,8},},{{42,11,21,8,255},{3,68,23,3,177},},{{11,22,18,392,198},},{{76,82,20,1816,208},},
{{1,55,19,2,332},},{{546,27,17,392,326},},{{1815,87,23,76,347},},{{27,9,24,1828,51,8},},{{8,9,24,1828,183,8},},{0},{0},{0},{0},{{76,89,21,1841,171},
{42,3,25,1835,284,8},},{0},{{1817,25,2,546,0},{8,13,23,8,177},},{{100,6,23,8,223},{2,35,24,1828,227,0},},{{1844,14,2,1832,0},
{26,66,24,1828,351,3},{1,42,19,2,332},},{{3,63,23,3,177},},{0},{{76,85,20,1816,208},},{0},{{26,70,23,3,347},{26,63,18,19,360},},
{{19,76,25,1835,230,3},},{{2,52,19,2,239},},{{1815,92,19,1816,363},},{{546,22,19,392,332},{47,17,21,1844,261},},{0},{{27,10,24,1828,51,8},},
{0},{0},{0},{{1820,4,21,27,86},{392,28,25,1835,230,11},{8,4,17,100,193},},{0},{{26,73,24,1828,351,3},},{{2,47,19,2,239},},{{392,32,25,1835,230,11},},
{{3,65,18,19,198},},{{1,47,17,2,326},},{{47,12,21,8,255},},{0},{{1816,82,18,1816,236},{76,79,23,76,177},},{0},{{546,34,18,392,329},
{26,65,21,3,335},},{0},{{27,3,24,1828,51,8},{2,55,21,0,211},},{0},{0},{{47,18,24,1828,279,8},{0,44,17,2,193},},{{76,84,24,1828,183,76},},
{0},{0},{{27,16,18,100,69},{2,38,21,0,211},},{0},{{1816,90,17,1816,233},{76,80,23,76,177},},{0},{{1821,73,21,3,86},{47,5,19,100,299},},
{{100,9,17,100,233},},{0},{0},{{47,9,19,100,299},},{0},{{1,49,23,0,316},},{0},{0},{{0,55,19,2,203},},{0},{{546,29,25,1835,323,11},},{{19,65,23,3,223},},
{{27,4,19,100,75},},{0},{{1816,85,23,76,223},},{{26,64,23,3,347},{1,57,17,2,326},},{0},{0},{{76,87,21,76,159},{42,5,17,100,289},},
{{11,24,18,392,198},},{{47,6,21,8,255},},{0},{0},{{1849,30,2,1833,0},},{0},{{392,26,21,11,211},},{{1,54,21,1829,312},},{0},{0},{0},{0},{{3,67,17,19,193},},
{{1839,63,12,1821,0},},{0},{{1,50,25,1835,323,0},},{{1816,80,17,1816,233},{42,12,23,8,273},},{0},{{8,10,25,1835,188,8},},{{100,16,18,100,236},
{100,7,17,100,233},},{{1,41,25,1835,323,0},},{{11,29,18,392,198},{3,62,21,3,159},},{{2,49,24,1828,227,0},},{{3,76,21,3,159},},
{{546,32,19,392,332},},{{546,19,25,1835,323,11},},{0},{{1161,3,24,1828,320,8},{27,18,23,8,44},},{{76,86,23,76,177},},{{546,23,25,1835,323,11},
{47,16,23,8,273},},{{392,25,18,392,236},{8,18,21,8,159},},{{1827,47,2,1,0},{2,57,21,0,211},},{0},{{42,11,17,100,289},
{3,68,19,19,203},},{{392,29,18,392,236},},{0},{{1,55,23,0,316},},{{47,11,24,1828,279,8},},{{1832,4,11,1823,0},},{{8,9,23,8,177},},
{{76,60,25,1835,188,76},},{{546,31,21,1831,312},},{0},{{19,67,18,19,236},{2,44,24,1828,227,0},},{{1161,4,24,1828,320,8},},{0},{0},{{0,41,23,0,177},},
{0},{{1,42,23,0,316},},{{2,48,17,2,233},},{{42,4294967295U,4294967295U,42,0,42},},{0},{0},{0},{0},{0},{{1815,92,23,76,347},},{{47,4,24,1828,279,8},},{0},{{2,43,24,1828,227,0},},
{{42,10,24,1828,279,8},},{{1815,80,24,1828,351,76},},{{47,8,21,1817,245},},{{392,28,21,11,211},{0,37,8,1846,121},},{{1161,9,24,1828,320,8},},
{{1815,84,24,1828,351,76},{11,19,23,11,177},},{{19,68,25,1835,230,3},{2,47,23,0,223},},{{0,52,25,1835,188,0},},{0},{{100,5,18,100,236},
{1,47,21,0,304},},{{19,64,25,1835,230,3},},{{1161,5,17,100,326},{27,7,25,1835,57,8},},{{76,79,19,1816,203},{8,12,24,1828,183,8},},
{0},{{26,65,17,19,357},},{{0,40,21,0,159},},{0},{{1816,86,25,1835,230,76},{1815,89,21,1841,343},},{{11,34,19,392,203},},{0},{{1817,11,2,1161,0},
{8,16,20,100,208},},{{26,69,24,1828,351,3},{26,62,23,3,347},},{{1824,69,23,26,92},},{{27,15,21,1834,37},{19,62,24,1828,227,3},},
{{1842,88,2,1840,0},{392,27,23,11,223},},{{1816,90,21,76,211},{76,80,19,1816,203},},{0},{{2,42,17,2,233},},{{100,9,21,8,211},
{27,11,24,1828,51,8},},{0},{0},{{546,25,18,392,329},{47,9,23,8,273},},{{1161,10,19,100,332},},{{1,49,19,2,332},{1,44,18,2,329},},
{{1816,81,23,76,223},},{{19,69,19,19,239},},{{1846,20,6,1837,2},{0,55,23,0,177},},{0},{{26,76,24,1828,351,3},},{{1815,90,24,1828,351,76},
{19,65,19,19,239},},{0},{0},{{546,33,21,1849,308},{26,64,24,1828,351,3},},{0},{{19,78,25,1835,230,3},},{0},{{42,5,21,8,255},},{0},{0},{{100,12,23,8,223},
{27,12,24,1828,51,8},},{0},{{1832,18,11,1823,0},},{0},{{8,2,1,1820,97},{3,71,19,19,203},},{0},{{1826,90,21,76,86},},{0},{0},{{1815,86,19,1816,363},},
{0},{0},{0},{0},{{1816,80,21,76,211},},{{392,34,18,392,236},},{0},{0},{{1,41,21,0,304},},{{1819,11,0,27,0},},{0},{{1816,84,18,1816,236},{76,90,24,1828,183,76},
{3,76,17,19,193},},{{546,32,23,11,316},},{{546,19,21,11,304},},{{27,4294967295U,4294967295U,42,2,42},},{{76,86,24,1828,183,76},},{{11,32,18,392,198},
{11,25,23,11,177},},{{47,16,19,100,299},},{{8,18,25,1835,188,8},{0,46,21,1827,145},},{{2,57,17,2,233},},{{1818,42,21,0,86},},
{0},{{0,49,18,2,198},},{{8,5,19,100,203},},{{100,11,18,100,236},},{{546,27,25,1835,323,11},},{{1819,0,0,27,0},{27,9,21,8,23},
{2,40,25,1835,230,0},},{{8,9,19,100,203},},{0},{0},{{0,38,25,1835,188,0},},{{1161,4,23,8,316},},{0},{0},{{1821,63,21,3,86},},{0},{{1827,52,2,1,0},},
{{11,26,17,392,193},{3,63,24,1828,183,3},},{{2,48,21,0,211},},{{0,45,19,2,203},},{{42,7,24,1828,279,8},},{0},{0},{{2,52,24,1828,227,0},},
{{76,81,20,1816,208},},{{8,21,1,1820,97},},{{1,52,18,2,329},},{{27,10,19,100,75},{2,43,23,0,223},},{{1161,13,25,1835,323,8},},
{{1816,60,24,1828,227,76},},{{11,23,19,392,203},},{0},{{8,4,25,1835,188,8},},{{26,73,23,3,347},{1,48,25,1835,323,0},},{0},{{1828,80,14,1815,0},
{1824,73,23,26,92},{19,68,21,3,211},},{{392,32,17,392,233},{0,52,21,0,159},},{{76,92,20,1816,208},},{{1826,92,21,76,86},
{47,12,24,1828,279,8},},{0},{{1161,5,21,8,304},{2,51,24,1828,227,0},},{0},{{3,78,18,19,198},},{{392,19,21,11,211},},{{27,3,21,8,23},
{2,55,24,1828,227,0},},{{1,56,21,1845,308},{1,43,18,2,329},},{{1816,86,21,76,211},{42,6,23,8,273},},{{11,34,23,11,177},
{11,27,18,392,198},},{{0,44,25,1835,188,0},},{{100,13,21,8,211},},{0},{0},{0},{{392,27,19,392,239},},{0},{{47,5,24,1828,279,8},},{{2,42,21,0,211},},
{{100,9,25,1835,230,8},},{{42,9,24,1828,279,8},},{{47,9,24,1828,279,8},},{{8,7,18,100,198},},{{1161,10,23,8,316},},{{1818,44,21,0,86},},
{{1816,81,19,1816,239},{1815,85,24,1828,351,76},},{{19,69,23,3,223},},{{42,13,19,100,299},},{{1161,6,24,1828,320,8},},{{546,29,17,392,326},},
{0},{0},{0},{0},{{0,43,18,2,198},},{{19,78,21,3,211},},{0},{{1823,16,21,8,86},{11,24,25,1835,188,11},},{{1826,86,21,76,86},{47,6,24,1828,279,8},
{0,47,18,2,198},},{0},{{27,17,21,1844,30},},{{26,68,24,1828,351,3},},{{1815,82,24,1828,351,76},},{0},{{3,71,23,3,177},},{0},{0},{{19,70,25,1835,230,3},},
{0},{{1815,86,23,76,347},{11,21,20,392,208},},{0},{0},{0},{0},{0},{0},{{1817,24,2,546,0},{8,10,17,100,193},},{{100,7,25,1835,230,8},},{{26,67,24,1828,351,3},},
{{27,5,18,100,69},{2,49,23,0,223},},{0},{{76,90,20,1816,208},},{{26,71,24,1828,351,3},},{0},{{1822,24,21,11,86},{1161,16,18,100,329},
{1161,3,21,8,304},},{{1845,53,2,1830,0},},{{11,25,19,392,203},},{{1835,71,16,1824,0},{546,23,17,392,326},},{0},{{1,38,21,0,304},},
{{1819,58,0,27,0},},{{11,22,25,1835,188,11},},{0},{{76,82,24,1828,183,76},{8,5,23,8,177},},{0},{{1823,10,21,8,86},},{{1828,81,14,1815,0},
{27,9,17,100,63},},{0},{{3,64,18,19,198},},{{26,78,24,1828,351,3},},{{2,44,21,0,211},},{{1161,4,19,100,332},},{0},{0},{{1821,67,21,3,86},},
{0},{{26,66,17,19,357},},{{1819,51,0,27,0},{11,26,21,11,159},},{{2,48,25,1835,230,0},},{{0,45,23,0,177},},{{76,85,24,1828,183,76},},
{{26,63,25,1835,354,3},},{{1836,46,21,1827,81},},{0},{{76,81,24,1828,183,76},},{{3,73,18,19,198},},{{392,24,19,392,239},},{{27,10,23,8,44},
{2,43,19,2,239},},{{1,39,23,0,316},},{{3,69,18,19,198},},{{11,23,23,11,177},},{0},{{1161,9,21,8,304},{100,10,23,8,223},},
{{26,73,19,19,363},},{0},{{19,68,17,19,233},},{{392,32,21,11,211},{0,52,17,2,193},},{0},{0},{{19,64,17,19,233},},{{1161,5,25,1835,323,8},
{27,7,17,100,63},},{0},{0},{0},{0},{0},{{1816,86,17,1816,233},{42,6,19,100,299},},{{392,23,17,392,233},},{{76,84,17,1816,193},{8,16,25,1835,188,8},},
{{100,13,17,100,233},},{0},{{11,8,21,1817,151},},{{2,38,25,1835,230,0},},{{3,70,21,3,159},},{0},{0},{{19,73,23,3,223},{2,42,25,1835,230,0},},
{0},{{1815,81,25,1835,354,76},},{{546,25,25,1835,323,11},},{{0,36,25,1835,188,0},},{0},{0},{{19,69,24,1828,227,3},},{0},{{42,13,23,8,273},},{{100,4,19,100,239},},
{{546,29,21,11,304},{47,13,24,1828,279,8},},{0},{0},{0},{0},{{1821,69,21,3,86},},{{19,78,17,19,233},},{{42,5,24,1828,279,8},},{0},{0},{{1817,23,2,546,0},},
{0},{{1815,82,23,76,347},},{{19,63,25,1835,230,3},},{0},{{1820,10,21,27,86},},{0},{{47,10,24,1828,279,8},},{{27,46,21,1827,16},},{{42,8,21,1817,245},
{8,6,25,1835,188,8},},{{11,21,24,1828,183,11},},{{546,24,19,392,332},},{{0,39,23,0,177},},{{1,45,19,2,332},},{{42,12,24,1828,279,8},},
{0},{0},{{8,10,21,8,159},},{{1827,55,2,1,0},{26,67,23,3,347},},{0},{{2,49,19,2,239},},{{392,21,18,392,236},},{{3,76,25,1835,188,3},},
{0},{0},{0},{0},{0},{{1834,18,12,1823,0},{546,23,21,11,304},{47,7,24,1828,279,8},},{{27,13,25,1835,57,8},},{0},{{1816,92,25,1835,230,76},{42,11,24,1828,279,8},},
{{11,22,21,11,159},},{0},{{1818,57,21,0,86},{100,11,25,1835,230,8},},{{47,11,17,100,289},},{{1815,87,24,1828,351,76},},{0},{0},{{76,60,21,76,159},},
{0},{{2,44,17,2,233},},{{27,6,23,8,44},},{{1841,92,12,1826,0},{1820,16,21,27,86},{42,16,19,100,299},},{0},{{8,13,18,100,198},},
{0},{{26,66,21,3,335},},{{11,26,25,1835,188,11},},{0},{{76,85,23,76,177},{42,7,19,100,299},},{{1817,10,2,1161,0},},{{26,70,24,1828,351,3},},
{{11,33,21,1849,165},},{{2,39,23,0,223},},{0},{{47,4,19,100,299},},{{392,24,23,11,223},},{0},{{1161,13,17,100,326},},{0},{{0,48,19,2,203},},
{{8,4,18,100,198},{0,37,7,1846,113},},{{1161,9,17,100,326},{100,10,19,100,239},},{{546,26,24,1828,320,11},{1,48,17,2,326},},
{0},{0},{{76,92,25,1835,188,76},{3,65,23,3,177},},{{100,5,25,1835,230,8},},{0},{{19,64,21,3,211},},{{27,7,21,8,23},},{0},{{26,65,24,1828,351,3},},
{0},{0},{{100,18,18,100,236},},{0},{{392,23,21,11,211},{0,44,18,2,198},},{{76,84,21,76,159},},{{1161,18,19,100,332},},{0},{{27,16,17,100,63},},
{0},{{76,80,24,1828,183,76},},{{546,21,24,1828,320,11},},{0},{{19,73,19,19,239},},{{42,9,23,8,273},{3,66,17,19,193},},{0},{{546,25,21,11,304},},
{{0,36,21,0,159},},{0},{{1815,85,21,76,335},},{0},{0},{{42,18,24,1828,279,8},{8,11,23,8,177},},{{100,4,23,8,223},},{0},{{1819,10,0,27,0},
{2,50,25,1835,230,0},},{0},{{1816,85,18,1816,236},{1815,60,24,1828,351,76},},{{1,57,18,2,329},},{{1826,82,21,76,86},},{0},{{76,87,24,1828,183,76},},
{{11,24,17,392,193},},{0},{{392,22,18,392,236},},{{26,68,21,3,335},},{{1815,82,19,1816,363},},{0},{{392,26,18,392,236},{0,35,23,0,177},},
{0},{{47,10,23,8,273},},{0},{0},{{8,6,21,8,159},},{{3,67,18,19,198},},{{546,24,23,11,316},},{0},{{1161,11,25,1835,323,8},{1,45,23,0,316},},
{{1816,80,18,1816,236},{42,17,21,1844,261},},{{1837,51,3,1836,2},{19,66,24,1828,227,3},},{0},{{1161,7,25,1835,323,8},{100,16,23,8,223},},
{{1821,62,21,3,86},{26,67,19,19,363},},{{3,62,24,1828,183,3},},{0},{{0,57,18,2,198},},{{26,71,19,19,363},},{{47,3,25,1835,284,8},
{0,42,19,2,203},},{0},{{100,3,24,1828,227,8},{27,18,18,100,69},},{{1820,51,21,27,86},{76,86,20,1816,208},{42,4,24,1828,279,8},},
{0},{{392,25,21,11,211},{8,18,18,100,198},},{{2,57,24,1828,227,0},{2,36,25,1835,230,0},},{{1161,12,23,8,316},{100,15,21,1834,219},},
{{1816,92,21,76,211},},{{1824,71,23,26,92},{1823,6,21,8,86},{11,22,17,392,193},},{{76,82,21,76,159},},{0},{{47,11,21,8,255},},
{{19,71,24,1828,227,3},},{{27,9,25,1835,57,8},{2,40,21,0,211},},{{3,64,25,1835,188,3},},{{26,78,21,3,335},},{0},{{19,67,23,3,223},},
{{27,6,19,100,75},},{{42,16,23,8,273},{42,3,24,1828,279,8},},{{8,13,1,1820,97},},{0},{{100,6,24,1828,227,8},{2,35,23,0,223},},
{{1818,38,21,0,86},{26,66,25,1835,354,3},{1,42,18,2,329},},{{1815,79,24,1828,351,76},{3,63,20,19,208},},{{1829,42,12,1818,0},},
{{1816,87,21,76,211},{76,85,19,1816,203},{42,7,23,8,273},},{0},{{26,63,17,19,357},},{{19,76,24,1828,227,3},},{{76,81,19,1816,203},},
{{1815,92,18,1816,360},},{{47,4,23,8,273},{1,52,25,1835,323,0},},{{1826,84,21,76,86},},{0},{{1822,22,21,11,86},{1161,13,21,8,304},},
{{11,23,24,1828,183,11},},{{0,48,23,0,177},},{0},{0},{{1,48,21,0,304},},{{2,47,18,2,236},},{0},{{3,65,19,19,203},},{{100,5,21,8,211},
{1,47,18,2,329},},{0},{{1161,5,18,100,329},},{{1816,82,19,1816,239},},{{3,78,25,1835,188,3},},{{546,34,19,392,332},},{{392,19,25,1835,230,11},},
{{27,3,25,1835,57,8},},{0},{0},{{392,23,25,1835,230,11},{47,18,23,8,273},},{{76,84,25,1835,188,76},{8,16,17,100,193},},{{1161,18,23,8,316},
{100,13,25,1835,230,8},},{0},{{27,16,21,8,23},},{0},{{1816,90,18,1816,236},{1816,79,19,1816,239},{76,80,20,1816,208},},{{1830,42,11,1818,0},},
{{2,42,18,2,236},},{{1822,34,21,11,86},},{{42,9,19,100,299},{3,66,21,3,159},},{{1815,81,17,1816,357},},{{546,25,17,392,326},},
{0},{{1,44,21,0,304},},{{1815,85,17,1816,357},},{0},{{0,55,18,2,198},},{{8,11,19,100,203},},{{546,29,24,1828,320,11},{47,13,21,8,255},},
{{11,28,25,1835,188,11},},{{27,4,18,100,69},},{0},{0},{{0,43,21,0,159},},{{2,54,21,1829,219},},{{1818,55,21,0,86},},{0},{{11,24,21,11,159},},
{0},{0},{{26,68,17,19,357},},{0},{{19,63,17,19,233},},{0},{0},{{47,10,19,100,299},},{0},{{2,41,23,0,223},},{{1820,6,21,27,86},{8,6,17,100,193},},
{{546,24,24,1828,320,11},},{0},{0},{{1161,11,21,8,304},{1,50,24,1828,320,0},},{0},{0},{0},{{100,16,19,100,239},},{0},{{11,29,19,392,203},},{0},{{1816,84,23,76,223},
{3,76,20,19,208},},{{1817,9,2,1161,0},{26,71,23,3,347},},{{546,19,24,1828,320,11},{0,42,23,0,177},},{{1824,67,23,26,92},},
{{1161,3,25,1835,323,8},},{{11,32,17,392,193},{11,25,20,392,208},},{{546,23,24,1828,320,11},{47,7,21,8,255},},{{392,25,17,392,233},},
{{27,13,17,100,63},{2,36,21,0,211},},{{1,38,25,1835,323,0},},{{1816,92,17,1816,233},{3,68,18,19,198},},{{392,29,17,392,233},
{0,49,21,0,159},},{{76,82,17,1816,193},},{{100,11,17,100,233},{1,55,24,1828,320,0},},{{47,11,25,1835,284,8},},{0},{0},{0},{{26,78,17,19,357},},
{0},{{19,67,19,19,239},{2,44,25,1835,230,0},},{{42,16,24,1828,279,8},{42,3,23,8,273},},{0},{0},{0},{0},{0},{{2,48,18,2,236},},{0},{{1816,87,25,1835,230,76},},
{{1161,17,21,1844,308},},{{26,63,21,3,335},},{0},{{76,81,23,76,177},},{0},{{1,52,21,0,304},},{0},{{1818,41,21,0,86},},{{42,10,25,1835,284,8},},
{0},{0},{0},{{1161,9,25,1835,323,8},},{0},{{19,68,24,1828,227,3},},{{392,32,18,392,236},},{{1820,0,21,27,86},{76,92,17,1816,193},},{{100,5,17,100,233},},
{{19,64,24,1828,227,3},},{0},{{1816,82,23,76,223},{76,79,18,1816,198},{8,12,25,1835,188,8},},{{3,78,21,3,159},},{{546,34,23,11,316},},
{0},{{1,43,23,0,316},},{{42,6,24,1828,279,8},},{{11,34,18,392,198},{11,27,23,11,177},},{{47,18,19,100,299},},{{1817,22,2,546,0},
{8,16,21,8,159},},{0},{{19,77,21,1850,215},},{{27,16,25,1835,57,8},{19,62,23,3,223},},{0},{{1816,79,23,76,223},{3,70,25,1835,188,3},},
{0},{{19,73,24,1828,227,3},},{{27,11,25,1835,57,8},},{{3,66,25,1835,188,3},},{{1815,81,21,76,335},},{{8,7,17,100,193},},{{1161,10,18,100,329},},
{{1,44,17,2,326},},{0},{0},{0},{{1818,51,21,0,86},{100,4,24,1828,227,8},},{{47,13,17,100,289},{26,76,25,1835,354,3},},{{1815,90,23,76,347},
{11,28,21,11,159},},{0},{0},{{26,64,25,1835,354,3},},{{0,43,17,2,193},},{{19,78,24,1828,227,3},},{0},{0},{{0,47,17,2,193},},{0},{0},{0},{0},{{19,63,21,3,211},},
{0},{0},{0},{0},{0},{{1815,86,18,1816,360},{11,21,17,392,193},},{{1821,78,21,3,86},},{0},{{2,45,19,2,239},},{{1161,11,17,100,326},},{{19,66,19,19,239},},
{{392,34,19,392,239},},{0},{{1161,7,17,100,326},},{{546,28,24,1828,320,11},},{{1815,91,21,1842,339},{11,29,23,11,177},},{{392,21,25,1835,230,11},},
{{1816,84,19,1816,239},{76,90,25,1835,188,76},},{{546,32,24,1828,320,11},},{0},{0},{{76,86,25,1835,188,76},{42,4,21,8,255},},{{11,32,21,11,159},},
{{47,16,18,100,294},{47,7,17,100,289},},{{1830,57,11,1818,0},},{{27,13,21,8,23},},{0},{{19,75,21,1839,219},},{{392,29,21,11,211},
{0,49,17,2,193},},{{8,5,18,100,198},},{{100,11,21,8,211},},{{1839,78,12,1821,0},{546,27,24,1828,320,11},},{0},{{8,9,18,100,198},},
{{3,64,17,19,193},},{{1,51,23,0,316},},{0},{0},{0},{0},{0},{0},{{26,66,18,19,360},{1,42,25,1835,323,0},},{{1815,79,21,76,335},{3,63,25,1835,188,3},},
{0},{{0,45,18,2,198},},{{1838,63,11,1821,0},},{0},{{19,76,23,3,223},},{{2,52,25,1835,230,0},},{0},{{3,73,23,3,177},},{{546,22,24,1828,320,11},
{1,52,17,2,326},},{{27,10,18,100,69},},{0},{{1816,60,25,1835,230,76},},{{1815,80,23,76,347},},{0},{0},{{546,26,17,392,326},{1,48,24,1828,320,0},},
{0},{0},{{0,52,18,2,198},},{{76,92,21,76,159},},{{1821,64,21,3,86},},{0},{{1819,13,0,27,0},{27,7,18,100,69},{2,51,23,0,223},},
{{8,12,21,8,159},},{{3,78,17,19,193},},{0},{0},{{1,43,19,2,332},},{0},{{11,27,19,392,203},},{{76,84,18,1816,198},},{0},{{1827,49,2,1,0},
{1,36,25,1835,323,0},},{0},{0},{{392,27,18,392,236},},{{546,21,19,392,332},},{{47,5,25,1835,284,8},},{0},{{100,9,24,1828,227,8},{27,11,21,8,23},},
{0},{{47,9,25,1835,284,8},},{{8,7,21,8,159},{0,51,25,1835,188,0},},{0},{0},{{1816,81,18,1816,236},{1815,85,25,1835,354,76},},{{0,55,25,1835,188,0},},
{{42,18,17,100,289},{42,13,18,100,294},},{{1,40,21,0,304},},{{26,76,21,3,335},},{{1823,12,21,8,86},{1815,90,19,1816,363},
{19,65,24,1828,227,3},},{{2,50,21,0,211},},{{1816,85,25,1835,230,76},},{0},{0},{{1824,62,23,1847,92},},{0},{{11,24,24,1828,183,11},},{{0,47,21,0,159},},
{0},{{100,12,24,1828,227,8},{27,12,23,8,44},},{{26,68,25,1835,354,3},},{0},{0},{{3,71,20,19,208},},{0},{0},{{19,70,24,1828,227,3},},{0},{{11,21,21,11,159},},
{0},{0},{{2,45,23,0,223},},{{1819,16,0,27,0},},{{19,66,23,3,223},},{{392,34,23,11,223},},{{8,10,18,100,198},},{{1822,28,21,11,86},
{1161,7,21,8,304},{100,7,24,1828,227,8},},{{11,29,24,1828,183,11},},{{27,5,19,100,75},},{{0,57,25,1835,188,0},},{{76,90,21,76,159},},
{0},{{47,3,21,8,255},},{{1161,16,17,100,326},{27,18,25,1835,57,8},},{{42,4,17,100,289},},{{11,32,25,1835,188,11},},{0},{{392,25,25,1835,230,11},},
{0},{{3,68,25,1835,188,3},},{{11,22,24,1828,183,11},},{{392,29,25,1835,230,11},},{{76,82,25,1835,188,76},},{{546,27,23,11,316},{47,11,18,100,294},},
{{19,71,17,19,233},},{{27,9,18,100,69},},{0},{{3,64,21,3,159},},{{26,78,25,1835,354,3},},{0},{{1161,4,18,100,329},},{{1850,74,2,1838,0},},
{0},{{1829,57,12,1818,0},},{{100,6,17,100,233},},{0},{{1815,79,17,1816,357},{11,26,20,392,208},},{{1823,18,21,8,86},},{0},{{1817,21,2,546,0},},
{{26,63,24,1828,351,3},},{{19,76,19,19,239},},{{2,52,21,0,211},},{0},{{3,73,19,19,203},},{0},{{2,43,18,2,236},},{{1161,13,18,100,329},
{1,39,24,1828,320,0},},{{1816,60,21,76,211},{42,10,17,100,289},{3,69,19,19,203},},{{1815,80,19,1816,363},{11,23,20,392,208},},
{{8,4,23,8,177},},{{1818,45,21,0,86},{1161,9,18,100,329},},{{546,26,21,11,304},{26,73,18,19,360},},{{1815,84,19,1816,363},},
{0},{{3,65,20,19,208},},{0},{{1826,79,21,76,86},},{0},{0},{0},{{546,34,24,1828,320,11},},{0},{{2,55,19,2,239},},{{1822,26,21,11,86},{100,18,23,8,223},},
{{1816,86,18,1816,236},},{{0,44,23,0,177},},{0},{0},{{26,69,19,19,363},{1,36,21,0,304},},{0},{{8,3,21,8,159},},{0},{{546,21,23,11,316},},
{{47,5,21,8,255},},{0},{{27,11,17,100,63},},{0},{{546,25,24,1828,320,11},},{{8,7,25,1835,188,8},{0,51,21,0,159},},{0},{{1,49,24,1828,320,0},
{1,44,25,1835,323,0},},{{19,69,25,1835,230,3},},{0},{{42,18,21,8,255},},{{1161,6,23,8,316},{1,40,25,1835,323,0},},{{47,13,25,1835,284,8},
{26,76,17,19,357},},{{27,4,21,8,23},},{0},{{1815,60,23,76,347},},{{26,64,17,19,357},{1,57,23,0,316},},{{0,43,25,1835,188,0},},
{0},{{1816,89,21,1841,219},},{{1824,64,23,26,92},},{{47,6,19,100,299},{0,47,25,1835,188,0},},{{392,22,23,11,223},},{0},{0},{0},{0},{{3,71,24,1828,183,3},},
{0},{{19,70,23,3,223},},{0},{0},{{11,21,25,1835,188,11},{3,67,23,3,177},},{0},{{0,50,23,0,177},},{{1818,35,21,0,86},},{{42,12,25,1835,284,8},},
{0},{0},{0},{{546,28,21,11,304},},{0},{{27,5,23,8,44},{2,49,18,2,236},},{{392,21,17,392,233},{0,57,21,0,159},},{{76,90,17,1816,193},
{3,76,24,1828,183,3},},{{1826,81,21,76,86},},{0},{{1161,16,21,8,304},{100,3,23,8,223},},{{76,86,17,1816,193},},{{11,25,24,1828,183,11},},
{{47,7,25,1835,284,8},},{0},{0},{{42,11,23,8,273},{3,68,21,3,159},},{{11,22,20,392,208},},{{0,49,25,1835,188,0},},{{100,11,24,1828,227,8},
{1,55,17,2,326},},{{1827,43,2,1,0},{546,27,19,392,332},},{{1815,87,25,1835,354,76},{19,71,21,3,211},},{0},{0},{0},{{0,38,23,0,177},},
{{19,67,24,1828,227,3},{2,44,18,2,236},},{0},{0},{0},{{8,13,17,100,193},},{{100,6,21,8,211},},{{1818,49,21,0,86},{1,42,17,2,326},},
{{11,26,24,1828,183,11},{3,63,17,19,193},},{0},{{42,7,18,100,294},},{0},{{26,70,25,1835,354,3},},{{1840,79,11,1826,0},},{{2,52,17,2,233},},
{{1815,92,17,1816,357},},{{546,22,21,11,304},{47,4,18,100,294},},{0},{0},{0},{{42,10,21,8,255},{3,69,23,3,177},},{0},{{8,4,19,100,203},},
{0},{{1831,34,12,1822,0},{546,26,25,1835,323,11},{1,35,23,0,316},},{{1815,84,23,76,347},{11,19,24,1828,183,11},},{0},{0},{{100,5,24,1828,227,8},},
{0},{0},{{76,79,21,76,159},},{0},{{1821,68,21,3,86},{47,46,21,1827,249},},{0},{{2,55,23,0,223},},{{100,18,19,100,239},},{{11,34,25,1835,188,11},},
{{0,44,19,2,203},},{{8,16,18,100,198},},{{1161,18,18,100,329},},{{26,69,23,3,347},{26,62,24,1828,351,3},},{{2,38,23,0,223},},
{{1820,11,21,27,86},{392,27,25,1835,230,11},},{{76,80,25,1835,188,76},},{{1817,7,2,1161,0},},{{47,5,17,100,289},},{{1822,21,21,11,86},
{100,9,19,100,239},},{0},{0},{{47,9,17,100,289},},{{392,31,21,1831,219},},{0},{0},{0},{{0,55,17,2,193},},{{42,18,25,1835,284,8},},{{1161,6,19,100,332},
{100,17,21,1844,215},},{{1824,76,23,26,92},{19,65,21,3,211},},{{27,4,17,100,63},},{0},{{1816,85,17,1816,233},{42,1,23,1819,242},},
{{26,64,21,3,335},{1,57,19,2,332},},{0},{0},{0},{0},{{47,6,23,8,273},},};

static const struct action_table_entry *action_table_lookup(uint32_t nfa_state, uint32_t dfa_state, uint32_t token) {
    uint32_t index = ((((((0xe5aa55e5 ^ (nfa_state)) * 0xe5aa55e5) ^ (dfa_state)) * 0xe5aa55e5) ^ (token)) * 0xe5aa55e5) & 2047;
    uint32_t j = 0;
    const struct action_table_entry *entry = 0;
    for (; j < 3; ++j) {
        entry = &action_table[index][j];
        if (entry->target_nfa_state == nfa_state && entry->dfa_state == dfa_state && entry->dfa_symbol == token)
            break;
    }
    if (j >= 3)
        return 0;
    return entry;
}
static void apply_actions(struct construct_state *state, uint32_t index, size_t start, size_t end) {
    size_t offset = end;
    for (uint32_t i = index; actions[i]; ++i) {
        if (((((actions[i]) >> 12) & 0xf) & 8))
            offset = start;
        construct_action_apply(state, actions[i], offset);
    }
}
static parsed_id build_parse_tree(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run *run, struct bluebird_tree *tree) {
    struct construct_state construct_state = { .info = tree };
    uint32_t *state_stack = 0;
    uint32_t stack_depth = 0;
    size_t stack_capacity = 0;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset - whitespace;
    construct_begin(&construct_state, offset, CONSTRUCT_NORMAL_ROOT);
    uint32_t nfa_state = 47;
    while (run) {
        uint16_t length_offset = run->lengths_size - 1;
        uint16_t n = run->number_of_tokens;
        for (uint16_t i = n - 1; i < n; i--) {
            size_t end = offset;
            size_t len = 0;
            const struct action_table_entry *entry = action_table_lookup(nfa_state, run->states[i], run->tokens[i]);
            if (!entry)
                abort();
            if (entry->dfa_symbol < 24)
                len = decode_token_length(run, &length_offset, &offset);
            else {
                if (stack_depth >= stack_capacity) {
                    size_t new_capacity = (stack_capacity + 2) * 3 / 2;
                    if (new_capacity <= stack_capacity)
                        abort();
                    uint32_t *new_stack = realloc(state_stack, new_capacity * sizeof(uint32_t));
                    if (!new_stack)
                        abort();
                    state_stack = new_stack;
                    stack_capacity = new_capacity;
                }
                state_stack[stack_depth++] = entry->push_nfa_state;
            }
            apply_actions(&construct_state, entry->actions, end, end + whitespace);
            if (entry->dfa_state == 59) {
                if (stack_depth == 0)
                    abort();
                nfa_state = state_stack[--stack_depth];
            } else
                nfa_state = entry->nfa_state;
            whitespace = end - offset - len;
        }
        struct bluebird_token_run *old = run;
        run = run->prev;
        free(old);
    }
    const struct action_table_entry *entry = action_table_lookup(nfa_state, UINT32_MAX, UINT32_MAX);
    if (!entry)
        abort();
    apply_actions(&construct_state, entry->actions, offset, offset + whitespace);
    free(state_stack);
    return construct_finish(&construct_state, offset);
}
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info) {
    switch (text[0]) {
    case 35:
        *end_token = false;
        *token = 4294967295U;
        return 1;
    case 40:
        *end_token = false;
        *token = 13;
        return 1;
    case 41:
        *end_token = true;
        *token = 14;
        return 1;
    case 42:
        *end_token = false;
        *token = 17;
        return 1;
    case 43:
        *end_token = false;
        *token = 18;
        return 1;
    case 46:
        if (text[1] == 111 && text[2] == 112 && text[3] == 101 && text[4] == 114 && text[5] == 97 && text[6] == 116 && text[7] == 111 && text[8] == 114 && text[9] == 115) {
            *end_token = false;
            *token = 3;
            return 10;
        } else {
            return 0;
        }
    case 58:
        *end_token = false;
        *token = 2;
        return 1;
    case 61:
        *end_token = false;
        *token = 1;
        return 1;
    case 63:
        *end_token = false;
        *token = 19;
        return 1;
    case 64:
        *end_token = false;
        *token = 12;
        return 1;
    case 91:
        *end_token = false;
        *token = 15;
        return 1;
    case 92:
        *end_token = false;
        *token = 11;
        return 1;
    case 93:
        *end_token = true;
        *token = 16;
        return 1;
    case 102:
        if (text[1] == 108 && text[2] == 97 && text[3] == 116) {
            *end_token = false;
            *token = 7;
            return 4;
        } else {
            return 0;
        }
    case 105:
        if (text[1] == 110 && text[2] == 102 && text[3] == 105 && text[4] == 120) {
            *end_token = false;
            *token = 6;
            return 5;
        } else {
            return 0;
        }
    case 108:
        switch (text[1]) {
        case 101:
            if (text[2] == 102 && text[3] == 116) {
                *end_token = false;
                *token = 8;
                return 4;
            } else {
                return 0;
            }
        case 105:
            if (text[2] == 110 && text[3] == 101 && text[4] == 45 && text[5] == 99 && text[6] == 111 && text[7] == 109 && text[8] == 109 && text[9] == 101 && text[10] == 110 && text[11] == 116 && text[12] == 45 && text[13] == 116 && text[14] == 111 && text[15] == 107 && text[16] == 101 && text[17] == 110) {
                *end_token = false;
                *token = 0;
                return 18;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 110:
        if (text[1] == 111 && text[2] == 110 && text[3] == 97 && text[4] == 115 && text[5] == 115 && text[6] == 111 && text[7] == 99) {
            *end_token = false;
            *token = 10;
            return 8;
        } else {
            return 0;
        }
    case 112:
        switch (text[1]) {
        case 111:
            if (text[2] == 115 && text[3] == 116 && text[4] == 102 && text[5] == 105 && text[6] == 120) {
                *end_token = false;
                *token = 4;
                return 7;
            } else {
                return 0;
            }
        case 114:
            if (text[2] == 101 && text[3] == 102 && text[4] == 105 && text[5] == 120) {
                *end_token = false;
                *token = 5;
                return 6;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 114:
        if (text[1] == 105 && text[2] == 103 && text[3] == 104 && text[4] == 116) {
            *end_token = false;
            *token = 9;
            return 5;
        } else {
            return 0;
        }
    case 124:
        *end_token = false;
        *token = 20;
        return 1;
    default:
        return 0;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context) {
    switch (parent) {
    case 0:
        switch (slot) {
        case 0: return 1;
        case 1: return 2;
        default: break;
        }
        break;
    case 1:
        switch (slot) {
        case 0: return 11;
        default: break;
        }
        break;
    case 2:
        switch (slot) {
        case 0: return 9;
        case 1: return 3;
        default: break;
        }
        break;
    case 3:
        switch (slot) {
        case 0: return 8;
        case 1: return 9;
        case 2: return 4;
        default: break;
        }
        break;
    case 4:
        switch (slot) {
        case 0: return 6;
        case 1: return 5;
        default: break;
        }
        break;
    case 5:
        switch (slot) {
        case 0: return 8;
        case 1: return 9;
        default: break;
        }
        break;
    case 6:
        switch (slot) {
        case 0: return 7;
        default: break;
        }
        break;
    case 8:
        switch (slot) {
        case 0: return 9;
        case 1: return 9;
        case 2: return 9;
        case 3: return 11;
        case 4: return 8;
        case 5: return 11;
        case 6: return 11;
        case 7: return 8;
        default: break;
        }
        break;
    default: break;
    }
    return UINT32_MAX;
}
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context) {
    switch (rule) {
    case 8:
        switch (choice) {
        case 4:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 5:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 6:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 7:
            *precedence = -2;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        case 8:
            *precedence = -3;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        default: return;
        }
    default: return;
    }
}
static size_t number_of_slots_lookup(uint32_t rule, void *context) {
    switch (rule) {
    case 0: return 2;
    case 1: return 1;
    case 2: return 2;
    case 3: return 3;
    case 4: return 2;
    case 5: return 2;
    case 6: return 1;
    case 7: return 0;
    case 8: return 8;
    case 9: return 0;
    case 10: return 0;
    case 11: return 0;
    default: return 0;
    }
}
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context) {
    switch (rule) {
    case 0:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 1:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 2:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 3:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 4:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 5:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 6:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 7:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 8:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 7;
        break;
    case 9:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 10:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 11:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    }
}
#endif

