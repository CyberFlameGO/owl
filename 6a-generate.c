#include "6a-generate.h"

#include "grow-array.h"
#include <stdio.h>
#include <string.h>

#if 0

enum substitution_transform {
    NO_TRANSFORM,
    LOWERCASE_WITH_UNDERSCORES,
    UPPERCASE_WITH_UNDERSCORES,
};

struct substitution {
    // Zero-terminated.
    const char *variable;

    const char *value;
    size_t value_length;

    enum substitution_transform transform;
};

struct generator_internal {
    struct substitution *substitutions;
    uint32_t substitutions_allocated_bytes;
    uint32_t number_of_substitutions;

    char *formatted_string;
    uint32_t formatted_string_allocated_bytes;
};

static struct substitution *find_substitution(struct generator *gen,
 const char *variable)
{
    uint32_t n = gen->internal->number_of_substitutions;
    for (uint32_t i = 0; i < n; ++i) {
        struct substitution *s = &gen->internal->substitutions[i];
        for (size_t j = 0; ; ++j) {
            if (s->variable[j] == 0)
                return s;
            if (s->variable[j] != variable[j])
                break;
        }
    }
    return 0;
}

static void apply_transform(char *string, size_t length,
 enum substitution_transform transform)
{
    if (transform == NO_TRANSFORM)
        return;
    for (size_t i = 0; i < length; ++i) {
        if (transform == UPPERCASE_WITH_UNDERSCORES && string[i] >= 'a'
         && string[i] <= 'z')
            string[i] = string[i] - 'a' + 'A';
        if (string[i] == '-')
            string[i] = '_';
    }
}

static void output_string(struct generator *gen, const char *string)
{
    size_t len = strlen(string);
    if (len == 0)
        return;
    size_t next_output_index = 0;
    char *format = gen->internal->formatted_string;
    uint32_t format_bytes = gen->internal->formatted_string_allocated_bytes;
    for (size_t i = 0; i < len - 1; ++i) {
        if (string[i] == '%' && string[i + 1] == '%') {
            struct substitution *sub = find_substitution(gen, string + i + 2);
            if (!sub)
                abort();
            gen->output(gen, string + next_output_index, i - next_output_index);
            if (sub->value_length > UINT32_MAX)
                abort();
            format = grow_array(format, &format_bytes,
             (uint32_t)sub->value_length);
            memcpy(format, sub->value, sub->value_length);
            apply_transform(format, sub->value_length, sub->transform);
            gen->output(gen, format, sub->value_length);
            next_output_index = i + 2 + strlen(sub->variable);
        }
    }
    gen->internal->formatted_string = format;
    gen->internal->formatted_string_allocated_bytes = format_bytes;
    if (next_output_index < len)
        gen->output(gen, string + next_output_index, len - next_output_index);
}

static void output_line(struct generator *gen, const char *string)
{
    output_string(gen, string);
    output_string(gen, "\n");
}

static void set_substitution(struct generator *gen, const char *variable,
 const char *value, size_t value_length, enum substitution_transform transform)
{
    uint32_t index = 0;
    for (; index < gen->internal->number_of_substitutions; ++index) {
        if (strcmp(variable, gen->internal->substitutions[index].variable) == 0)
            break;
    }
    if (index >= gen->internal->number_of_substitutions) {
        gen->internal->number_of_substitutions = index + 1;
        gen->internal->substitutions = grow_array(gen->internal->substitutions,
         &gen->internal->substitutions_allocated_bytes,
         gen->internal->number_of_substitutions * sizeof(struct substitution));
        gen->internal->substitutions[index].variable = variable;
    }
    gen->internal->substitutions[index].value = value;
    gen->internal->substitutions[index].value_length = value_length;
    gen->internal->substitutions[index].transform = transform;
}

static bool rule_is_syntactic(struct rule rule)
{
    return rule.type == SIMPLE_RULE || rule.type == RULE_WITH_CHOICES ||
     rule.type == RULE_WITH_OPERATORS;
}

static bool rule_has_choices(struct rule rule)
{
    return rule.type == RULE_WITH_CHOICES || rule.type == RULE_WITH_OPERATORS;
}

void generate(struct generator *gen)
{
    struct generator_internal internal = {0};
    gen->internal = &internal;

    if (gen->grammar->number_of_rules == 0) {
        fprintf(stderr, "A generated grammar needs at least one rule, but this "
         "grammar doesn't appear to have any!\n");
        exit(-1);
    }
    set_substitution(gen, "root-rule", gen->grammar->rules[0].name,
     gen->grammar->rules[0].name_length, LOWERCASE_WITH_UNDERSCORES);

    output_line(gen, "// -----------------------------------------------------------------------------");
    output_line(gen, "// This file was generated by the bluebird parsing tool.");
    output_line(gen, "// Make sure to #define BLUEBIRD_PARSER_IMPLEMENTATION somewhere so the parser");
    output_line(gen, "// is compiled properly.  Just two lines are enough -- a typical parser.c might");
    output_line(gen, "// look like:");
    output_line(gen, "//");
    output_line(gen, "//   #define BLUEBIRD_PARSER_IMPLEMENTATION");
    output_line(gen, "//   #include \"bluebird-parser.h\"");
    output_line(gen, "");
    output_line(gen, "#ifndef _BLUEBIRD_PARSER_H_");
    output_line(gen, "#define _BLUEBIRD_PARSER_H_");
    output_line(gen, "");
    output_line(gen, "// A parsed_id represents an element in the parse tree.  Use the");
    output_line(gen, "// parsed_..._get() function corresponding to the element type to unpack the");
    output_line(gen, "// element into its appropriate type of parsed_... element struct.");
    output_line(gen, "typedef uint32_t parsed_id;");
    output_line(gen, "");
    output_line(gen, "// The bluebird_tree struct represents an entire parse tree.  Use the");
    output_line(gen, "// bluebird_tree_create_...() functions to create a tree, then call");
    output_line(gen, "// bluebird_tree_root() to get the root bluebird_id.");
    output_line(gen, "struct bluebird_tree;");
    output_line(gen, "");
    output_line(gen, "// Creates a bluebird_tree from a string.  Remember to call");
    output_line(gen, "// bluebird_tree_destroy() when you're done with it");
    output_line(gen, "struct bluebird_tree *bluebird_tree_create_from_string(const char *string,");
    output_line(gen, " size_t length);");
    output_line(gen, "");
    output_line(gen, "// Returns the root parsed_id.");
    output_line(gen, "parsed_id bluebird_tree_root_id(struct bluebird_tree *tree);");
    output_line(gen, "");
    output_line(gen, "// As a shortcut, returns the parsed_%%root-rule struct corresponding to the root parsed_id.");
    output_line(gen, "struct parsed_%%root-rule bluebird_tree_get_parsed_%%root-rule(struct bluebird_tree *tree);");

    uint32_t n = gen->grammar->number_of_rules;
    for (rule_id i = 0; i < n; ++i) {
        struct rule rule = gen->grammar->rules[i];
        if (!rule_is_syntactic(rule))
            continue;
        set_substitution(gen, "rule", gen->grammar->rules[i].name,
         gen->grammar->rules[i].name_length, LOWERCASE_WITH_UNDERSCORES);
        output_line(gen, "");
        if (rule_has_choices(rule)) {
            output_line(gen, "enum parsed_%%rule_type {");
            for (rule_id j = i + 1; j < n; ++j) {
                if (gen->grammar->rules[j].syntactic_rule != i)
                    continue;
                set_substitution(gen, "choice-name",
                 gen->grammar->rules[j].choice_name,
                 gen->grammar->rules[j].choice_name_length,
                 UPPERCASE_WITH_UNDERSCORES);
                output_line(gen, "    %%choice-name,");
            }
            output_line(gen, "};");
        }
        output_line(gen, "struct parsed_%%rule {");
        output_line(gen, "    struct bluebird_tree *_tree;");
        output_line(gen, "    bool empty;");
        if (rule_has_choices(rule))
            output_line(gen, "    enum parsed_%%rule_type type;");
        for (uint32_t j = 0; j < rule.number_of_slots; ++j) {
            struct slot slot = rule.slots[j];
            set_substitution(gen, "referenced-slot", slot.name,
             slot.name_length, LOWERCASE_WITH_UNDERSCORES);
            output_line(gen, "    parsed_id %%referenced-slot;");
        }
/*
        ID_FIELD_X(_next, DISABLE_PRINT) \
        FIELD(string_offset, size_t, DISABLE_PRINT) \
        FIELD(string_length, size_t, DISABLE_PRINT) \
        has_type(FIELD(type, enum parsed_type, DISABLE_PRINT)) \
*/
        output_line(gen, "};");
        output_line(gen, "struct parsed_%%rule parsed_%%rule_get(struct bluebird_tree *, parsed_id);");
        output_line(gen, "struct parsed_%%rule parsed_%%rule_next(struct parsed_%%rule);");
    }

    output_line(gen, "#ifdef BLUEBIRD_PARSER_IMPLEMENTATION");
    output_line(gen, "#endif BLUEBIRD_PARSER_IMPLEMENTATION");

    output_line(gen, "#endif");

    free(internal.substitutions);
    gen->internal = 0;
}

#endif
