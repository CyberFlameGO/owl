#include "6a-generate.h"

#include "6a-generate-output.h"
#include "grow-array.h"
#include "x-construct-actions.h"
#include <stdio.h>
#include <string.h>

static bool rule_is_named(struct rule *rule, const char *name);
static bool token_is(struct token *token, const char *name);

static void generate_fields_for_token_rule(struct generator_output *out,
 struct rule *rule, const char *string);
static void generate_keyword_reader(struct generator *gen,
 struct generator_output *out);

enum automaton_type { NORMAL_AUTOMATON, BRACKET_AUTOMATON };
static void generate_automaton(struct generator *gen,
 struct generator_output *out, struct automaton *a, uint32_t offset,
 enum automaton_type type);
static void generate_action_automaton(struct generator *gen,
 struct generator_output *out, struct action_map *map, uint32_t dfa_offset,
 uint32_t nfa_offset, uint32_t bracket_nfa_offset, enum automaton_type type);
static void generate_actions(struct generator_output *out,
 struct action_map *map, uint32_t action_index);

static void output_indentation(struct generator_output *out,
 size_t indentation);

static bool should_escape(char c);

static int compare_tokens(const void *a, const void *b);

void generate(struct generator *gen)
{
    struct generator_output *out = output_create(gen->output);

    set_substitution(out, "root-rule",
     gen->grammar->rules[gen->grammar->root_rule].name,
     gen->grammar->rules[gen->grammar->root_rule].name_length,
     LOWERCASE_WITH_UNDERSCORES);
    set_unsigned_number_substitution(out, "root-rule-index",
     gen->grammar->root_rule);

    output_line(out, "// -----------------------------------------------------------------------------");
    output_line(out, "// This file was generated by the bluebird parsing tool.");
    output_line(out, "// Make sure to #define BLUEBIRD_PARSER_IMPLEMENTATION somewhere so the parser");
    output_line(out, "// is compiled properly.  Just two lines are enough -- a typical parser.c might");
    output_line(out, "// look like:");
    output_line(out, "//");
    output_line(out, "//   #define BLUEBIRD_PARSER_IMPLEMENTATION");
    output_line(out, "//   #include \"bluebird-parser.h\"");
    output_line(out, "");
    output_line(out, "#ifndef _BLUEBIRD_PARSER_H_");
    output_line(out, "#define _BLUEBIRD_PARSER_H_");
    output_line(out, "");
    output_line(out, "#include \"stdbool.h\"");
    output_line(out, "#include \"stddef.h\"");
    output_line(out, "#include \"stdint.h\"");
    output_line(out, "");
    output_line(out, "// A parsed_id represents an element in the parse tree.  Use the");
    output_line(out, "// parsed_..._get() function corresponding to the element type to unpack the");
    output_line(out, "// element into its appropriate type of parsed_... element struct.");
    output_line(out, "typedef size_t parsed_id;");
    output_line(out, "");
    output_line(out, "// The bluebird_tree struct represents an entire parse tree.  Use the");
    output_line(out, "// bluebird_tree_create_...() functions to create a tree, then call");
    output_line(out, "// bluebird_tree_root() to get the root bluebird_id.");
    output_line(out, "struct bluebird_tree;");
    output_line(out, "");
    output_line(out, "// Creates a bluebird_tree from a string.  Remember to call");
    output_line(out, "// bluebird_tree_destroy() when you're done with it.");
    output_line(out, "struct bluebird_tree *bluebird_tree_create_from_string(const char *string);");
    output_line(out, "");
    output_line(out, "// Destroys a bluebird_tree, freeing its resources back to the system.");
    output_line(out, "void bluebird_tree_destroy(struct bluebird_tree *);");
    output_line(out, "");
    output_line(out, "// Prints a representation of the tree to stdout.");
    output_line(out, "void bluebird_tree_print(struct bluebird_tree *);");
    output_line(out, "");
    output_line(out, "// Returns the root parsed_id.");
    output_line(out, "parsed_id bluebird_tree_root_id(struct bluebird_tree *tree);");
    output_line(out, "");
    output_line(out, "// As a shortcut, returns the parsed_%%root-rule struct corresponding to the root parsed_id.");
    output_line(out, "struct parsed_%%root-rule bluebird_tree_get_parsed_%%root-rule(struct bluebird_tree *tree);");
    output_line(out, "");
    output_line(out, "// The range of text corresponding to a tree element.");
    output_line(out, "struct source_range {");
    output_line(out, "    size_t start;");
    output_line(out, "    size_t end;");
    output_line(out, "};");

    uint32_t n = gen->grammar->number_of_rules;
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "");
        if (rule->number_of_choices > 0) {
            output_line(out, "enum parsed_%%rule_type {");
            for (uint32_t j = 0; j < rule->number_of_choices; ++j) {
                set_substitution(out, "choice-name", rule->choices[j].name,
                 rule->choices[j].name_length, UPPERCASE_WITH_UNDERSCORES);
                output_line(out, "    PARSED_%%choice-name,");
            }
            for (uint32_t j = 0; j < rule->number_of_operators; ++j) {
                set_substitution(out, "operator-name", rule->operators[j].name,
                 rule->operators[j].name_length, UPPERCASE_WITH_UNDERSCORES);
                output_line(out, "    PARSED_%%operator-name,");
            }
            output_line(out, "};");
        }
        output_line(out, "struct parsed_%%rule {");
        output_line(out, "    struct bluebird_tree *_tree;");
        output_line(out, "    parsed_id _next;");
        output_line(out, "    struct source_range range;");
        output_line(out, "    bool empty;");
        if (rule->number_of_choices > 0)
            output_line(out, "    enum parsed_%%rule_type type;");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            struct slot slot = rule->slots[j];
            set_substitution(out, "referenced-slot", slot.name,
             slot.name_length, LOWERCASE_WITH_UNDERSCORES);
            output_line(out, "    parsed_id %%referenced-slot;");
        }
        if (rule->is_token)
            generate_fields_for_token_rule(out, rule, "    %%type%%field;\n");
        output_line(out, "};");
    }
    output_line(out, "");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "struct parsed_%%rule parsed_%%rule_get(struct bluebird_tree *, parsed_id);");
    }
    output_line(out, "");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "static inline struct parsed_%%rule parsed_%%rule_next(struct parsed_%%rule parsed)");
        output_line(out, "{");
        output_line(out, "    return parsed_%%rule_get(parsed._tree, parsed._next);");
        output_line(out, "}");
    }
    output_line(out, "");
    output_line(out, "#endif");

    output_line(out, "");
    output_line(out, "#ifdef BLUEBIRD_PARSER_IMPLEMENTATION");
    output_line(out, "// Code implementing the parser.  This might get a bit messy!");
    output_line(out, "#include <assert.h>");
    output_line(out, "#include <stdio.h>");
    output_line(out, "#include <stdlib.h>");
    output_line(out, "#include <string.h>");
    output_line(out, "");
    output_line(out, "struct bluebird_tree {");
    output_line(out, "    const char *string;");
    output_line(out, "    uint8_t *parse_tree;");
    output_line(out, "    size_t parse_tree_size;");
    output_line(out, "    parsed_id next_id;");
    output_line(out, "    parsed_id root_id;");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "    struct {");
        generate_fields_for_token_rule(out, rule, "        %%type%%field;\n");
        // FIXME: This isn't very memory-efficient.
        output_line(out, "        struct source_range range;");
        output_line(out, "    } *%%rule_tokens;");
        output_line(out, "    size_t number_of_%%rule_tokens;");
        output_line(out, "    size_t used_%%rule_tokens;");
        output_line(out, "    size_t %%rule_tokens_capacity;");
    }
    output_line(out, "};");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_string(out, "static void add_%%rule_token(struct bluebird_tree *tree, size_t start, size_t end");
        generate_fields_for_token_rule(out, rule, ", %%type%%field_param");
        output_line(out, ") {");
        output_line(out, "    size_t index = tree->number_of_%%rule_tokens++;");
        output_line(out, "    if (tree->number_of_%%rule_tokens > tree->%%rule_tokens_capacity) {");
        output_line(out, "        size_t capacity = (tree->%%rule_tokens_capacity + 1) * 3 / 2;");
        output_line(out, "        void *tokens = realloc(tree->%%rule_tokens, sizeof(tree->%%rule_tokens[0]) * capacity);");
        output_line(out, "        if (!tokens)");
        output_line(out, "            abort();");
        output_line(out, "        tree->%%rule_tokens_capacity = capacity;");
        output_line(out, "        tree->%%rule_tokens = tokens;");
        output_line(out, "    }");
        output_line(out, "    tree->%%rule_tokens[index].range.start = start;");
        output_line(out, "    tree->%%rule_tokens[index].range.end = end;");
        generate_fields_for_token_rule(out, rule, "    tree->%%rule_tokens[index].%%field = %%field_param;\n");
        output_line(out, "}");
    }

    set_literal_substitution(out, "token-type", "uint32_t");
    set_literal_substitution(out, "state-type", "uint32_t");

    // Code for reading and writing packed parse trees.
    // TODO: Delta encoding instead of absolute numbers.
    output_line(out, "static inline parsed_id read_tree(parsed_id *id, struct bluebird_tree *tree) {");
    output_line(out, "    uint8_t *parse_tree = tree->parse_tree;");
    output_line(out, "    size_t parse_tree_size = tree->parse_tree_size;");
    output_line(out, "    if (*id >= parse_tree_size)");
    output_line(out, "        return 0;");
    output_line(out, "    parsed_id result = parse_tree[*id] & 0x7f;");
    output_line(out, "    (*id)++;");
    output_line(out, "    int shift_amount = 7;");
    output_line(out, "    while (*id < parse_tree_size && (parse_tree[*id] & 0x80) != 0) {");
    output_line(out, "        result |= (parse_tree[*id] & 0x7f) << shift_amount;");
    output_line(out, "        shift_amount += 7;");
    output_line(out, "        (*id)++;");
    output_line(out, "    }");
    output_line(out, "    return result;");
    output_line(out, "}");
    output_line(out, "static bool grow_tree(struct bluebird_tree *tree, size_t size)");
    output_line(out, "{");
    output_line(out, "    size_t n = tree->parse_tree_size;");
    output_line(out, "    while (size > n)");
    output_line(out, "        n = (n + 1) * 3 / 2;");
    output_line(out, "    uint8_t *parse_tree = realloc(tree->parse_tree, n);");
    output_line(out, "    if (!parse_tree)");
    output_line(out, "        return false;");
    output_line(out, "    memset(parse_tree + tree->parse_tree_size, 0, n - tree->parse_tree_size);");
    output_line(out, "    tree->parse_tree_size = n;");
    output_line(out, "    tree->parse_tree = parse_tree;");
    output_line(out, "    return true;");
    output_line(out, "}");
    output_line(out, "static void write_tree(struct bluebird_tree *tree, parsed_id value)");
    output_line(out, "{");
    output_line(out, "    // Reserve 10 bytes (the maximum encoded size of a 64-bit value).");
    output_line(out, "    size_t reserved_size = tree->next_id + 10;");
    output_line(out, "    if (tree->parse_tree_size <= reserved_size && !grow_tree(tree, reserved_size))");
    // FIXME: Should we handle this case?
    output_line(out, "        return;");
    output_line(out, "    tree->parse_tree[tree->next_id++] = value & 0x7f;");
    output_line(out, "    value >>= 7;");
    output_line(out, "    while (value > 0) {");
    output_line(out, "        tree->parse_tree[tree->next_id++] = 0x80 | (value & 0x7f);");
    output_line(out, "        value >>= 7;");
    output_line(out, "    }");
    output_line(out, "}");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "struct parsed_%%rule parsed_%%rule_get(struct bluebird_tree *tree, parsed_id id) {");
        output_line(out, "    if (id == 0)");
        output_line(out, "        return (struct parsed_%%rule){ ._tree = tree, .empty = true };");
        output_line(out, "    parsed_id next = read_tree(&id, tree);");
        if (rule->is_token)
            output_line(out, "    size_t token_index = read_tree(&id, tree);");
        else {
            output_line(out, "    size_t start_location = read_tree(&id, tree);");
            output_line(out, "    size_t end_location = read_tree(&id, tree);");
        }
        output_line(out, "    return (struct parsed_%%rule){");
        output_line(out, "        ._tree = tree,");
        output_line(out, "        ._next = next,");
        if (rule->is_token) {
            generate_fields_for_token_rule(out, rule, "        .%%field = tree->%%rule_tokens[token_index].%%field,\n");
            output_line(out, "        .range = tree->%%rule_tokens[token_index].range,");
        } else {
            output_line(out, "        .range.start = start_location,");
            output_line(out, "        .range.end = end_location,");
        }
        if (rule->number_of_choices > 0)
            output_line(out, "        .type = read_tree(&id, tree),");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            struct slot slot = rule->slots[j];
            set_substitution(out, "referenced-slot", slot.name,
             slot.name_length, LOWERCASE_WITH_UNDERSCORES);
            output_line(out, "        .%%referenced-slot = read_tree(&id, tree),");
        }
        output_line(out, "    };");
        output_line(out, "}");
    }
    output_line(out, "static parsed_id finish_node(uint32_t rule, uint32_t choice, "
     "parsed_id next_sibling, parsed_id *slots, size_t start_location, size_t end_location, void *info) {");
    output_line(out, "    struct bluebird_tree *tree = info;");
//    output_line(out, "    printf(\"finishing node (%lu): %u / %u\\n\", tree->next_id, rule, choice);");
    output_line(out, "    parsed_id id = tree->next_id;");
    output_line(out, "    write_tree(tree, next_sibling);");
    // TODO: Remove these casts.
    output_line(out, "    write_tree(tree, (parsed_id)start_location);");
    output_line(out, "    write_tree(tree, (parsed_id)end_location);");
    output_line(out, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (rule->is_token)
            continue;
        set_unsigned_number_substitution(out, "rule-index", i);
        output_line(out, "    case %%rule-index: {");
//        output_line(out, "        printf(\"next = %lu\\n\", next_sibling);");
        if (rule->number_of_choices > 0)
            output_line(out, "        write_tree(tree, choice);");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            set_unsigned_number_substitution(out, "slot-index", j);
//            output_line(out, "        printf(\"slot %%slot-index = %lu\\n\", slots[%%slot-index]);");
            output_line(out, "        write_tree(tree, slots[%%slot-index]);");
        }
        output_line(out, "        break;");
        output_line(out, "    }");
    }
    output_line(out, "    default:");
    output_line(out, "        break;");
    output_line(out, "    }");
    output_line(out, "    return id;");
    output_line(out, "}");
    output_line(out, "static parsed_id finish_token(uint32_t rule, parsed_id next_sibling, void *info) {");
    output_line(out, "    struct bluebird_tree *tree = info;");
//    output_line(out, "    printf(\"finishing token (%lu): %u\\n\", tree->next_id, rule);");
    output_line(out, "    parsed_id id = tree->next_id;");
    output_line(out, "    write_tree(tree, next_sibling);");
    output_line(out, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        set_unsigned_number_substitution(out, "rule-index", i);
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "    case %%rule-index: {");
        output_line(out, "        tree->used_%%rule_tokens++;");
        output_line(out, "        if (tree->used_%%rule_tokens > tree->number_of_%%rule_tokens)");
        output_line(out, "            abort();");
        output_line(out, "        size_t token_index = tree->number_of_%%rule_tokens - tree->used_%%rule_tokens;");
        // TODO: Remove this cast.
        output_line(out, "        write_tree(tree, (parsed_id)token_index);");
        output_line(out, "        break;");
        output_line(out, "    }");
    }
    output_line(out, "    default:");
    output_line(out, "        break;");
    output_line(out, "    }");
    output_line(out, "    return id;");
    output_line(out, "}");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "static void parsed_%%rule_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);");
    }
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "static void parsed_%%rule_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {");
        output_line(out, "    struct parsed_%%rule it = parsed_%%rule_get(tree, id);");
        output_line(out, "    while (!it.empty) {");
        output_line(out, "        for (int i = 0; i < indent; ++i) printf(\"  \");");
        output_line(out, "        printf(\"%%rule\");");
        output_line(out, "        if (strcmp(\"%%rule\", slot_name))");
        output_line(out, "            printf(\"@%s\", slot_name);");
        if (rule->number_of_choices > 0) {
            output_line(out, "        switch (it.type) {");
            for (uint32_t j = 0; j < rule->number_of_choices; ++j) {
                set_substitution(out, "choice-name", rule->choices[j].name,
                 rule->choices[j].name_length, UPPERCASE_WITH_UNDERSCORES);
                output_line(out, "        case PARSED_%%choice-name:");
                output_line(out, "            printf(\" : %%choice-name\");");
                output_line(out, "            break;");
            }
            for (uint32_t j = 0; j < rule->number_of_operators; ++j) {
                set_substitution(out, "operator-name", rule->operators[j].name,
                 rule->operators[j].name_length, UPPERCASE_WITH_UNDERSCORES);
                output_line(out, "        case PARSED_%%operator-name:");
                output_line(out, "            printf(\" : %%operator-name\");");
                output_line(out, "            break;");
            }
            output_line(out, "        }");
        }
        if (rule->is_token) {
            if (rule_is_named(rule, "identifier"))
                output_line(out, "        printf(\" - %.*s\", (int)it.length, it.identifier);");
            else if (rule_is_named(rule, "number"))
                output_line(out, "        printf(\" - %f\", it.number);");
            else if (rule_is_named(rule, "string"))
                output_line(out, "        printf(\" - %.*s\", (int)it.length, it.string);");
        }
        output_line(out, "        printf(\" (%zu - %zu)\\n\", it.range.start, it.range.end);");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            struct slot slot = rule->slots[j];
            set_substitution(out, "slot-name", slot.name, slot.name_length,
             LOWERCASE_WITH_UNDERSCORES);
            struct rule *slot_rule = &gen->grammar->rules[slot.rule_index];
            set_substitution(out, "slot-rule", slot_rule->name,
             slot_rule->name_length, LOWERCASE_WITH_UNDERSCORES);
            output_line(out, "        parsed_%%slot-rule_print(tree, it.%%slot-name, \"%%slot-name\", indent + 1);");
        }
        output_line(out, "        it = parsed_%%rule_next(it);");
        output_line(out, "    }");
        output_line(out, "}");
    }
    output_line(out, "void bluebird_tree_print(struct bluebird_tree *tree) {");
    output_line(out, "    parsed_%%root-rule_print(tree, tree->root_id, \"%%root-rule\", 0);");
    output_line(out, "}");

    output_line(out, "parsed_id bluebird_tree_root_id(struct bluebird_tree *tree) {");
    output_line(out, "    return tree->root_id;");
    output_line(out, "}");

    set_unsigned_number_substitution(out, "identifier-token", 0xffffffff);
    set_unsigned_number_substitution(out, "number-token", 0xffffffff);
    set_unsigned_number_substitution(out, "string-token", 0xffffffff);
    set_unsigned_number_substitution(out, "bracket-transition-token", 0xffffffff);
    output_line(out, "#define IGNORE_TOKEN_WRITE(...)");
    set_literal_substitution(out, "write-identifier-token", "IGNORE_TOKEN_WRITE");
    set_literal_substitution(out, "write-number-token", "IGNORE_TOKEN_WRITE");
    set_literal_substitution(out, "write-string-token", "IGNORE_TOKEN_WRITE");
    for (uint32_t i = gen->combined->number_of_keyword_tokens;
     i < gen->combined->number_of_tokens; ++i) {
        if (token_is(&gen->combined->tokens[i], "identifier"))
            set_unsigned_number_substitution(out, "identifier-token", i);
        else if (token_is(&gen->combined->tokens[i], "number"))
            set_unsigned_number_substitution(out, "number-token", i);
        else if (token_is(&gen->combined->tokens[i], "string"))
            set_unsigned_number_substitution(out, "string-token", i);
    }
    output_line(out, "static size_t read_keyword_token(%%token-type *token, bool *end_token, const char *text, void *info);");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        if (rule_is_named(rule, "identifier")) {
            output_line(out, "static void write_identifier_token(size_t offset, size_t length, void *info) {");
            output_line(out, "    struct bluebird_tree *tree = info;");
            output_line(out, "    add_identifier_token(tree, offset, offset + length, tree->string + offset, length);");
            output_line(out, "}");
            set_literal_substitution(out, "write-identifier-token", "write_identifier_token");
        } else if (rule_is_named(rule, "number")) {
            output_line(out, "static void write_number_token(size_t offset, size_t length, double number, void *info) {");
            output_line(out, "    struct bluebird_tree *tree = info;");
            output_line(out, "    add_number_token(tree, offset, offset + length, number);");
            output_line(out, "}");
            set_literal_substitution(out, "write-number-token", "write_number_token");
        } else if (rule_is_named(rule, "string")) {
            output_line(out, "static void write_string_token(size_t offset, size_t length, size_t content_offset, size_t content_length, void *info) {");
            output_line(out, "    struct bluebird_tree *tree = info;");
            output_line(out, "    add_string_token(tree, offset, offset + length, tree->string + offset, length);");
            output_line(out, "}");
            set_literal_substitution(out, "write-string-token", "write_string_token");
        }
    }
#define EVALUATE_MACROS_AND_STRINGIFY(...) #__VA_ARGS__

#define TOKEN_T %%token-type
#define STATE_T %%state-type
#define READ_KEYWORD_TOKEN read_keyword_token
#define WRITE_NUMBER_TOKEN %%write-number-token
#define WRITE_IDENTIFIER_TOKEN %%write-identifier-token
#define WRITE_STRING_TOKEN %%write-string-token
#define ALLOW_DASHES_IN_IDENTIFIERS(...) %%allow-dashes-in-identifiers
#define IDENTIFIER_TOKEN %%identifier-token
#define NUMBER_TOKEN %%number-token
#define STRING_TOKEN %%string-token
#define BRACKET_TRANSITION_TOKEN %%bracket-transition-token

    const char *tokenizer_source;
#define TOKENIZE_BODY(...) tokenizer_source = EVALUATE_MACROS_AND_STRINGIFY(__VA_ARGS__);
#include "x-tokenize.h"
    if (SHOULD_ALLOW_DASHES_IN_IDENTIFIERS(gen->combined))
        set_literal_substitution(out, "allow-dashes-in-identifiers", "true");
    else
        set_literal_substitution(out, "allow-dashes-in-identifiers", "false");
    output_formatted_source(out, tokenizer_source);
    output_line(out, "static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context);");
    output_line(out, "static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context);");
    output_line(out, "static size_t number_of_slots_lookup(uint32_t rule, void *context);");
    output_line(out, "static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context);");

#define FINISHED_NODE_T parsed_id
#define FINISH_NODE finish_node
#define FINISH_TOKEN finish_token

#define RULE_T uint32_t
#define RULE_LOOKUP rule_lookup
#define ROOT_RULE(...) %%root-rule-index
#define FIXITY_ASSOCIATIVITY_PRECEDENCE_LOOKUP(fixity_associativity, precedence, rule, choice, context) \
 do { \
     int local; \
     fixity_associativity_precedence_lookup(&local, &precedence, rule, choice, context); \
     fixity_associativity = local; \
 } while (0)
#define NUMBER_OF_SLOTS_LOOKUP number_of_slots_lookup
#define LEFT_RIGHT_OPERAND_SLOTS_LOOKUP(rule, left, right, operand, info) \
 (left_right_operand_slots_lookup(rule, &(left), &(right), &(operand), info))

    const char *construct_source;
#define CONSTRUCT_BODY(...) construct_source = EVALUATE_MACROS_AND_STRINGIFY(__VA_ARGS__);
#include "x-construct-parse-tree.h"
    output_formatted_source(out, construct_source);

    set_unsigned_number_substitution(out, "start-state",
     gen->deterministic->automaton.start_state);
    output_line(out, "");
    output_line(out, "struct state_stack {");
    output_line(out, "    %%state-type *states;");
    output_line(out, "    size_t capacity;");
    output_line(out, "    size_t depth;");
    output_line(out, "};");
    output_line(out, "struct fill_run_continuation {");
    output_line(out, "    %%state-type state;");
    output_line(out, "    struct state_stack stack;");
    output_line(out, "};");
    output_line(out, "static void fill_run_states(struct bluebird_token_run *, struct fill_run_continuation *);");
    output_line(out, "static parsed_id build_parse_tree(struct bluebird_default_tokenizer *, struct bluebird_token_run *, struct bluebird_tree *);");
    output_line(out, "");
    output_line(out, "struct bluebird_tree *bluebird_tree_create_from_string(const char *string) {");
    output_line(out, "    struct bluebird_tree *tree = calloc(1, sizeof(struct bluebird_tree));");
    output_line(out, "    tree->string = string;");
    output_line(out, "    tree->next_id = 1;");
    output_line(out, "    struct bluebird_default_tokenizer tokenizer = {");
    output_line(out, "        .text = string,");
    output_line(out, "        .info = tree,");
    output_line(out, "    };");
    output_line(out, "    struct bluebird_token_run *token_run = 0;");
    output_line(out, "    struct fill_run_continuation c = {");
    output_line(out, "        .state = %%start-state,");
    output_line(out, "    };");
    output_line(out, "    while (bluebird_default_tokenizer_advance(&tokenizer, &token_run))");
    output_line(out, "        fill_run_states(token_run, &c);");
    output_line(out, "    if (string[tokenizer.offset] != '\\0') {");
    output_line(out, "        // TODO: Return error instead of printing it");
    output_line(out, "        fprintf(stderr, \"error: tokenizing failed. next char was %u\\n\", string[tokenizer.offset]);");
    output_line(out, "        exit(-1);");
    output_line(out, "    }");
    output_line(out, "    if (c.stack.depth > 0) {");
    output_line(out, "        // TODO: Return error instead of printing it");
    output_line(out, "        fprintf(stderr, \"error: parsing failed because the stack was still full\\n\");");
    output_line(out, "    }");
    output_line(out, "    free(c.stack.states);");
    /*
    output_line(out, "    struct bluebird_token_run *run_to_print = token_run;");
    output_line(out, "    while (run_to_print) {");
    output_line(out, "        for (uint32_t i = 0; i < run_to_print->number_of_tokens; ++i) {");
    output_line(out, "            printf(\"%u -> %u\\n\", run_to_print->tokens[i], run_to_print->states[i]);");
    output_line(out, "        }");
    output_line(out, "        printf(\"--\\n\");");
    output_line(out, "        run_to_print = run_to_print->prev;");
    output_line(out, "    }");
     */
    output_line(out, "    tree->root_id = build_parse_tree(&tokenizer, token_run, tree);");
    output_line(out, "    return tree;");
    output_line(out, "}");
    output_line(out, "void bluebird_tree_destroy(struct bluebird_tree *tree) {");
    output_line(out, "    free(tree);");
    output_line(out, "}");
    output_line(out, "static bool grow_state_stack(struct state_stack *stack) {");
    output_line(out, "    size_t new_capacity = (stack->capacity + 2) * 3 / 2;");
    output_line(out, "    if (new_capacity <= stack->capacity)");
    output_line(out, "        return false;");
    output_line(out, "    %%state-type *new_states = realloc(stack->states, new_capacity * sizeof(%%state-type));");
    output_line(out, "    if (!new_states)");
    output_line(out, "        return false;");
    output_line(out, "    stack->states = new_states;");
    output_line(out, "    stack->capacity = new_capacity;");
    output_line(out, "    return true;");
    output_line(out, "}");
    struct automaton *a = &gen->deterministic->automaton;
    struct automaton *b = &gen->deterministic->bracket_automaton;
    set_unsigned_number_substitution(out, "first-bracket-state-id",
     a->number_of_states);
    output_line(out, "static void fill_run_states(struct bluebird_token_run *run, struct fill_run_continuation *cont) {");
    output_line(out, "    uint16_t token_index = 0;");
    output_line(out, "    uint16_t number_of_tokens = run->number_of_tokens;");
    output_line(out, "    uint16_t start_state = cont->state;");
    output_line(out, "start:");
    output_line(out, "    switch (start_state) {");
    generate_automaton(gen, out, a, 0, NORMAL_AUTOMATON);
    generate_automaton(gen, out, b, a->number_of_states, BRACKET_AUTOMATON);
    output_line(out, "    }");
    output_line(out, "}");
    set_unsigned_number_substitution(out, "final-nfa-state",
     gen->combined->final_nfa_state);
    output_line(out, "static parsed_id build_parse_tree(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run *run, struct bluebird_tree *tree) {");
    output_line(out, "    struct construct_state construct_state = { .info = tree };");
    output_line(out, "    struct state_stack stack = {0};");
    output_line(out, "    size_t whitespace = tokenizer->whitespace;");
    output_line(out, "    size_t offset = tokenizer->offset - whitespace;");
    if (gen->combined->root_rule_is_expression)
        output_line(out, "    construct_begin(&construct_state, offset, CONSTRUCT_EXPRESSION_ROOT);");
    else
        output_line(out, "    construct_begin(&construct_state, offset, CONSTRUCT_NORMAL_ROOT);");
    output_line(out, "    if (!run)");
    output_line(out, "        goto finish;");
    output_line(out, "    uint16_t token_index = run->number_of_tokens;");
    output_line(out, "    uint16_t length_offset = run->lengths_size - 1;");
    output_line(out, "    %%state-type start_state = %%final-nfa-state;");
    output_line(out, "start:");
    output_line(out, "    switch (start_state) {");
    uint32_t nfa_offset = gen->combined->automaton.number_of_states;
    generate_action_automaton(gen, out, &gen->deterministic->action_map, 0, 0,
     nfa_offset, NORMAL_AUTOMATON);
    generate_action_automaton(gen, out, &gen->deterministic->bracket_action_map,
     a->number_of_states, nfa_offset, gen->combined->automaton.number_of_states,
     BRACKET_AUTOMATON);
    output_line(out, "    }");
    // TODO: Free all remaining token runs here.
    output_line(out, "    printf(\"error!\\n\");");
    output_line(out, "    exit(-1);");
    output_line(out, "finish:");
    output_line(out, "    free(stack.states);");
    output_line(out, "    return construct_finish(&construct_state, offset);");
    output_line(out, "}");
    generate_keyword_reader(gen, out);
    output_line(out, "static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context) {");
    output_line(out, "    switch (parent) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (rule->number_of_slots == 0)
            continue;
        set_unsigned_number_substitution(out, "rule-index", i);
        output_line(out, "    case %%rule-index:");
        output_line(out, "        switch (slot) {");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            set_unsigned_number_substitution(out, "slot-index", j);
            set_unsigned_number_substitution(out, "slot-rule-index",
             rule->slots[j].rule_index);
            output_line(out, "        case %%slot-index: return %%slot-rule-index;");
        }
        output_line(out, "        default: break;");
        output_line(out, "        }");
        output_line(out, "        break;");
    }
    output_line(out, "    default: break;");
    output_line(out, "    }");
    output_line(out, "    return UINT32_MAX;");
    output_line(out, "}");
    output_line(out, "static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context) {");
    output_line(out, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (rule->number_of_operators == 0)
            continue;
        set_unsigned_number_substitution(out, "rule-index", i);
        output_line(out, "    case %%rule-index:");
        output_line(out, "        switch (choice) {");
        for (uint32_t j = 0; j < rule->number_of_operators; ++j) {
            struct operator op = rule->operators[j];
            set_unsigned_number_substitution(out, "choice-index",
             j + rule->number_of_choices);
            set_signed_number_substitution(out, "operator-precedence",
             op.precedence);
            output_line(out, "        case %%choice-index:");
            output_line(out, "            *precedence = %%operator-precedence;");
            if (op.fixity == PREFIX)
                output_line(out, "            *fixity_associativity = CONSTRUCT_PREFIX;");
            else if (op.fixity == POSTFIX)
                output_line(out, "            *fixity_associativity = CONSTRUCT_POSTFIX;");
            else if (op.associativity == RIGHT)
                output_line(out, "            *fixity_associativity = CONSTRUCT_INFIX_RIGHT;");
            else if (op.associativity == FLAT)
                output_line(out, "            *fixity_associativity = CONSTRUCT_INFIX_FLAT;");
            else
                output_line(out, "            *fixity_associativity = CONSTRUCT_INFIX_LEFT;");
            output_line(out, "            return;");
        }
        output_line(out, "        default: return;");
        output_line(out, "        }");
    }
    output_line(out, "    default: return;");
    output_line(out, "    }");
    output_line(out, "}");
    output_line(out, "static size_t number_of_slots_lookup(uint32_t rule, void *context) {");
    output_line(out, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        set_unsigned_number_substitution(out, "rule-index", i);
        set_unsigned_number_substitution(out, "number-of-slots",
         gen->grammar->rules[i].number_of_slots);
        output_line(out, "    case %%rule-index: return %%number-of-slots;");
    }
    output_line(out, "    default: return 0;");
    output_line(out, "    }");
    output_line(out, "}");
    output_line(out, "static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context) {");
    output_line(out, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_unsigned_number_substitution(out, "rule-index", i);
        set_unsigned_number_substitution(out, "left-slot",
         rule->left_slot_index);
        set_unsigned_number_substitution(out, "right-slot",
         rule->right_slot_index);
        set_unsigned_number_substitution(out, "operand-slot",
         rule->operand_slot_index);
        output_line(out, "    case %%rule-index:");
        output_line(out, "        *left = %%left-slot;");
        output_line(out, "        *right = %%right-slot;");
        output_line(out, "        *operand = %%operand-slot;");
        output_line(out, "        break;");
    }
    output_line(out, "    }");
    output_line(out, "}");
    output_line(out, "#endif");
    output_line(out, "");

    output_destroy(out);
}

static void generate_fields_for_token_rule(struct generator_output *out,
 struct rule *rule, const char *string)
{
    if (rule_is_named(rule, "identifier")) {
        set_literal_substitution(out, "type", "const char *");
        set_literal_substitution(out, "field", "identifier");
        output_string(out, string);
        set_literal_substitution(out, "type", "size_t ");
        set_literal_substitution(out, "field", "length");
        output_string(out, string);
    } else if (rule_is_named(rule, "number")) {
        set_literal_substitution(out, "type", "double ");
        set_literal_substitution(out, "field", "number");
        output_string(out, string);
    } else if (rule_is_named(rule, "string")) {
        set_literal_substitution(out, "type", "const char *");
        set_literal_substitution(out, "field", "string");
        output_string(out, string);
        set_literal_substitution(out, "type", "size_t ");
        set_literal_substitution(out, "field", "length");
        output_string(out, string);
    } else
        abort();
}

struct generated_token {
    struct token token;
    struct generated_token *prefix;
};

static void generate_keyword(struct generator_output *out, struct token keyword,
 size_t indentation)
{
    set_unsigned_number_substitution(out, "token-index", keyword.symbol);
    if (keyword.length > UINT32_MAX)
        abort();
    set_unsigned_number_substitution(out, "token-length",
     (uint32_t)keyword.length);
    output_indentation(out, indentation);
    if (keyword.type == TOKEN_END)
        output_line(out, "*end_token = true;");
    else
        output_line(out, "*end_token = false;");
    output_indentation(out, indentation);
    output_line(out, "*token = %%token-index;");
    output_indentation(out, indentation);
    output_line(out, "return %%token-length;");
}

static void generate_keyword_reader(struct generator *gen,
 struct generator_output *out) {
    output_line(out, "static size_t read_keyword_token(%%token-type *token, bool *end_token, const char *text, void *info) {");
    output_line(out, "    switch (text[0]) {");
    struct generated_token *tokens = malloc(sizeof(struct generated_token) *
     (size_t)gen->combined->number_of_keyword_tokens);
    if (!tokens) {
        fputs("critical error: out of memory\n", stderr);
        exit(-1);
    }
    for (uint32_t i = 0; i < gen->combined->number_of_keyword_tokens; ++i)
        tokens[i].token = gen->combined->tokens[i];
    qsort(tokens, gen->combined->number_of_keyword_tokens,
     sizeof(struct generated_token), compare_tokens);
    size_t shared_length = 0;
    struct generated_token *prefix = 0;
    for (uint32_t i = 0; i < gen->combined->number_of_keyword_tokens; ++i) {
        struct generated_token *token = &tokens[i];
        struct token keyword = token->token;
        struct generated_token *next = 0;
        size_t next_length = 0;
        if (i + 1 < gen->combined->number_of_keyword_tokens) {
            next = &tokens[i + 1];
            next_length = next->token.length;
        }
        size_t shared = 0;
        for (; shared < keyword.length && shared < next_length; shared++) {
            if (keyword.string[shared] != next->token.string[shared])
                break;
        }
        while (shared > shared_length) {
            set_unsigned_number_substitution(out, "character",
             keyword.string[shared_length]);
            output_indentation(out, shared_length + 1);
            output_line(out, "case %%character:");
            shared_length++;
            if (shared_length > UINT32_MAX)
                abort();
            set_unsigned_number_substitution(out, "index",
             (uint32_t)shared_length);
            output_indentation(out, shared_length + 1);
            output_line(out, "switch (text[%%index]) {");
        }
        token->prefix = prefix;
        if (shared == keyword.length) {
            prefix = token;
            continue;
        }
        set_unsigned_number_substitution(out, "character",
         keyword.string[shared_length]);
        output_indentation(out, shared_length + 1);
        output_line(out, "case %%character:");
        if (keyword.length <= shared_length + 1)
            generate_keyword(out, keyword, shared_length + 2);
        else {
            if (shared_length + 1 > UINT32_MAX)
                abort();
            set_unsigned_number_substitution(out, "offset",
             (uint32_t)(shared_length + 1));
            output_indentation(out, shared_length + 2);
            output_string(out, "if (strncmp(text + %%offset, \"");
            for (size_t j = shared_length + 1; j < keyword.length; ++j) {
                if (!should_escape(keyword.string[j])) {
                    gen->output(&keyword.string[j], 1);
                    continue;
                }
                char string[8];
                snprintf(string, sizeof(string), "\\x%02x", keyword.string[j]);
                gen->output(string, strlen(string));
            }
            if (keyword.length - shared_length - 1 > UINT32_MAX)
                abort();
            set_unsigned_number_substitution(out, "token-length",
             (uint32_t)(keyword.length - shared_length - 1));
            output_line(out, "\", %%token-length) == 0) {");
            generate_keyword(out, keyword, shared_length + 3);
            output_indentation(out, shared_length + 2);
            output_line(out, "} else {");
            if (prefix)
                generate_keyword(out, prefix->token, shared_length + 3);
            else {
                output_indentation(out, shared_length + 3);
                output_line(out, "return 0;");
            }
            output_indentation(out, shared_length + 2);
            output_line(out, "}");
        }
        while (shared_length > shared) {
            output_indentation(out, shared_length + 1);
            output_line(out, "default:");
            if (prefix) {
                generate_keyword(out, prefix->token, shared_length + 2);
                if (prefix->token.length >= shared_length)
                    prefix = prefix->prefix;
            } else {
                output_indentation(out, shared_length + 2);
                output_line(out, "return 0;");
            }
            output_indentation(out, shared_length + 1);
            output_line(out, "}");
            shared_length--;
        }
    }
    output_line(out, "    default:");
    output_line(out, "        return 0;");
    output_line(out, "    }");
    output_line(out, "}");
}

static void generate_automaton(struct generator *gen,
 struct generator_output *out, struct automaton *a, uint32_t offset,
 enum automaton_type type)
{
    for (uint32_t i = 0; i < a->number_of_states; ++i) {
        struct state s = a->states[i];
        set_unsigned_number_substitution(out, "state-id", i + offset);
        output_line(out, "    case %%state-id:");
        output_line(out, "state_%%state-id: {");
        if (s.accepting && type == BRACKET_AUTOMATON) {
            set_unsigned_number_substitution(out, "state-transition-symbol",
             s.transition_symbol);
            output_line(out, "        start_state = cont->stack.states[--cont->stack.depth];");
            output_line(out, "        run->tokens[token_index] = %%state-transition-symbol;");
            output_line(out, "        goto start;");
            output_line(out, "    }");
            continue;
        }
        output_line(out, "        if (token_index >= number_of_tokens) {");
        output_line(out, "            cont->state = %%state-id;");
        output_line(out, "            return;");
        output_line(out, "        }");
        output_line(out, "        %%token-type token = run->tokens[token_index];");
        output_line(out, "        run->states[token_index] = %%state-id;");
        output_line(out, "        token_index++;");
        output_line(out, "        switch (token) {");
        bool has_bracket_symbols = false;
        for (uint32_t j = 0; j < s.number_of_transitions; ++j) {
            struct transition t = s.transitions[j];
            if (t.symbol >= gen->combined->number_of_tokens) {
                // Symbols are either tokens or bracket symbols, so this must
                // be a bracket symbol.
                has_bracket_symbols = true;
            }
            set_unsigned_number_substitution(out, "token-symbol", t.symbol);
            set_unsigned_number_substitution(out, "token-target", t.target + offset);
            output_line(out, "        case %%token-symbol: goto state_%%token-target;");
        }
        output_string(out, "        default:");
        if (has_bracket_symbols) {
            output_line(out, "");
            output_line(out, "            if (cont->stack.depth >= cont->stack.capacity) {");
            output_line(out, "                if (!grow_state_stack(&cont->stack))");
            output_line(out, "                    break;"); // TODO: Error handling.
            output_line(out, "            }");
            output_line(out, "            cont->stack.states[cont->stack.depth++] = %%state-id;");
            output_line(out, "            token_index--;");
            output_line(out, "            goto state_%%first-bracket-state-id;");
        } else
            output_line(out, " break;"); // TODO: Error handling.
        output_line(out, "        }");
        output_line(out, "        break;");
        output_line(out, "    }");
    }
}

static void generate_action_automaton(struct generator *gen,
 struct generator_output *out, struct action_map *map, uint32_t dfa_offset,
 uint32_t nfa_offset, uint32_t bracket_nfa_offset, enum automaton_type type)
{
    for (uint32_t i = 0; i < map->number_of_entries; ++i) {
        struct action_map_entry entry = map->entries[i];
        struct action_map_entry *last_entry = 0;
        if (i > 0)
            last_entry = &map->entries[i - 1];
        if (!last_entry || last_entry->target_nfa_state != entry.target_nfa_state) {
            set_unsigned_number_substitution(out, "entry-target",
             entry.target_nfa_state + nfa_offset);
            output_line(out, "    case %%entry-target:");
            output_line(out, "nfa_state_%%entry-target: {");
            output_line(out, "        size_t end = offset;");
            output_line(out, "        size_t len = 0;");
            output_line(out, "        if (token_index == 0) {");
            output_line(out, "            struct bluebird_token_run *last_run = run;");
            output_line(out, "            run = run->prev;");
            output_line(out, "            free(last_run);");
            output_line(out, "            if (!run) {");
            struct action_map_entry *final_entry = action_map_find(map, entry.target_nfa_state, UINT32_MAX, UINT32_MAX);
            if (!final_entry) {
                output_line(out, "                break;");
            } else {
                generate_actions(out, map, final_entry->action_index);
                output_line(out, "                goto finish;");
            }
            output_line(out, "            }");
            output_line(out, "            token_index = run->number_of_tokens;");
            output_line(out, "            length_offset = run->lengths_size - 1;");
            output_line(out, "        }");
            output_line(out, "        token_index--;");
            output_line(out, "        switch (run->states[token_index]) {");
        }
        struct action_map_entry *next_entry = 0;
        if (i + 1 < map->number_of_entries)
            next_entry = &map->entries[i + 1];
        if (entry.dfa_state != UINT32_MAX) {
            if (!last_entry || last_entry->dfa_state != entry.dfa_state || last_entry->target_nfa_state != entry.target_nfa_state) {
                set_unsigned_number_substitution(out, "entry-state-id",
                 entry.dfa_state + dfa_offset);
                output_line(out, "        case %%entry-state-id:");
                output_line(out, "            switch (run->tokens[token_index]) {");
            }
            set_unsigned_number_substitution(out, "entry-symbol",
             entry.dfa_symbol);
            output_line(out, "            case %%entry-symbol:");
            if (entry.dfa_symbol < gen->combined->number_of_tokens)
                output_line(out, "                len = decode_token_length(run, &length_offset, &offset);");
            generate_actions(out, map, entry.action_index);
            output_line(out, "                whitespace = end - offset - len;");
            set_unsigned_number_substitution(out, "entry-nfa-state",
             entry.nfa_state + nfa_offset);
            if (type == BRACKET_AUTOMATON && entry.dfa_state ==
             gen->deterministic->bracket_automaton.start_state) {
                output_line(out, "                start_state = stack.states[--stack.depth];");
                output_line(out, "                goto start;");
            } else if (entry.dfa_symbol >= gen->combined->number_of_tokens) {
                output_line(out, "                if (stack.depth >= stack.capacity) {");
                output_line(out, "                    if (!grow_state_stack(&stack))");
                output_line(out, "                        break;"); // TODO: Error handling.
                output_line(out, "                }");
                output_line(out, "                stack.states[stack.depth++] = %%entry-nfa-state;");
                struct automaton *b = &gen->combined->bracket_automaton;
                for (state_id j = 0; j < b->number_of_states; ++j) {
                    if (!b->states[j].accepting)
                        continue;
                    if (b->states[j].transition_symbol != entry.nfa_symbol)
                        continue;
                    set_unsigned_number_substitution(out, "bracket-nfa-state",
                     j + bracket_nfa_offset);
                    output_line(out, "                goto nfa_state_%%bracket-nfa-state;");
                    break;
                }
            } else
                output_line(out, "                goto nfa_state_%%entry-nfa-state;");
            if (!next_entry || next_entry->dfa_state != entry.dfa_state || next_entry->target_nfa_state != entry.target_nfa_state) {
                output_line(out, "            default: break;");
                output_line(out, "            }");
                output_line(out, "            break;");
            }
        }
        if (!next_entry || next_entry->target_nfa_state != entry.target_nfa_state) {
            output_line(out, "        default: break;");
            output_line(out, "        }");
            output_line(out, "        break;");
            output_line(out, "    }");
        }
    }
}

static void generate_actions(struct generator_output *out,
 struct action_map *map, uint32_t action_index)
{
    bool include_whitespace = true;
    for (uint32_t i = action_index; i < map->number_of_actions; ++i) {
        if (map->actions[i] == 0)
            break;
        set_unsigned_number_substitution(out, "action-id", map->actions[i]);
        set_unsigned_number_substitution(out, "action-slot", CONSTRUCT_ACTION_GET_SLOT(map->actions[i]));
        if (is_end_action(map->actions[i]))
            include_whitespace = false;
        // TODO: end vs end + whitespace depending on whether it's an end action
        if (include_whitespace)
            output_line(out, "                construct_action_apply(&construct_state, %%action-id, end + whitespace);");
        else
            output_line(out, "                construct_action_apply(&construct_state, %%action-id, end);");
    }
}

static bool rule_is_named(struct rule *rule, const char *name)
{
    return rule->name_length == strlen(name) &&
     !memcmp(name, rule->name, rule->name_length);
}

static bool token_is(struct token *token, const char *name)
{
    return token->length == strlen(name) &&
     !memcmp(name, token->string, token->length);
}

static void output_indentation(struct generator_output *out, size_t indentation)
{
    for (int i = 0; i < indentation; ++i)
        output_string(out, "    ");
}

static bool should_escape(char c)
{
    if (c >= 'a' && c <= 'z')
        return false;
    if (c >= 'A' && c <= 'Z')
        return false;
    if (c >= '0' && c <= '9')
        return false;
    const char *symbols = "!#%&'()*+,-./:;<=>?[]^_{|}~";
    for (size_t i = 0; symbols[i]; ++i) {
        if (c == symbols[i])
            return false;
    }
    return true;
}

static int compare_tokens(const void *aa, const void *bb)
{
    const struct token *a = &((struct generated_token *)aa)->token;
    const struct token *b = &((struct generated_token *)bb)->token;
    size_t minlen = a->length < b->length ? a->length : b->length;
    int cmp = memcmp(a->string, b->string, minlen);
    if (cmp != 0)
        return cmp;
    if (a->length < b->length)
        return -1;
    if (a->length > b->length)
        return 1;
    return 0;
}
