#include "6a-generate.h"

#include "grow-array.h"
#include "x-construct-actions.h"
#include <stdio.h>
#include <string.h>

enum substitution_transform {
    NO_TRANSFORM,
    LOWERCASE_WITH_UNDERSCORES,
    UPPERCASE_WITH_UNDERSCORES,
};

enum substitution_type {
    STRING,
    UNSIGNED_NUMBER,
    SIGNED_NUMBER,
};

struct substitution {
    // Zero-terminated.
    const char *variable;

    enum substitution_type type;
    uint32_t unsigned_number;
    int32_t signed_number;

    const char *value;
    size_t value_length;

    enum substitution_transform transform;
};

struct generator_internal {
    struct substitution *substitutions;
    uint32_t substitutions_allocated_bytes;
    uint32_t number_of_substitutions;

    char *formatted_string;
    uint32_t formatted_string_allocated_bytes;
};

static void output_string_length(struct generator *gen, const char *string,
 size_t len);

static void output_string(struct generator *gen, const char *string)
{
    output_string_length(gen, string, strlen(string));
}

static void output_line(struct generator *gen, const char *string)
{
    output_string(gen, string);
    output_string(gen, "\n");
}

static void output_formatted_source(struct generator *gen, const char *string);

static void set_substitution(struct generator *gen, const char *variable,
 const char *value, size_t value_length, enum substitution_transform transform);
static void set_unsigned_number_substitution(struct generator *gen,
 const char *variable, uint32_t value);
static void set_signed_number_substitution(struct generator *gen,
 const char *variable, int32_t value);
static void set_literal_substitution(struct generator *gen,
 const char *variable, const char *value);

static bool rule_is_named(struct rule *rule, const char *name);
static bool token_is(struct token *token, const char *name);

static void generate_fields_for_token_rule(struct generator *gen,
 struct rule *rule, const char *string);

enum automaton_type { NORMAL_AUTOMATON, BRACKET_AUTOMATON };
static void generate_automaton(struct generator *gen, struct automaton *a,
 uint32_t offset, enum automaton_type type);
static void generate_action_automaton(struct generator *gen,
 struct action_map *map, uint32_t dfa_offset, uint32_t nfa_offset,
 uint32_t bracket_nfa_offset, enum automaton_type type);
static void generate_actions(struct generator *gen, struct action_map *map,
 uint32_t action_index);

static bool should_escape(char c);

void generate(struct generator *gen)
{
    struct generator_internal internal = {0};
    gen->internal = &internal;

    set_substitution(gen, "root-rule",
     gen->grammar->rules[gen->grammar->root_rule].name,
     gen->grammar->rules[gen->grammar->root_rule].name_length,
     LOWERCASE_WITH_UNDERSCORES);
    set_unsigned_number_substitution(gen, "root-rule-index",
     gen->grammar->root_rule);

    output_line(gen, "// -----------------------------------------------------------------------------");
    output_line(gen, "// This file was generated by the bluebird parsing tool.");
    output_line(gen, "// Make sure to #define BLUEBIRD_PARSER_IMPLEMENTATION somewhere so the parser");
    output_line(gen, "// is compiled properly.  Just two lines are enough -- a typical parser.c might");
    output_line(gen, "// look like:");
    output_line(gen, "//");
    output_line(gen, "//   #define BLUEBIRD_PARSER_IMPLEMENTATION");
    output_line(gen, "//   #include \"bluebird-parser.h\"");
    output_line(gen, "");
    output_line(gen, "#ifndef _BLUEBIRD_PARSER_H_");
    output_line(gen, "#define _BLUEBIRD_PARSER_H_");
    output_line(gen, "");
    output_line(gen, "#include \"stdbool.h\"");
    output_line(gen, "#include \"stddef.h\"");
    output_line(gen, "#include \"stdint.h\"");
    output_line(gen, "");
    output_line(gen, "// A parsed_id represents an element in the parse tree.  Use the");
    output_line(gen, "// parsed_..._get() function corresponding to the element type to unpack the");
    output_line(gen, "// element into its appropriate type of parsed_... element struct.");
    output_line(gen, "typedef size_t parsed_id;");
    output_line(gen, "");
    output_line(gen, "// The bluebird_tree struct represents an entire parse tree.  Use the");
    output_line(gen, "// bluebird_tree_create_...() functions to create a tree, then call");
    output_line(gen, "// bluebird_tree_root() to get the root bluebird_id.");
    output_line(gen, "struct bluebird_tree;");
    output_line(gen, "");
    output_line(gen, "// Creates a bluebird_tree from a string.  Remember to call");
    output_line(gen, "// bluebird_tree_destroy() when you're done with it.");
    output_line(gen, "struct bluebird_tree *bluebird_tree_create_from_string(const char *string);");
    output_line(gen, "");
    output_line(gen, "// Destroys a bluebird_tree, freeing its resources back to the system.");
    output_line(gen, "void bluebird_tree_destroy(struct bluebird_tree *);");
    output_line(gen, "");
    output_line(gen, "// Prints a representation of the tree to stdout.");
    output_line(gen, "void bluebird_tree_print(struct bluebird_tree *);");
    output_line(gen, "");
    output_line(gen, "// Returns the root parsed_id.");
    output_line(gen, "parsed_id bluebird_tree_root_id(struct bluebird_tree *tree);");
    output_line(gen, "");
    output_line(gen, "// As a shortcut, returns the parsed_%%root-rule struct corresponding to the root parsed_id.");
    output_line(gen, "struct parsed_%%root-rule bluebird_tree_get_parsed_%%root-rule(struct bluebird_tree *tree);");

    uint32_t n = gen->grammar->number_of_rules;
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(gen, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(gen, "");
        if (rule->number_of_choices > 0) {
            output_line(gen, "enum parsed_%%rule_type {");
            for (uint32_t j = 0; j < rule->number_of_choices; ++j) {
                set_substitution(gen, "choice-name", rule->choices[j].name,
                 rule->choices[j].name_length, UPPERCASE_WITH_UNDERSCORES);
                output_line(gen, "    PARSED_%%choice-name,");
            }
            for (uint32_t j = 0; j < rule->number_of_operators; ++j) {
                set_substitution(gen, "operator-name", rule->operators[j].name,
                 rule->operators[j].name_length, UPPERCASE_WITH_UNDERSCORES);
                output_line(gen, "    PARSED_%%operator-name,");
            }
            output_line(gen, "};");
        }
        output_line(gen, "struct parsed_%%rule {");
        output_line(gen, "    struct bluebird_tree *_tree;");
        output_line(gen, "    parsed_id _next;");
        output_line(gen, "    bool empty;");
        if (rule->number_of_choices > 0)
            output_line(gen, "    enum parsed_%%rule_type type;");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            struct slot slot = rule->slots[j];
            set_substitution(gen, "referenced-slot", slot.name,
             slot.name_length, LOWERCASE_WITH_UNDERSCORES);
            output_line(gen, "    parsed_id %%referenced-slot;");
        }
        if (rule->is_token)
            generate_fields_for_token_rule(gen, rule, "    %%type%%field;\n");
        output_line(gen, "};");
    }
    output_line(gen, "");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(gen, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(gen, "struct parsed_%%rule parsed_%%rule_get(struct bluebird_tree *, parsed_id);");
    }
    output_line(gen, "");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(gen, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(gen, "static inline struct parsed_%%rule parsed_%%rule_next(struct parsed_%%rule parsed)");
        output_line(gen, "{");
        output_line(gen, "    return parsed_%%rule_get(parsed._tree, parsed._next);");
        output_line(gen, "}");
    }
    output_line(gen, "");
    output_line(gen, "#endif");

    output_line(gen, "");
    output_line(gen, "#ifdef BLUEBIRD_PARSER_IMPLEMENTATION");
    output_line(gen, "// Code implementing the parser.  This might get a bit messy!");
    output_line(gen, "#include <assert.h>");
    output_line(gen, "#include <stdio.h>");
    output_line(gen, "#include <stdlib.h>");
    output_line(gen, "#include <string.h>");
    output_line(gen, "");
    output_line(gen, "struct bluebird_tree {");
    output_line(gen, "    const char *string;");
    output_line(gen, "    uint8_t *parse_tree;");
    output_line(gen, "    size_t parse_tree_size;");
    output_line(gen, "    parsed_id next_id;");
    output_line(gen, "    parsed_id root_id;");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        set_substitution(gen, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(gen, "    struct {");
        generate_fields_for_token_rule(gen, rule, "        %%type%%field;\n");
        output_line(gen, "    } *%%rule_tokens;");
        output_line(gen, "    size_t number_of_%%rule_tokens;");
        output_line(gen, "    size_t used_%%rule_tokens;");
        output_line(gen, "    size_t %%rule_tokens_capacity;");
    }
    output_line(gen, "};");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        set_substitution(gen, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_string(gen, "static void add_%%rule_token(struct bluebird_tree *tree");
        generate_fields_for_token_rule(gen, rule, ", %%type%%field_param");
        output_line(gen, ") {");
        output_line(gen, "    size_t index = tree->number_of_%%rule_tokens++;");
        output_line(gen, "    if (tree->number_of_%%rule_tokens > tree->%%rule_tokens_capacity) {");
        output_line(gen, "        size_t capacity = (tree->%%rule_tokens_capacity + 1) * 3 / 2;");
        output_line(gen, "        void *tokens = realloc(tree->%%rule_tokens, sizeof(tree->%%rule_tokens[0]) * capacity);");
        output_line(gen, "        if (!tokens)");
        output_line(gen, "            abort();");
        output_line(gen, "        tree->%%rule_tokens_capacity = capacity;");
        output_line(gen, "        tree->%%rule_tokens = tokens;");
        output_line(gen, "    }");
        generate_fields_for_token_rule(gen, rule, "    tree->%%rule_tokens[index].%%field = %%field_param;\n");
        output_line(gen, "}");
    }

    set_literal_substitution(gen, "token-type", "uint32_t");
    set_literal_substitution(gen, "state-type", "uint32_t");

    // Code for reading and writing packed parse trees.
    // TODO: Delta encoding instead of absolute numbers.
    output_line(gen, "static inline parsed_id read_tree(parsed_id *id, struct bluebird_tree *tree) {");
    output_line(gen, "    uint8_t *parse_tree = tree->parse_tree;");
    output_line(gen, "    size_t parse_tree_size = tree->parse_tree_size;");
    output_line(gen, "    if (*id >= parse_tree_size)");
    output_line(gen, "        return 0;");
    output_line(gen, "    parsed_id result = parse_tree[*id] & 0x7f;");
    output_line(gen, "    (*id)++;");
    output_line(gen, "    int shift_amount = 7;");
    output_line(gen, "    while (*id < parse_tree_size && (parse_tree[*id] & 0x80) != 0) {");
    output_line(gen, "        result |= (parse_tree[*id] & 0x7f) << shift_amount;");
    output_line(gen, "        shift_amount += 7;");
    output_line(gen, "        (*id)++;");
    output_line(gen, "    }");
    output_line(gen, "    return result;");
    output_line(gen, "}");
    output_line(gen, "static bool grow_tree(struct bluebird_tree *tree, size_t size)");
    output_line(gen, "{");
    output_line(gen, "    size_t n = tree->parse_tree_size;");
    output_line(gen, "    while (size > n)");
    output_line(gen, "        n = (n + 1) * 3 / 2;");
    output_line(gen, "    uint8_t *parse_tree = realloc(tree->parse_tree, n);");
    output_line(gen, "    if (!parse_tree)");
    output_line(gen, "        return false;");
    output_line(gen, "    memset(parse_tree + tree->parse_tree_size, 0, n - tree->parse_tree_size);");
    output_line(gen, "    tree->parse_tree_size = n;");
    output_line(gen, "    tree->parse_tree = parse_tree;");
    output_line(gen, "    return true;");
    output_line(gen, "}");
    output_line(gen, "static void write_tree(struct bluebird_tree *tree, parsed_id value)");
    output_line(gen, "{");
    output_line(gen, "    // Reserve 5 bytes (the maximum encoded size of a 32-bit value).");
    output_line(gen, "    size_t reserved_size = tree->next_id + 5;");
    output_line(gen, "    if (tree->parse_tree_size <= reserved_size && !grow_tree(tree, reserved_size))");
    // FIXME: Should we handle this case?
    output_line(gen, "        return;");
    output_line(gen, "    tree->parse_tree[tree->next_id++] = value & 0x7f;");
    output_line(gen, "    value >>= 7;");
    output_line(gen, "    while (value > 0) {");
    output_line(gen, "        tree->parse_tree[tree->next_id++] = 0x80 | (value & 0x7f);");
    output_line(gen, "        value >>= 7;");
    output_line(gen, "    }");
    output_line(gen, "}");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(gen, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(gen, "struct parsed_%%rule parsed_%%rule_get(struct bluebird_tree *tree, parsed_id id) {");
        output_line(gen, "    if (id == 0)");
        output_line(gen, "        return (struct parsed_%%rule){ ._tree = tree, .empty = true };");
        output_line(gen, "    parsed_id next = read_tree(&id, tree);");
        if (rule->is_token)
            output_line(gen, "    size_t token_index = read_tree(&id, tree);");
        output_line(gen, "    return (struct parsed_%%rule){");
        output_line(gen, "        ._tree = tree,");
        output_line(gen, "        ._next = next,");
        if (rule->is_token)
            generate_fields_for_token_rule(gen, rule, "        .%%field = tree->%%rule_tokens[token_index].%%field,\n");
        if (rule->number_of_choices > 0)
            output_line(gen, "        .type = read_tree(&id, tree),");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            struct slot slot = rule->slots[j];
            set_substitution(gen, "referenced-slot", slot.name,
             slot.name_length, LOWERCASE_WITH_UNDERSCORES);
            output_line(gen, "        .%%referenced-slot = read_tree(&id, tree),");
        }
        output_line(gen, "    };");
        output_line(gen, "}");
    }
    output_line(gen, "static parsed_id finish_node(uint32_t rule, uint32_t choice, parsed_id next_sibling, parsed_id *slots, void *info) {");
    output_line(gen, "    struct bluebird_tree *tree = info;");
//    output_line(gen, "    printf(\"finishing node (%lu): %u / %u\\n\", tree->next_id, rule, choice);");
    output_line(gen, "    parsed_id id = tree->next_id;");
    output_line(gen, "    write_tree(tree, next_sibling);");
    output_line(gen, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (rule->is_token)
            continue;
        set_unsigned_number_substitution(gen, "rule-index", i);
        output_line(gen, "    case %%rule-index: {");
//        output_line(gen, "        printf(\"next = %lu\\n\", next_sibling);");
        if (rule->number_of_choices > 0)
            output_line(gen, "        write_tree(tree, choice);");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            set_unsigned_number_substitution(gen, "slot-index", j);
//            output_line(gen, "        printf(\"slot %%slot-index = %lu\\n\", slots[%%slot-index]);");
            output_line(gen, "        write_tree(tree, slots[%%slot-index]);");
        }
        output_line(gen, "        break;");
        output_line(gen, "    }");
    }
    output_line(gen, "    default:");
    output_line(gen, "        break;");
    output_line(gen, "    }");
    output_line(gen, "    return id;");
    output_line(gen, "}");
    output_line(gen, "static parsed_id finish_token(uint32_t rule, parsed_id next_sibling, void *info) {");
    output_line(gen, "    struct bluebird_tree *tree = info;");
//    output_line(gen, "    printf(\"finishing token (%lu): %u\\n\", tree->next_id, rule);");
    output_line(gen, "    parsed_id id = tree->next_id;");
    output_line(gen, "    write_tree(tree, next_sibling);");
    output_line(gen, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        set_unsigned_number_substitution(gen, "rule-index", i);
        set_substitution(gen, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(gen, "    case %%rule-index: {");
        output_line(gen, "        tree->used_%%rule_tokens++;");
        output_line(gen, "        if (tree->used_%%rule_tokens > tree->number_of_%%rule_tokens)");
        output_line(gen, "            abort();");
        output_line(gen, "        size_t token_index = tree->number_of_%%rule_tokens - tree->used_%%rule_tokens;");
        // TODO: Remove this cast.
        output_line(gen, "        write_tree(tree, (parsed_id)token_index);");
        output_line(gen, "        break;");
        output_line(gen, "    }");
    }
    output_line(gen, "    default:");
    output_line(gen, "        break;");
    output_line(gen, "    }");
    output_line(gen, "    return id;");
    output_line(gen, "}");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(gen, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(gen, "static void parsed_%%rule_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);");
    }
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(gen, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(gen, "static void parsed_%%rule_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {");
        output_line(gen, "    struct parsed_%%rule it = parsed_%%rule_get(tree, id);");
        output_line(gen, "    while (!it.empty) {");
        output_line(gen, "        for (int i = 0; i < indent; ++i) printf(\"  \");");
        output_line(gen, "        printf(\"%%rule\");");
        output_line(gen, "        if (strcmp(\"%%rule\", slot_name))");
        output_line(gen, "            printf(\"@%s\", slot_name);");
        if (rule->number_of_choices > 0) {
            output_line(gen, "        switch (it.type) {");
            for (uint32_t j = 0; j < rule->number_of_choices; ++j) {
                set_substitution(gen, "choice-name", rule->choices[j].name,
                 rule->choices[j].name_length, UPPERCASE_WITH_UNDERSCORES);
                output_line(gen, "        case PARSED_%%choice-name:");
                output_line(gen, "            printf(\" : %%choice-name\");");
                output_line(gen, "            break;");
            }
            for (uint32_t j = 0; j < rule->number_of_operators; ++j) {
                set_substitution(gen, "operator-name", rule->operators[j].name,
                 rule->operators[j].name_length, UPPERCASE_WITH_UNDERSCORES);
                output_line(gen, "        case PARSED_%%operator-name:");
                output_line(gen, "            printf(\" : %%operator-name\");");
                output_line(gen, "            break;");
            }
            output_line(gen, "        }");
        }
        if (rule->is_token) {
            if (rule_is_named(rule, "identifier"))
                output_line(gen, "        printf(\" - %.*s\", (int)it.length, it.identifier);");
            else if (rule_is_named(rule, "number"))
                output_line(gen, "        printf(\" - %f\", it.number);");
            else if (rule_is_named(rule, "string"))
                output_line(gen, "        printf(\" - %.*s\", (int)it.length, it.string);");
        }
        output_line(gen, "        printf(\"\\n\");");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            struct slot slot = rule->slots[j];
            set_substitution(gen, "slot-name", slot.name, slot.name_length,
             LOWERCASE_WITH_UNDERSCORES);
            struct rule *slot_rule = &gen->grammar->rules[slot.rule_index];
            set_substitution(gen, "slot-rule", slot_rule->name,
             slot_rule->name_length, LOWERCASE_WITH_UNDERSCORES);
            output_line(gen, "        parsed_%%slot-rule_print(tree, it.%%slot-name, \"%%slot-name\", indent + 1);");
        }
        output_line(gen, "        it = parsed_%%rule_next(it);");
        output_line(gen, "    }");
        output_line(gen, "}");
    }
    output_line(gen, "void bluebird_tree_print(struct bluebird_tree *tree) {");
    output_line(gen, "    parsed_%%root-rule_print(tree, tree->root_id, \"%%root-rule\", 0);");
    output_line(gen, "}");

    output_line(gen, "parsed_id bluebird_tree_root_id(struct bluebird_tree *tree) {");
    output_line(gen, "    return tree->root_id;");
    output_line(gen, "}");

    set_unsigned_number_substitution(gen, "identifier-token", 0xffffffff);
    set_unsigned_number_substitution(gen, "number-token", 0xffffffff);
    set_unsigned_number_substitution(gen, "string-token", 0xffffffff);
    set_unsigned_number_substitution(gen, "bracket-transition-token", 0xffffffff);
    output_line(gen, "#define IGNORE_TOKEN_WRITE(...)");
    set_literal_substitution(gen, "write-identifier-token", "IGNORE_TOKEN_WRITE");
    set_literal_substitution(gen, "write-number-token", "IGNORE_TOKEN_WRITE");
    set_literal_substitution(gen, "write-string-token", "IGNORE_TOKEN_WRITE");
    for (uint32_t i = gen->combined->number_of_keyword_tokens;
     i < gen->combined->number_of_tokens; ++i) {
        if (token_is(&gen->combined->tokens[i], "identifier"))
            set_unsigned_number_substitution(gen, "identifier-token", i);
        else if (token_is(&gen->combined->tokens[i], "number"))
            set_unsigned_number_substitution(gen, "number-token", i);
        else if (token_is(&gen->combined->tokens[i], "string"))
            set_unsigned_number_substitution(gen, "string-token", i);
    }
    output_line(gen, "static size_t read_keyword_token(%%token-type *token, bool *end_token, const char *text, void *info);");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        if (rule_is_named(rule, "identifier")) {
            output_line(gen, "static void write_identifier_token(size_t offset, size_t length, void *info) {");
            output_line(gen, "    struct bluebird_tree *tree = info;");
            output_line(gen, "    add_identifier_token(tree, tree->string + offset, length);");
            output_line(gen, "}");
            set_literal_substitution(gen, "write-identifier-token", "write_identifier_token");
        } else if (rule_is_named(rule, "number")) {
            output_line(gen, "static void write_number_token(size_t offset, size_t length, double number, void *info) {");
            output_line(gen, "    struct bluebird_tree *tree = info;");
            output_line(gen, "    add_number_token(tree, number);");
            output_line(gen, "}");
            set_literal_substitution(gen, "write-number-token", "write_number_token");
        } else if (rule_is_named(rule, "string")) {
            output_line(gen, "static void write_string_token(size_t offset, size_t length, size_t content_offset, size_t content_length, void *info) {");
            output_line(gen, "    struct bluebird_tree *tree = info;");
            output_line(gen, "    add_string_token(tree, tree->string + offset, length);");
            output_line(gen, "}");
            set_literal_substitution(gen, "write-string-token", "write_string_token");
        }
    }
#define EVALUATE_MACROS_AND_STRINGIFY(...) #__VA_ARGS__

#define TOKEN_T %%token-type
#define STATE_T %%state-type
#define READ_KEYWORD_TOKEN read_keyword_token
#define WRITE_NUMBER_TOKEN %%write-number-token
#define WRITE_IDENTIFIER_TOKEN %%write-identifier-token
#define WRITE_STRING_TOKEN %%write-string-token
#define ALLOW_DASHES_IN_IDENTIFIERS(...) %%allow-dashes-in-identifiers
#define IDENTIFIER_TOKEN %%identifier-token
#define NUMBER_TOKEN %%number-token
#define STRING_TOKEN %%string-token
#define BRACKET_TRANSITION_TOKEN %%bracket-transition-token

    const char *tokenizer_source;
#define TOKENIZE_BODY(...) tokenizer_source = EVALUATE_MACROS_AND_STRINGIFY(__VA_ARGS__);
#include "x-tokenize.h"
    if (SHOULD_ALLOW_DASHES_IN_IDENTIFIERS(gen->combined))
        set_literal_substitution(gen, "allow-dashes-in-identifiers", "true");
    else
        set_literal_substitution(gen, "allow-dashes-in-identifiers", "false");
    output_formatted_source(gen, tokenizer_source);
    output_line(gen, "static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context);");
    output_line(gen, "static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context);");
    output_line(gen, "static size_t number_of_slots_lookup(uint32_t rule, void *context);");
    output_line(gen, "static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context);");

#define FINISHED_NODE_T parsed_id
#define FINISH_NODE finish_node
#define FINISH_TOKEN finish_token

#define RULE_T uint32_t
#define RULE_LOOKUP rule_lookup
#define ROOT_RULE(...) %%root-rule-index
#define FIXITY_ASSOCIATIVITY_PRECEDENCE_LOOKUP(fixity_associativity, precedence, rule, choice, context) \
 do { \
     int local; \
     fixity_associativity_precedence_lookup(&local, &precedence, rule, choice, context); \
     fixity_associativity = local; \
 } while (0)
#define NUMBER_OF_SLOTS_LOOKUP number_of_slots_lookup
#define LEFT_RIGHT_OPERAND_SLOTS_LOOKUP(rule, left, right, operand, info) \
 (left_right_operand_slots_lookup(rule, &(left), &(right), &(operand), info))

    const char *construct_source;
#define CONSTRUCT_BODY(...) construct_source = EVALUATE_MACROS_AND_STRINGIFY(__VA_ARGS__);
#include "x-construct-parse-tree.h"
    output_formatted_source(gen, construct_source);

    set_unsigned_number_substitution(gen, "start-state",
     gen->deterministic->automaton.start_state);
    output_line(gen, "");
    output_line(gen, "struct state_stack {");
    output_line(gen, "    %%state-type *states;");
    output_line(gen, "    size_t capacity;");
    output_line(gen, "    size_t depth;");
    output_line(gen, "};");
    output_line(gen, "struct fill_run_continuation {");
    output_line(gen, "    %%state-type state;");
    output_line(gen, "    struct state_stack stack;");
    output_line(gen, "};");
    output_line(gen, "static void fill_run_states(struct bluebird_token_run *, struct fill_run_continuation *);");
    output_line(gen, "static parsed_id build_parse_tree(struct bluebird_token_run *, struct bluebird_tree *);");
    output_line(gen, "");
    output_line(gen, "struct bluebird_tree *bluebird_tree_create_from_string(const char *string) {");
    output_line(gen, "    struct bluebird_tree *tree = calloc(1, sizeof(struct bluebird_tree));");
    output_line(gen, "    tree->string = string;");
    output_line(gen, "    tree->next_id = 1;");
    output_line(gen, "    struct bluebird_default_tokenizer tokenizer = {");
    output_line(gen, "        .text = string,");
    output_line(gen, "        .info = tree,");
    output_line(gen, "    };");
    output_line(gen, "    struct bluebird_token_run *token_run = 0;");
    output_line(gen, "    struct fill_run_continuation c = {");
    output_line(gen, "        .state = %%start-state,");
    output_line(gen, "    };");
    output_line(gen, "    while (bluebird_default_tokenizer_advance(&tokenizer, &token_run))");
    output_line(gen, "        fill_run_states(token_run, &c);");
    output_line(gen, "    if (string[tokenizer.offset] != '\\0') {");
    output_line(gen, "        // TODO: Return error instead of printing it");
    output_line(gen, "        fprintf(stderr, \"error: tokenizing failed. next char was %u\\n\", string[tokenizer.offset]);");
    output_line(gen, "        abort();");
    output_line(gen, "    }");
    output_line(gen, "    if (c.stack.depth > 0) {");
    output_line(gen, "        // TODO: Return error instead of printing it");
    output_line(gen, "        fprintf(stderr, \"error: parsing failed because the stack was still full\\n\");");
    output_line(gen, "    }");
    output_line(gen, "    free(c.stack.states);");
    /*
    output_line(gen, "    struct bluebird_token_run *run_to_print = token_run;");
    output_line(gen, "    while (run_to_print) {");
    output_line(gen, "        for (uint32_t i = 0; i < run_to_print->number_of_tokens; ++i) {");
    output_line(gen, "            printf(\"%u -> %u\\n\", run_to_print->tokens[i], run_to_print->states[i]);");
    output_line(gen, "        }");
    output_line(gen, "        printf(\"--\\n\");");
    output_line(gen, "        run_to_print = run_to_print->prev;");
    output_line(gen, "    }");
     */
    output_line(gen, "    tree->root_id = build_parse_tree(token_run, tree);");
    output_line(gen, "    return tree;");
    output_line(gen, "}");
    output_line(gen, "void bluebird_tree_destroy(struct bluebird_tree *tree) {");
    output_line(gen, "    free(tree);");
    output_line(gen, "}");
    output_line(gen, "static bool grow_state_stack(struct state_stack *stack) {");
    output_line(gen, "    size_t new_capacity = (stack->capacity + 2) * 3 / 2;");
    output_line(gen, "    if (new_capacity <= stack->capacity)");
    output_line(gen, "        return false;");
    output_line(gen, "    %%state-type *new_states = realloc(stack->states, new_capacity * sizeof(%%state-type));");
    output_line(gen, "    if (!new_states)");
    output_line(gen, "        return false;");
    output_line(gen, "    stack->states = new_states;");
    output_line(gen, "    stack->capacity = new_capacity;");
    output_line(gen, "    return true;");
    output_line(gen, "}");
    struct automaton *a = &gen->deterministic->automaton;
    struct automaton *b = &gen->deterministic->bracket_automaton;
    set_unsigned_number_substitution(gen, "first-bracket-state-id",
     a->number_of_states);
    output_line(gen, "static void fill_run_states(struct bluebird_token_run *run, struct fill_run_continuation *cont) {");
    output_line(gen, "    uint16_t token_index = 0;");
    output_line(gen, "    uint16_t number_of_tokens = run->number_of_tokens;");
    output_line(gen, "    uint16_t start_state = cont->state;");
    output_line(gen, "start:");
    output_line(gen, "    switch (start_state) {");
    generate_automaton(gen, a, 0, NORMAL_AUTOMATON);
    generate_automaton(gen, b, a->number_of_states, BRACKET_AUTOMATON);
    output_line(gen, "    }");
    output_line(gen, "}");
    set_unsigned_number_substitution(gen, "final-nfa-state",
     gen->combined->final_nfa_state);
    output_line(gen, "static parsed_id build_parse_tree(struct bluebird_token_run *run, struct bluebird_tree *tree) {");
    output_line(gen, "    struct construct_state construct_state = { .info = tree };");
    output_line(gen, "    struct state_stack stack = { 0 };");
    if (gen->combined->root_rule_is_expression)
        output_line(gen, "    construct_begin(&construct_state, CONSTRUCT_EXPRESSION_ROOT);");
    else
        output_line(gen, "    construct_begin(&construct_state, CONSTRUCT_NORMAL_ROOT);");
    output_line(gen, "    uint16_t token_index = run->number_of_tokens;");
    output_line(gen, "    %%state-type start_state = %%final-nfa-state;");
    output_line(gen, "start:");
    output_line(gen, "    switch (start_state) {");
    uint32_t nfa_offset = gen->combined->automaton.number_of_states;
    generate_action_automaton(gen, &gen->deterministic->action_map, 0, 0,
     nfa_offset, NORMAL_AUTOMATON);
    generate_action_automaton(gen, &gen->deterministic->bracket_action_map,
     a->number_of_states, nfa_offset, gen->combined->automaton.number_of_states,
     BRACKET_AUTOMATON);
    output_line(gen, "    }");
    // TODO: Free all remaining token runs here.
    output_line(gen, "    printf(\"error!\\n\");");
    output_line(gen, "finish:");
    output_line(gen, "    free(stack.states);");
    output_line(gen, "    return construct_finish(&construct_state);");
    output_line(gen, "}");
    output_line(gen, "static size_t read_keyword_token(%%token-type *token, bool *end_token, const char *text, void *info) {");
    for (uint32_t i = 0; i < gen->combined->number_of_keyword_tokens; ++i) {
        struct token keyword = gen->combined->tokens[i];
        set_unsigned_number_substitution(gen, "token-index", keyword.symbol);
        if (keyword.length > UINT32_MAX) {
            // Why even store the length as a size_t if we're just gonna do
            // this?
            abort();
        }
        set_unsigned_number_substitution(gen, "token-length",
         (uint32_t)keyword.length);
        if (keyword.type == TOKEN_END)
            set_literal_substitution(gen, "is-end-token", "true");
        else
            set_literal_substitution(gen, "is-end-token", "false");
        // TODO: Use a trie or something slightly less N^2.
        // TODO: This is incorrect; it doesn't handle tokens that are prefixes
        // of each other if they happen to appear in the wrong order.
        output_string(gen, "    if (strncmp(text, \"");
        for (size_t j = 0; j < keyword.length; ++j) {
            if (!should_escape(keyword.string[j])) {
                gen->output(gen, &keyword.string[j], 1);
                continue;
            }
            char string[8];
            snprintf(string, sizeof(string), "\\x%02x", keyword.string[j]);
            gen->output(gen, string, strlen(string));
        }
        output_line(gen, "\", %%token-length) == 0) {");
        output_line(gen, "        *token = %%token-index;");
        output_line(gen, "        *end_token = %%is-end-token;");
        output_line(gen, "        return %%token-length;");
        output_line(gen, "    }");
    }
    output_line(gen, "    return 0;");
    output_line(gen, "}");
    output_line(gen, "static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context) {");
    output_line(gen, "    switch (parent) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (rule->number_of_slots == 0)
            continue;
        set_unsigned_number_substitution(gen, "rule-index", i);
        output_line(gen, "    case %%rule-index:");
        output_line(gen, "        switch (slot) {");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            set_unsigned_number_substitution(gen, "slot-index", j);
            set_unsigned_number_substitution(gen, "slot-rule-index",
             rule->slots[j].rule_index);
            output_line(gen, "        case %%slot-index: return %%slot-rule-index;");
        }
        output_line(gen, "        default: break;");
        output_line(gen, "        }");
        output_line(gen, "        break;");
    }
    output_line(gen, "    default: break;");
    output_line(gen, "    }");
    output_line(gen, "    return UINT32_MAX;");
    output_line(gen, "}");
    output_line(gen, "static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context) {");
    output_line(gen, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (rule->number_of_operators == 0)
            continue;
        set_unsigned_number_substitution(gen, "rule-index", i);
        output_line(gen, "    case %%rule-index:");
        output_line(gen, "        switch (choice) {");
        for (uint32_t j = 0; j < rule->number_of_operators; ++j) {
            struct operator op = rule->operators[j];
            set_unsigned_number_substitution(gen, "choice-index",
             j + rule->number_of_choices);
            set_signed_number_substitution(gen, "operator-precedence",
             op.precedence);
            output_line(gen, "        case %%choice-index:");
            output_line(gen, "            *precedence = %%operator-precedence;");
            if (op.fixity == PREFIX)
                output_line(gen, "            *fixity_associativity = CONSTRUCT_PREFIX;");
            else if (op.fixity == POSTFIX)
                output_line(gen, "            *fixity_associativity = CONSTRUCT_POSTFIX;");
            else if (op.associativity == RIGHT)
                output_line(gen, "            *fixity_associativity = CONSTRUCT_INFIX_RIGHT;");
            else if (op.associativity == FLAT)
                output_line(gen, "            *fixity_associativity = CONSTRUCT_INFIX_FLAT;");
            else
                output_line(gen, "            *fixity_associativity = CONSTRUCT_INFIX_LEFT;");
            output_line(gen, "            return;");
        }
        output_line(gen, "        default: return;");
        output_line(gen, "        }");
    }
    output_line(gen, "    default: return;");
    output_line(gen, "    }");
    output_line(gen, "}");
    output_line(gen, "static size_t number_of_slots_lookup(uint32_t rule, void *context) {");
    output_line(gen, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        set_unsigned_number_substitution(gen, "rule-index", i);
        set_unsigned_number_substitution(gen, "number-of-slots",
         gen->grammar->rules[i].number_of_slots);
        output_line(gen, "    case %%rule-index: return %%number-of-slots;");
    }
    output_line(gen, "    default: return 0;");
    output_line(gen, "    }");
    output_line(gen, "}");
    output_line(gen, "static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context) {");
    output_line(gen, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_unsigned_number_substitution(gen, "rule-index", i);
        set_unsigned_number_substitution(gen, "left-slot",
         rule->left_slot_index);
        set_unsigned_number_substitution(gen, "right-slot",
         rule->right_slot_index);
        set_unsigned_number_substitution(gen, "operand-slot",
         rule->operand_slot_index);
        output_line(gen, "    case %%rule-index:");
        output_line(gen, "        *left = %%left-slot;");
        output_line(gen, "        *right = %%right-slot;");
        output_line(gen, "        *operand = %%operand-slot;");
        output_line(gen, "        break;");
    }
    output_line(gen, "    }");
    output_line(gen, "}");
    output_line(gen, "#endif");
    output_line(gen, "");

    free(internal.substitutions);
    gen->internal = 0;
}

static void generate_fields_for_token_rule(struct generator *gen,
 struct rule *rule, const char *string)
{
    if (rule_is_named(rule, "identifier")) {
        set_literal_substitution(gen, "type", "const char *");
        set_literal_substitution(gen, "field", "identifier");
        output_string(gen, string);
        set_literal_substitution(gen, "type", "size_t ");
        set_literal_substitution(gen, "field", "length");
        output_string(gen, string);
    } else if (rule_is_named(rule, "number")) {
        set_literal_substitution(gen, "type", "double ");
        set_literal_substitution(gen, "field", "number");
        output_string(gen, string);
    } else if (rule_is_named(rule, "string")) {
        set_literal_substitution(gen, "type", "const char *");
        set_literal_substitution(gen, "field", "string");
        output_string(gen, string);
        set_literal_substitution(gen, "type", "size_t ");
        set_literal_substitution(gen, "field", "length");
        output_string(gen, string);
    } else
        abort();
}

static void generate_automaton(struct generator *gen, struct automaton *a,
 uint32_t offset, enum automaton_type type)
{
    for (uint32_t i = 0; i < a->number_of_states; ++i) {
        struct state s = a->states[i];
        set_unsigned_number_substitution(gen, "state-id", i + offset);
        output_line(gen, "    case %%state-id:");
        output_line(gen, "state_%%state-id: {");
        if (s.accepting && type == BRACKET_AUTOMATON) {
            set_unsigned_number_substitution(gen, "state-transition-symbol",
             s.transition_symbol);
            output_line(gen, "        start_state = cont->stack.states[--cont->stack.depth];");
            output_line(gen, "        run->tokens[token_index] = %%state-transition-symbol;");
            output_line(gen, "        goto start;");
            output_line(gen, "    }");
            continue;
        }
        output_line(gen, "        if (token_index >= number_of_tokens) {");
        output_line(gen, "            cont->state = %%state-id;");
        output_line(gen, "            return;");
        output_line(gen, "        }");
        output_line(gen, "        %%token-type token = run->tokens[token_index];");
        output_line(gen, "        run->states[token_index] = %%state-id;");
        output_line(gen, "        token_index++;");
        output_line(gen, "        switch (token) {");
        bool has_bracket_symbols = false;
        for (uint32_t j = 0; j < s.number_of_transitions; ++j) {
            struct transition t = s.transitions[j];
            if (t.symbol >= gen->combined->number_of_tokens) {
                // Symbols are either tokens or bracket symbols, so this must
                // be a bracket symbol.
                has_bracket_symbols = true;
            }
            set_unsigned_number_substitution(gen, "token-symbol", t.symbol);
            set_unsigned_number_substitution(gen, "token-target", t.target + offset);
            output_line(gen, "        case %%token-symbol: goto state_%%token-target;");
        }
        output_string(gen, "        default:");
        if (has_bracket_symbols) {
            output_line(gen, "");
            output_line(gen, "            if (cont->stack.depth >= cont->stack.capacity) {");
            output_line(gen, "                if (!grow_state_stack(&cont->stack))");
            output_line(gen, "                    break;"); // TODO: Error handling.
            output_line(gen, "            }");
            output_line(gen, "            cont->stack.states[cont->stack.depth++] = %%state-id;");
            output_line(gen, "            token_index--;");
            output_line(gen, "            goto state_%%first-bracket-state-id;");
        } else
            output_line(gen, " break;"); // TODO: Error handling.
        output_line(gen, "        }");
        output_line(gen, "        break;");
        output_line(gen, "    }");
    }
}

static void generate_action_automaton(struct generator *gen,
 struct action_map *map, uint32_t dfa_offset, uint32_t nfa_offset,
 uint32_t bracket_nfa_offset, enum automaton_type type)
{
    for (uint32_t i = 0; i < map->number_of_entries; ++i) {
        struct action_map_entry entry = map->entries[i];
        struct action_map_entry *last_entry = 0;
        if (i > 0)
            last_entry = &map->entries[i - 1];
        if (!last_entry || last_entry->target_nfa_state != entry.target_nfa_state) {
            set_unsigned_number_substitution(gen, "entry-target",
             entry.target_nfa_state + nfa_offset);
            output_line(gen, "    case %%entry-target:");
            output_line(gen, "nfa_state_%%entry-target:");
            output_line(gen, "        if (token_index == 0) {");
            output_line(gen, "            struct bluebird_token_run *last_run = run;");
            output_line(gen, "            run = run->prev;");
            output_line(gen, "            free(last_run);");
            output_line(gen, "            if (!run) {");
            struct action_map_entry *final_entry = action_map_find(map, entry.target_nfa_state, UINT32_MAX, UINT32_MAX);
            if (!final_entry) {
                output_line(gen, "                break;");
            } else {
                generate_actions(gen, map, final_entry->action_index);
                output_line(gen, "                goto finish;");
            }
            output_line(gen, "            }");
            output_line(gen, "            token_index = run->number_of_tokens;");
            output_line(gen, "        }");
            output_line(gen, "        token_index--;");
            output_line(gen, "        switch (run->states[token_index]) {");
        }
        struct action_map_entry *next_entry = 0;
        if (i + 1 < map->number_of_entries)
            next_entry = &map->entries[i + 1];
        if (entry.dfa_state != UINT32_MAX) {
            if (!last_entry || last_entry->dfa_state != entry.dfa_state || last_entry->target_nfa_state != entry.target_nfa_state) {
                set_unsigned_number_substitution(gen, "entry-state-id",
                 entry.dfa_state + dfa_offset);
                output_line(gen, "        case %%entry-state-id:");
                output_line(gen, "            switch (run->tokens[token_index]) {");
            }
            set_unsigned_number_substitution(gen, "entry-symbol",
             entry.dfa_symbol);
            output_line(gen, "            case %%entry-symbol:");
            generate_actions(gen, map, entry.action_index);
            set_unsigned_number_substitution(gen, "entry-nfa-state",
             entry.nfa_state + nfa_offset);
            if (type == BRACKET_AUTOMATON && entry.dfa_state ==
             gen->deterministic->bracket_automaton.start_state) {
                output_line(gen, "                start_state = stack.states[--stack.depth];");
                output_line(gen, "                goto start;");
            } else if (entry.dfa_symbol >= gen->combined->number_of_tokens) {
                output_line(gen, "                if (stack.depth >= stack.capacity) {");
                output_line(gen, "                    if (!grow_state_stack(&stack))");
                output_line(gen, "                        break;"); // TODO: Error handling.
                output_line(gen, "                }");
                output_line(gen, "                stack.states[stack.depth++] = %%entry-nfa-state;");
                struct automaton *b = &gen->combined->bracket_automaton;
                for (state_id j = 0; j < b->number_of_states; ++j) {
                    if (!b->states[j].accepting)
                        continue;
                    if (b->states[j].transition_symbol != entry.nfa_symbol)
                        continue;
                    set_unsigned_number_substitution(gen, "bracket-nfa-state",
                     j + bracket_nfa_offset);
                    output_line(gen, "                goto nfa_state_%%bracket-nfa-state;");
                    break;
                }
            } else
                output_line(gen, "                goto nfa_state_%%entry-nfa-state;");
            if (!next_entry || next_entry->dfa_state != entry.dfa_state || next_entry->target_nfa_state != entry.target_nfa_state) {
                output_line(gen, "            default: break;");
                output_line(gen, "            }");
                output_line(gen, "            break;");
            }
        }
        if (!next_entry || next_entry->target_nfa_state != entry.target_nfa_state) {
            output_line(gen, "        default: break;");
            output_line(gen, "        }");
            output_line(gen, "        break;");
        }
    }
}

#define CONSTRUCT_ACTION_NAME(name) PRINT_CONSTRUCT_ACTION_ ## name,
enum { CONSTRUCT_ACTIONS };
#undef CONSTRUCT_ACTION_NAME
#define CONSTRUCT_ACTION_NAME(name) case PRINT_CONSTRUCT_ACTION_ ## name : \
 output_line(gen, "printf(\"" #name " %%action-slot\\n\");"); break;
#define FORMAT_ACTION(action) do {\
    switch (CONSTRUCT_ACTION_GET_TYPE(action)) { \
    CONSTRUCT_ACTIONS \
    } \
} while (0)
static void generate_actions(struct generator *gen, struct action_map *map,
 uint32_t action_index)
{
    for (uint32_t i = action_index; i < map->number_of_actions; ++i) {
        if (map->actions[i] == 0)
            break;
        set_unsigned_number_substitution(gen, "action-id", map->actions[i]);
        set_unsigned_number_substitution(gen, "action-slot", CONSTRUCT_ACTION_GET_SLOT(map->actions[i]));
//        FORMAT_ACTION(map->actions[i]);
        output_line(gen, "            construct_action_apply(&construct_state, %%action-id);");
    }
}
#undef CONSTRUCT_ACTION_NAME

static void output_formatted_source(struct generator *gen, const char *string)
{
    // This implements a very simple C source formatter.
    size_t next_output_index = 0;
    char quoted_string_char = 0;
    int indent = 0;
    size_t i = 0;
    for (; string[i]; ++i) {
        bool line_break_after = false;
        if (quoted_string_char) {
            if (string[i] == '\\') {
                i++;
                if (string[i] == '\0')
                    break;
            } else if (string[i] == quoted_string_char)
                quoted_string_char = 0;
            continue;
        }
        if (string[i] == ';' || string[i] == '{')
            line_break_after = true;
        else if (string[i] == '"' || string[i] == '\'')
            quoted_string_char = string[i];
        else if (string[i] == '}') {
            indent--;
            if (string[i + 1] != ';')
                line_break_after = true;
        } else if (string[i] == ':') {
            line_break_after = true;
            indent--;
        }
        if (line_break_after) {
            for (int j = 0; j < indent; ++j)
                output_string(gen, "    ");
            output_string_length(gen, string + next_output_index,
             i + 1 - next_output_index);
            output_string(gen, "\n");
            if (string[i + 1] == ' ')
                next_output_index = i + 2;
            else
                next_output_index = i + 1;
        }
        if (string[i] == '{' || string[i] == ':')
            indent++;
    }
    output_string_length(gen, string + next_output_index,
     i - next_output_index);
}

static struct substitution *find_substitution(struct generator *gen,
 const char *variable)
{
    uint32_t n = gen->internal->number_of_substitutions;
    size_t longest_match = 0;
    struct substitution *longest_match_substitution = 0;
    for (uint32_t i = 0; i < n; ++i) {
        struct substitution *s = &gen->internal->substitutions[i];
        for (size_t j = 0; ; ++j) {
            if (s->variable[j] == 0 && j > longest_match) {
                longest_match = j;
                longest_match_substitution = s;
            }
            if (s->variable[j] != variable[j])
                break;
        }
    }
    return longest_match_substitution;
}

static void apply_transform(char *string, size_t length,
 enum substitution_transform transform)
{
    if (transform == NO_TRANSFORM)
        return;
    for (size_t i = 0; i < length; ++i) {
        if (transform == UPPERCASE_WITH_UNDERSCORES && string[i] >= 'a'
         && string[i] <= 'z')
            string[i] = string[i] - 'a' + 'A';
        if (string[i] == '-')
            string[i] = '_';
    }
}

static void output_string_length(struct generator *gen, const char *string,
 size_t len)
{
    if (len == 0)
        return;
    size_t next_output_index = 0;
    char *format = gen->internal->formatted_string;
    uint32_t format_bytes = gen->internal->formatted_string_allocated_bytes;
    for (size_t i = 0; i < len - 1; ++i) {
        if (string[i] == '%' && string[i + 1] == '%') {
            struct substitution *sub = find_substitution(gen, string + i + 2);
            if (!sub)
                abort();
            gen->output(gen, string + next_output_index, i - next_output_index);
            switch (sub->type) {
            case UNSIGNED_NUMBER: {
                int len = snprintf(0, 0, "%uU", sub->unsigned_number);
                format = grow_array(format, &format_bytes, (uint32_t)len + 1);
                snprintf(format, len + 1, "%uU", sub->unsigned_number);
                gen->output(gen, format, len);
                break;
            }
            case SIGNED_NUMBER: {
                int len = snprintf(0, 0, "%d", sub->signed_number);
                format = grow_array(format, &format_bytes, (uint32_t)len + 1);
                snprintf(format, len + 1, "%d", sub->signed_number);
                gen->output(gen, format, len);
                break;
            }
            case STRING:
                if (sub->value_length > UINT32_MAX)
                    abort();
                format = grow_array(format, &format_bytes,
                 (uint32_t)sub->value_length);
                memcpy(format, sub->value, sub->value_length);
                apply_transform(format, sub->value_length, sub->transform);
                gen->output(gen, format, sub->value_length);
                break;
            }
            next_output_index = i + 2 + strlen(sub->variable);
        }
    }
    gen->internal->formatted_string = format;
    gen->internal->formatted_string_allocated_bytes = format_bytes;
    if (next_output_index < len)
        gen->output(gen, string + next_output_index, len - next_output_index);
}

static uint32_t create_substitution(struct generator *gen, const char *variable)
{
    uint32_t index = 0;
    for (; index < gen->internal->number_of_substitutions; ++index) {
        if (strcmp(variable, gen->internal->substitutions[index].variable) == 0)
            break;
    }
    if (index >= gen->internal->number_of_substitutions) {
        gen->internal->number_of_substitutions = index + 1;
        gen->internal->substitutions = grow_array(gen->internal->substitutions,
         &gen->internal->substitutions_allocated_bytes,
         gen->internal->number_of_substitutions * sizeof(struct substitution));
        gen->internal->substitutions[index].variable = variable;
    }
    return index;
}

static void set_substitution(struct generator *gen, const char *variable,
 const char *value, size_t value_length, enum substitution_transform transform)
{
    uint32_t index = create_substitution(gen, variable);
    gen->internal->substitutions[index].type = STRING;
    gen->internal->substitutions[index].value = value;
    gen->internal->substitutions[index].value_length = value_length;
    gen->internal->substitutions[index].transform = transform;
}

static void set_unsigned_number_substitution(struct generator *gen,
 const char *variable, uint32_t value)
{
    uint32_t index = create_substitution(gen, variable);
    gen->internal->substitutions[index].type = UNSIGNED_NUMBER;
    gen->internal->substitutions[index].unsigned_number = value;
}

static void set_signed_number_substitution(struct generator *gen,
 const char *variable, int32_t value)
{
    uint32_t index = create_substitution(gen, variable);
    gen->internal->substitutions[index].type = SIGNED_NUMBER;
    gen->internal->substitutions[index].signed_number = value;
}

static void set_literal_substitution(struct generator *gen,
 const char *variable, const char *value)
{
    set_substitution(gen, variable, value, strlen(value), NO_TRANSFORM);
}

static bool rule_is_named(struct rule *rule, const char *name)
{
    return rule->name_length == strlen(name) &&
     !memcmp(name, rule->name, rule->name_length);
}

static bool token_is(struct token *token, const char *name)
{
    return token->length == strlen(name) &&
     !memcmp(name, token->string, token->length);
}

static bool should_escape(char c)
{
    if (c >= 'a' && c <= 'z')
        return false;
    if (c >= 'A' && c <= 'Z')
        return false;
    if (c >= '0' && c <= '9')
        return false;
    const char *symbols = "!#%&'()*+,-./:;<=>?[]^_{|}~";
    for (size_t i = 0; symbols[i]; ++i) {
        if (c == symbols[i])
            return false;
    }
    return true;
}
