// This stuff has to appear before any other #includes to avoid unwanted macro
// expansion from standard headers (e.g., memset -> __builtin___memset_chk).
#define EVALUATE_MACROS_AND_STRINGIFY(...) #__VA_ARGS__
#define TOKEN_T %%token-type
#define STATE_T %%state-type
#define READ_KEYWORD_TOKEN read_keyword_token
#define WRITE_NUMBER_TOKEN %%write-number-token
#define WRITE_IDENTIFIER_TOKEN %%write-identifier-token
#define WRITE_STRING_TOKEN %%write-string-token
#define ALLOW_DASHES_IN_IDENTIFIERS(...) %%allow-dashes-in-identifiers
#define IDENTIFIER_TOKEN %%identifier-token
#define NUMBER_TOKEN %%number-token
#define STRING_TOKEN %%string-token
#define BRACKET_TRANSITION_TOKEN %%bracket-transition-token
#define TOKENIZE_BODY(...) static const char *tokenizer_source = EVALUATE_MACROS_AND_STRINGIFY(__VA_ARGS__);
#include "x-tokenize.h"
#define FINISHED_NODE_T parsed_id
#define FINISH_NODE finish_node
#define FINISH_TOKEN finish_token
#define RULE_T uint32_t
#define RULE_LOOKUP rule_lookup
#define ROOT_RULE(...) %%root-rule-index
#define FIXITY_ASSOCIATIVITY_PRECEDENCE_LOOKUP(fixity_associativity, precedence, rule, choice, context) \
 do { \
     int local; \
     fixity_associativity_precedence_lookup(&local, &precedence, rule, choice, context); \
     fixity_associativity = local; \
 } while (0)
#define NUMBER_OF_SLOTS_LOOKUP number_of_slots_lookup
#define LEFT_RIGHT_OPERAND_SLOTS_LOOKUP(rule, left, right, operand, info) \
 (left_right_operand_slots_lookup(rule, &(left), &(right), &(operand), info))
#define CONSTRUCT_BODY(...) static const char *construct_source = EVALUATE_MACROS_AND_STRINGIFY(__VA_ARGS__);
#include "x-construct-parse-tree.h"

// Now we can start the #includes as usual.
#include "6a-generate.h"

#include "6a-generate-output.h"
#include "grow-array.h"
#include "x-construct-actions.h"
#include <stdio.h>
#include <string.h>

static bool rule_is_named(struct rule *rule, const char *name);
static bool token_is(struct token *token, const char *name);

static void generate_fields_for_token_rule(struct generator_output *out,
 struct rule *rule, const char *string);
static void generate_keyword_reader(struct generator *gen,
 struct generator_output *out);

enum automaton_type { NORMAL_AUTOMATON, BRACKET_AUTOMATON };
static void generate_automaton(struct generator *gen,
 struct generator_output *out, struct automaton *a, uint32_t offset,
 enum automaton_type type);

static void generate_action_table(struct generator *gen,
 struct generator_output *out);

static void output_indentation(struct generator_output *out,
 size_t indentation);

static int compare_tokens(const void *a, const void *b);

static int compare_choice_names(const void *aa, const void *bb)
{
    struct choice *a = *(struct choice * const*)aa;
    struct choice *b = *(struct choice * const*)bb;
    if (a->name_length < b->name_length)
        return -1;
    if (a->name_length > b->name_length)
        return 1;
    return memcmp(a->name, b->name, a->name_length);
}

void generate(struct generator *gen)
{
    struct generator_output *out = output_create(gen->output);

    set_substitution(out, "root-rule",
     gen->grammar->rules[gen->grammar->root_rule].name,
     gen->grammar->rules[gen->grammar->root_rule].name_length,
     LOWERCASE_WITH_UNDERSCORES);
    set_unsigned_number_substitution(out, "root-rule-index",
     gen->grammar->root_rule);

    output_line(out, "// -----------------------------------------------------------------------------");
    output_line(out, "// This file was generated by the bluebird parsing tool.");
    output_line(out, "// Make sure to #define BLUEBIRD_PARSER_IMPLEMENTATION somewhere so the parser");
    output_line(out, "// is compiled properly.  Just two lines are enough -- a typical parser.c might");
    output_line(out, "// look like:");
    output_line(out, "//");
    output_line(out, "//   #define BLUEBIRD_PARSER_IMPLEMENTATION");
    output_line(out, "//   #include \"bluebird-parser.h\"");
    output_line(out, "");
    output_line(out, "#ifndef _BLUEBIRD_PARSER_H_");
    output_line(out, "#define _BLUEBIRD_PARSER_H_");
    output_line(out, "");
    output_line(out, "#include \"stdbool.h\"");
    output_line(out, "#include \"stddef.h\"");
    output_line(out, "#include \"stdint.h\"");
    output_line(out, "");
    output_line(out, "// A parsed_id represents an element in the parse tree.  Use the");
    output_line(out, "// parsed_..._get() function corresponding to the element type to unpack the");
    output_line(out, "// element into its appropriate type of parsed_... element struct.");
    output_line(out, "typedef size_t parsed_id;");
    output_line(out, "");
    output_line(out, "// The bluebird_tree struct represents an entire parse tree.  Use the");
    output_line(out, "// bluebird_tree_create_...() functions to create a tree, then call");
    output_line(out, "// bluebird_tree_root() to get the root bluebird_id.");
    output_line(out, "struct bluebird_tree;");
    output_line(out, "");
    output_line(out, "// Creates a bluebird_tree from a string.  Remember to call");
    output_line(out, "// bluebird_tree_destroy() when you're done with it.");
    output_line(out, "struct bluebird_tree *bluebird_tree_create_from_string(const char *string);");
    output_line(out, "");
    output_line(out, "// Destroys a bluebird_tree, freeing its resources back to the system.");
    output_line(out, "void bluebird_tree_destroy(struct bluebird_tree *);");
    output_line(out, "");
    output_line(out, "// Prints a representation of the tree to stdout.");
    output_line(out, "void bluebird_tree_print(struct bluebird_tree *);");
    output_line(out, "");
    output_line(out, "// Returns the root parsed_id.");
    output_line(out, "parsed_id bluebird_tree_root_id(struct bluebird_tree *tree);");
    output_line(out, "");
    output_line(out, "// As a shortcut, returns the parsed_%%root-rule struct corresponding to the root parsed_id.");
    output_line(out, "struct parsed_%%root-rule bluebird_tree_get_parsed_%%root-rule(struct bluebird_tree *tree);");
    output_line(out, "");
    output_line(out, "// The range of text corresponding to a tree element.");
    output_line(out, "struct source_range {");
    output_line(out, "    size_t start;");
    output_line(out, "    size_t end;");
    output_line(out, "};");

    uint32_t n = gen->grammar->number_of_rules;
    struct choice **choices = 0;
    uint32_t choices_allocated_bytes = 0;
    uint32_t choice_index = 0;
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        for (uint32_t j = 0; j < rule->number_of_choices; ++j) {
            uint32_t k = choice_index++;
            choices = grow_array(choices, &choices_allocated_bytes,
             choice_index * sizeof(struct choice *));
            choices[k] = &rule->choices[j];
        }
    }
    if (choice_index > 0) {
        qsort(choices, choice_index, sizeof(struct choice *),
         compare_choice_names);
        output_line(out, "enum parsed_type {");
        for (uint32_t i = 0; i < choice_index; ++i) {
            size_t len = choices[i]->name_length;
            if (i > 0 && choices[i - 1]->name_length == len &&
             !memcmp(choices[i - 1]->name, choices[i]->name, len))
                continue;
            set_substitution(out, "choice-name", choices[i]->name, len,
             UPPERCASE_WITH_UNDERSCORES);
            output_line(out, "    PARSED_%%choice-name,");
        }
        output_line(out, "};");
    }
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "");
        output_line(out, "struct parsed_%%rule {");
        output_line(out, "    struct bluebird_tree *_tree;");
        output_line(out, "    parsed_id _next;");
        output_line(out, "    struct source_range range;");
        output_line(out, "    bool empty;");
        if (rule->number_of_choices > 0)
            output_line(out, "    enum parsed_type type;");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            struct slot slot = rule->slots[j];
            set_substitution(out, "referenced-slot", slot.name,
             slot.name_length, LOWERCASE_WITH_UNDERSCORES);
            output_line(out, "    parsed_id %%referenced-slot;");
        }
        if (rule->is_token)
            generate_fields_for_token_rule(out, rule, "    %%type%%field;\n");
        output_line(out, "};");
    }
    output_line(out, "");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "struct parsed_%%rule parsed_%%rule_get(struct bluebird_tree *, parsed_id);");
    }
    output_line(out, "");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "static inline struct parsed_%%rule parsed_%%rule_next(struct parsed_%%rule parsed)");
        output_line(out, "{");
        output_line(out, "    return parsed_%%rule_get(parsed._tree, parsed._next);");
        output_line(out, "}");
    }
    output_line(out, "");
    output_line(out, "#endif");

    output_line(out, "");
    output_line(out, "#ifdef BLUEBIRD_PARSER_IMPLEMENTATION");
    output_line(out, "// Code implementing the parser.  This might get a bit messy!");
    output_line(out, "#include <assert.h>");
    output_line(out, "#include <stdio.h>");
    output_line(out, "#include <stdlib.h>");
    output_line(out, "#include <string.h>");
    output_line(out, "");
    output_line(out, "struct bluebird_tree {");
    output_line(out, "    const char *string;");
    output_line(out, "    uint8_t *parse_tree;");
    output_line(out, "    size_t parse_tree_size;");
    output_line(out, "    parsed_id next_id;");
    output_line(out, "    parsed_id root_id;");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "    struct {");
        generate_fields_for_token_rule(out, rule, "        %%type%%field;\n");
        // FIXME: This isn't very memory-efficient.
        output_line(out, "        struct source_range range;");
        output_line(out, "    } *%%rule_tokens;");
        output_line(out, "    size_t number_of_%%rule_tokens;");
        output_line(out, "    size_t used_%%rule_tokens;");
        output_line(out, "    size_t %%rule_tokens_capacity;");
    }
    output_line(out, "};");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_string(out, "static void add_%%rule_token(struct bluebird_tree *tree, size_t start, size_t end");
        generate_fields_for_token_rule(out, rule, ", %%type%%field_param");
        output_line(out, ") {");
        output_line(out, "    size_t index = tree->number_of_%%rule_tokens++;");
        output_line(out, "    if (tree->number_of_%%rule_tokens > tree->%%rule_tokens_capacity) {");
        output_line(out, "        size_t capacity = (tree->%%rule_tokens_capacity + 1) * 3 / 2;");
        output_line(out, "        void *tokens = realloc(tree->%%rule_tokens, sizeof(tree->%%rule_tokens[0]) * capacity);");
        output_line(out, "        if (!tokens)");
        output_line(out, "            abort();");
        output_line(out, "        tree->%%rule_tokens_capacity = capacity;");
        output_line(out, "        tree->%%rule_tokens = tokens;");
        output_line(out, "    }");
        output_line(out, "    tree->%%rule_tokens[index].range.start = start;");
        output_line(out, "    tree->%%rule_tokens[index].range.end = end;");
        generate_fields_for_token_rule(out, rule, "    tree->%%rule_tokens[index].%%field = %%field_param;\n");
        output_line(out, "}");
    }

    set_literal_substitution(out, "token-type", "uint32_t");
    set_literal_substitution(out, "state-type", "uint32_t");

    // Code for reading and writing packed parse trees.
    // TODO: Delta encoding instead of absolute numbers.
    output_line(out, "static inline parsed_id read_tree(parsed_id *id, struct bluebird_tree *tree) {");
    output_line(out, "    uint8_t *parse_tree = tree->parse_tree;");
    output_line(out, "    size_t parse_tree_size = tree->parse_tree_size;");
    output_line(out, "    if (*id >= parse_tree_size)");
    output_line(out, "        return 0;");
    output_line(out, "    parsed_id result = parse_tree[*id] & 0x7f;");
    output_line(out, "    (*id)++;");
    output_line(out, "    int shift_amount = 7;");
    output_line(out, "    while (*id < parse_tree_size && (parse_tree[*id] & 0x80) != 0) {");
    output_line(out, "        result |= (parse_tree[*id] & 0x7f) << shift_amount;");
    output_line(out, "        shift_amount += 7;");
    output_line(out, "        (*id)++;");
    output_line(out, "    }");
    output_line(out, "    return result;");
    output_line(out, "}");
    output_line(out, "static bool grow_tree(struct bluebird_tree *tree, size_t size)");
    output_line(out, "{");
    output_line(out, "    size_t n = tree->parse_tree_size;");
    output_line(out, "    while (n < size || n < 4096)");
    output_line(out, "        n = (n + 1) * 3 / 2;");
    output_line(out, "    uint8_t *parse_tree = realloc(tree->parse_tree, n);");
    output_line(out, "    if (!parse_tree)");
    output_line(out, "        return false;");
    output_line(out, "    memset(parse_tree + tree->parse_tree_size, 0, n - tree->parse_tree_size);");
    output_line(out, "    tree->parse_tree_size = n;");
    output_line(out, "    tree->parse_tree = parse_tree;");
    output_line(out, "    return true;");
    output_line(out, "}");
    output_line(out, "static void write_tree(struct bluebird_tree *tree, parsed_id value)");
    output_line(out, "{");
    output_line(out, "    // Reserve 10 bytes (the maximum encoded size of a 64-bit value).");
    output_line(out, "    size_t reserved_size = tree->next_id + 10;");
    output_line(out, "    if (tree->parse_tree_size <= reserved_size && !grow_tree(tree, reserved_size))");
    // FIXME: Should we handle this case?
    output_line(out, "        return;");
    output_line(out, "    tree->parse_tree[tree->next_id++] = value & 0x7f;");
    output_line(out, "    value >>= 7;");
    output_line(out, "    while (value > 0) {");
    output_line(out, "        tree->parse_tree[tree->next_id++] = 0x80 | (value & 0x7f);");
    output_line(out, "        value >>= 7;");
    output_line(out, "    }");
    output_line(out, "}");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "struct parsed_%%rule parsed_%%rule_get(struct bluebird_tree *tree, parsed_id id) {");
        output_line(out, "    if (id == 0)");
        output_line(out, "        return (struct parsed_%%rule){ ._tree = tree, .empty = true };");
        output_line(out, "    parsed_id next = read_tree(&id, tree);");
        if (rule->is_token)
            output_line(out, "    size_t token_index = read_tree(&id, tree);");
        else {
            output_line(out, "    size_t start_location = read_tree(&id, tree);");
            output_line(out, "    size_t end_location = read_tree(&id, tree);");
        }
        output_line(out, "    return (struct parsed_%%rule){");
        output_line(out, "        ._tree = tree,");
        output_line(out, "        ._next = next,");
        if (rule->is_token) {
            generate_fields_for_token_rule(out, rule, "        .%%field = tree->%%rule_tokens[token_index].%%field,\n");
            output_line(out, "        .range = tree->%%rule_tokens[token_index].range,");
        } else {
            output_line(out, "        .range.start = start_location,");
            output_line(out, "        .range.end = end_location,");
        }
        if (rule->number_of_choices > 0)
            output_line(out, "        .type = read_tree(&id, tree),");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            struct slot slot = rule->slots[j];
            set_substitution(out, "referenced-slot", slot.name,
             slot.name_length, LOWERCASE_WITH_UNDERSCORES);
            output_line(out, "        .%%referenced-slot = read_tree(&id, tree),");
        }
        output_line(out, "    };");
        output_line(out, "}");
    }
    output_line(out, "static parsed_id finish_node(uint32_t rule, uint32_t choice, "
     "parsed_id next_sibling, parsed_id *slots, size_t start_location, size_t end_location, void *info) {");
    output_line(out, "    struct bluebird_tree *tree = info;");
//    output_line(out, "    printf(\"finishing node (%lu): %u / %u\\n\", tree->next_id, rule, choice);");
    output_line(out, "    parsed_id id = tree->next_id;");
    output_line(out, "    write_tree(tree, next_sibling);");
    // TODO: Remove these casts.
    output_line(out, "    write_tree(tree, (parsed_id)start_location);");
    output_line(out, "    write_tree(tree, (parsed_id)end_location);");
    output_line(out, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (rule->is_token)
            continue;
        set_unsigned_number_substitution(out, "rule-index", i);
        output_line(out, "    case %%rule-index: {");
//        output_line(out, "        printf(\"next = %lu\\n\", next_sibling);");
        if (rule->number_of_choices > 0) {
            output_line(out, "        switch (choice) {");
            for (uint32_t i = 0; i < rule->number_of_choices; ++i) {
                set_unsigned_number_substitution(out, "choice-index", i);
                set_substitution(out, "choice-name", rule->choices[i].name,
                 rule->choices[i].name_length, UPPERCASE_WITH_UNDERSCORES);
                output_line(out, "        case %%choice-index:");
                output_line(out, "            write_tree(tree, PARSED_%%choice-name);");
                output_line(out, "            break;");
            }
            output_line(out, "        }");
        }
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            set_unsigned_number_substitution(out, "slot-index", j);
//            output_line(out, "        printf(\"slot %%slot-index = %lu\\n\", slots[%%slot-index]);");
            output_line(out, "        write_tree(tree, slots[%%slot-index]);");
        }
        output_line(out, "        break;");
        output_line(out, "    }");
    }
    output_line(out, "    default:");
    output_line(out, "        break;");
    output_line(out, "    }");
    output_line(out, "    return id;");
    output_line(out, "}");
    output_line(out, "static parsed_id finish_token(uint32_t rule, parsed_id next_sibling, void *info) {");
    output_line(out, "    struct bluebird_tree *tree = info;");
//    output_line(out, "    printf(\"finishing token (%lu): %u\\n\", tree->next_id, rule);");
    output_line(out, "    parsed_id id = tree->next_id;");
    output_line(out, "    write_tree(tree, next_sibling);");
    output_line(out, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        set_unsigned_number_substitution(out, "rule-index", i);
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "    case %%rule-index: {");
        output_line(out, "        tree->used_%%rule_tokens++;");
        output_line(out, "        if (tree->used_%%rule_tokens > tree->number_of_%%rule_tokens)");
        output_line(out, "            abort();");
        output_line(out, "        size_t token_index = tree->number_of_%%rule_tokens - tree->used_%%rule_tokens;");
        // TODO: Remove this cast.
        output_line(out, "        write_tree(tree, (parsed_id)token_index);");
        output_line(out, "        break;");
        output_line(out, "    }");
    }
    output_line(out, "    default:");
    output_line(out, "        break;");
    output_line(out, "    }");
    output_line(out, "    return id;");
    output_line(out, "}");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "static void parsed_%%rule_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent);");
    }
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_substitution(out, "rule", rule->name, rule->name_length,
         LOWERCASE_WITH_UNDERSCORES);
        output_line(out, "static void parsed_%%rule_print(struct bluebird_tree *tree, parsed_id id, const char *slot_name, int indent) {");
        output_line(out, "    struct parsed_%%rule it = parsed_%%rule_get(tree, id);");
        output_line(out, "    while (!it.empty) {");
        output_line(out, "        for (int i = 0; i < indent; ++i) printf(\"  \");");
        output_line(out, "        printf(\"%%rule\");");
        output_line(out, "        if (strcmp(\"%%rule\", slot_name))");
        output_line(out, "            printf(\"@%s\", slot_name);");
        if (rule->number_of_choices > 0) {
            output_line(out, "        switch (it.type) {");
            for (uint32_t j = 0; j < rule->number_of_choices; ++j) {
                set_substitution(out, "choice-name", rule->choices[j].name,
                 rule->choices[j].name_length, UPPERCASE_WITH_UNDERSCORES);
                output_line(out, "        case PARSED_%%choice-name:");
                output_line(out, "            printf(\" : %%choice-name\");");
                output_line(out, "            break;");
            }
            output_line(out, "        default:");
            output_line(out, "            break;");
            output_line(out, "        }");
        }
        if (rule->is_token) {
            if (rule_is_named(rule, "identifier"))
                output_line(out, "        printf(\" - %.*s\", (int)it.length, it.identifier);");
            else if (rule_is_named(rule, "number"))
                output_line(out, "        printf(\" - %f\", it.number);");
            else if (rule_is_named(rule, "string"))
                output_line(out, "        printf(\" - %.*s\", (int)it.length, it.string);");
        }
        output_line(out, "        printf(\" (%zu - %zu)\\n\", it.range.start, it.range.end);");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            struct slot slot = rule->slots[j];
            set_substitution(out, "slot-name", slot.name, slot.name_length,
             LOWERCASE_WITH_UNDERSCORES);
            struct rule *slot_rule = &gen->grammar->rules[slot.rule_index];
            set_substitution(out, "slot-rule", slot_rule->name,
             slot_rule->name_length, LOWERCASE_WITH_UNDERSCORES);
            output_line(out, "        parsed_%%slot-rule_print(tree, it.%%slot-name, \"%%slot-name\", indent + 1);");
        }
        output_line(out, "        it = parsed_%%rule_next(it);");
        output_line(out, "    }");
        output_line(out, "}");
    }
    output_line(out, "void bluebird_tree_print(struct bluebird_tree *tree) {");
    output_line(out, "    parsed_%%root-rule_print(tree, tree->root_id, \"%%root-rule\", 0);");
    output_line(out, "}");

    output_line(out, "parsed_id bluebird_tree_root_id(struct bluebird_tree *tree) {");
    output_line(out, "    return tree->root_id;");
    output_line(out, "}");

    set_unsigned_number_substitution(out, "identifier-token", 0xffffffff);
    set_unsigned_number_substitution(out, "number-token", 0xffffffff);
    set_unsigned_number_substitution(out, "string-token", 0xffffffff);
    set_unsigned_number_substitution(out, "bracket-transition-token", 0xffffffff);
    output_line(out, "#define IGNORE_TOKEN_WRITE(...)");
    set_literal_substitution(out, "write-identifier-token", "IGNORE_TOKEN_WRITE");
    set_literal_substitution(out, "write-number-token", "IGNORE_TOKEN_WRITE");
    set_literal_substitution(out, "write-string-token", "IGNORE_TOKEN_WRITE");
    for (uint32_t i = gen->combined->number_of_keyword_tokens;
     i < gen->combined->number_of_tokens; ++i) {
        if (token_is(&gen->combined->tokens[i], "identifier"))
            set_unsigned_number_substitution(out, "identifier-token", i);
        else if (token_is(&gen->combined->tokens[i], "number"))
            set_unsigned_number_substitution(out, "number-token", i);
        else if (token_is(&gen->combined->tokens[i], "string"))
            set_unsigned_number_substitution(out, "string-token", i);
    }
    output_line(out, "static size_t read_keyword_token(%%token-type *token, bool *end_token, const char *text, void *info);");
    for (uint32_t i = 0; i < n; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (!rule->is_token)
            continue;
        if (rule_is_named(rule, "identifier")) {
            output_line(out, "static void write_identifier_token(size_t offset, size_t length, void *info) {");
            output_line(out, "    struct bluebird_tree *tree = info;");
            output_line(out, "    add_identifier_token(tree, offset, offset + length, tree->string + offset, length);");
            output_line(out, "}");
            set_literal_substitution(out, "write-identifier-token", "write_identifier_token");
        } else if (rule_is_named(rule, "number")) {
            output_line(out, "static void write_number_token(size_t offset, size_t length, double number, void *info) {");
            output_line(out, "    struct bluebird_tree *tree = info;");
            output_line(out, "    add_number_token(tree, offset, offset + length, number);");
            output_line(out, "}");
            set_literal_substitution(out, "write-number-token", "write_number_token");
        } else if (rule_is_named(rule, "string")) {
            output_line(out, "static void write_string_token(size_t offset, size_t length, size_t content_offset, size_t content_length, void *info) {");
            output_line(out, "    struct bluebird_tree *tree = info;");
            output_line(out, "    add_string_token(tree, offset, offset + length, tree->string + offset, length);");
            output_line(out, "}");
            set_literal_substitution(out, "write-string-token", "write_string_token");
        }
    }
    if (SHOULD_ALLOW_DASHES_IN_IDENTIFIERS(gen->combined))
        set_literal_substitution(out, "allow-dashes-in-identifiers", "true");
    else
        set_literal_substitution(out, "allow-dashes-in-identifiers", "false");
    output_formatted_source(out, tokenizer_source);
    output_line(out, "static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context);");
    output_line(out, "static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context);");
    output_line(out, "static size_t number_of_slots_lookup(uint32_t rule, void *context);");
    output_line(out, "static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context);");

    output_formatted_source(out, construct_source);

    set_unsigned_number_substitution(out, "start-state",
     gen->deterministic->automaton.start_state);
    output_line(out, "");
    output_line(out, "struct state_stack {");
    output_line(out, "    %%state-type *states;");
    output_line(out, "    size_t capacity;");
    output_line(out, "    size_t depth;");
    output_line(out, "};");
    output_line(out, "struct fill_run_continuation {");
    output_line(out, "    %%state-type state;");
    output_line(out, "    struct state_stack stack;");
    output_line(out, "};");
    output_line(out, "static void fill_run_states(struct bluebird_token_run *, struct fill_run_continuation *);");
    output_line(out, "static parsed_id build_parse_tree(struct bluebird_default_tokenizer *, struct bluebird_token_run *, struct bluebird_tree *);");
    output_line(out, "");
    output_line(out, "struct bluebird_tree *bluebird_tree_create_from_string(const char *string) {");
    output_line(out, "    struct bluebird_tree *tree = calloc(1, sizeof(struct bluebird_tree));");
    output_line(out, "    tree->string = string;");
    output_line(out, "    tree->next_id = 1;");
    output_line(out, "    struct bluebird_default_tokenizer tokenizer = {");
    output_line(out, "        .text = string,");
    output_line(out, "        .info = tree,");
    output_line(out, "    };");
    output_line(out, "    struct bluebird_token_run *token_run = 0;");
    output_line(out, "    struct fill_run_continuation c = {");
    output_line(out, "        .state = %%start-state,");
    output_line(out, "    };");
    output_line(out, "    while (bluebird_default_tokenizer_advance(&tokenizer, &token_run))");
    output_line(out, "        fill_run_states(token_run, &c);");
    output_line(out, "    if (string[tokenizer.offset] != '\\0') {");
    output_line(out, "        // TODO: Return error instead of printing it");
    output_line(out, "        fprintf(stderr, \"error: tokenizing failed. next char was %u\\n\", string[tokenizer.offset]);");
    output_line(out, "        exit(-1);");
    output_line(out, "    }");
    output_line(out, "    if (c.stack.depth > 0) {");
    output_line(out, "        // TODO: Return error instead of printing it");
    output_line(out, "        fprintf(stderr, \"error: parsing failed because the stack was still full\\n\");");
    output_line(out, "    }");
    output_line(out, "    free(c.stack.states);");
    /*
    output_line(out, "    struct bluebird_token_run *run_to_print = token_run;");
    output_line(out, "    while (run_to_print) {");
    output_line(out, "        for (uint32_t i = 0; i < run_to_print->number_of_tokens; ++i) {");
    output_line(out, "            printf(\"%u -> %u\\n\", run_to_print->tokens[i], run_to_print->states[i]);");
    output_line(out, "        }");
    output_line(out, "        printf(\"--\\n\");");
    output_line(out, "        run_to_print = run_to_print->prev;");
    output_line(out, "    }");
     */
    output_line(out, "    tree->root_id = build_parse_tree(&tokenizer, token_run, tree);");
    output_line(out, "    return tree;");
    output_line(out, "}");
    output_line(out, "void bluebird_tree_destroy(struct bluebird_tree *tree) {");
    output_line(out, "    free(tree->parse_tree);");
    output_line(out, "    free(tree->identifier_tokens);");
    output_line(out, "    free(tree->number_tokens);");
    output_line(out, "    free(tree->string_tokens);");
    output_line(out, "    free(tree);");
    output_line(out, "}");
    output_line(out, "static bool grow_state_stack(struct state_stack *stack) {");
    output_line(out, "    size_t new_capacity = (stack->capacity + 2) * 3 / 2;");
    output_line(out, "    if (new_capacity <= stack->capacity)");
    output_line(out, "        return false;");
    output_line(out, "    %%state-type *new_states = realloc(stack->states, new_capacity * sizeof(%%state-type));");
    output_line(out, "    if (!new_states)");
    output_line(out, "        return false;");
    output_line(out, "    stack->states = new_states;");
    output_line(out, "    stack->capacity = new_capacity;");
    output_line(out, "    return true;");
    output_line(out, "}");
    struct automaton *a = &gen->deterministic->automaton;
    struct automaton *b = &gen->deterministic->bracket_automaton;
    set_unsigned_number_substitution(out, "first-bracket-state-id",
     a->number_of_states);
    output_line(out, "static void fill_run_states(struct bluebird_token_run *run, struct fill_run_continuation *cont) {");
    output_line(out, "    uint16_t token_index = 0;");
    output_line(out, "    uint16_t number_of_tokens = run->number_of_tokens;");
    output_line(out, "    uint16_t start_state = cont->state;");
    output_line(out, "start:");
    output_line(out, "    switch (start_state) {");
    generate_automaton(gen, out, a, 0, NORMAL_AUTOMATON);
    generate_automaton(gen, out, b, a->number_of_states, BRACKET_AUTOMATON);
    output_line(out, "    }");
    output_line(out, "}");
    generate_action_table(gen, out);
    generate_keyword_reader(gen, out);
    output_line(out, "static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context) {");
    output_line(out, "    switch (parent) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (rule->number_of_slots == 0)
            continue;
        set_unsigned_number_substitution(out, "rule-index", i);
        output_line(out, "    case %%rule-index:");
        output_line(out, "        switch (slot) {");
        for (uint32_t j = 0; j < rule->number_of_slots; ++j) {
            set_unsigned_number_substitution(out, "slot-index", j);
            set_unsigned_number_substitution(out, "slot-rule-index",
             rule->slots[j].rule_index);
            output_line(out, "        case %%slot-index: return %%slot-rule-index;");
        }
        output_line(out, "        default: break;");
        output_line(out, "        }");
        output_line(out, "        break;");
    }
    output_line(out, "    default: break;");
    output_line(out, "    }");
    output_line(out, "    return UINT32_MAX;");
    output_line(out, "}");
    output_line(out, "static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context) {");
    output_line(out, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        if (rule->first_operator_choice == rule->number_of_choices)
            continue;
        set_unsigned_number_substitution(out, "rule-index", i);
        output_line(out, "    case %%rule-index:");
        output_line(out, "        switch (choice) {");
        for (uint32_t j = rule->first_operator_choice;
         j < rule->number_of_choices; ++j) {
            struct choice op = rule->choices[j];
            set_unsigned_number_substitution(out, "choice-index", j);
            set_signed_number_substitution(out, "operator-precedence",
             op.precedence);
            output_line(out, "        case %%choice-index:");
            output_line(out, "            *precedence = %%operator-precedence;");
            if (op.fixity == PREFIX)
                output_line(out, "            *fixity_associativity = CONSTRUCT_PREFIX;");
            else if (op.fixity == POSTFIX)
                output_line(out, "            *fixity_associativity = CONSTRUCT_POSTFIX;");
            else if (op.associativity == RIGHT)
                output_line(out, "            *fixity_associativity = CONSTRUCT_INFIX_RIGHT;");
            else if (op.associativity == FLAT)
                output_line(out, "            *fixity_associativity = CONSTRUCT_INFIX_FLAT;");
            else
                output_line(out, "            *fixity_associativity = CONSTRUCT_INFIX_LEFT;");
            output_line(out, "            return;");
        }
        output_line(out, "        default: return;");
        output_line(out, "        }");
    }
    output_line(out, "    default: return;");
    output_line(out, "    }");
    output_line(out, "}");
    output_line(out, "static size_t number_of_slots_lookup(uint32_t rule, void *context) {");
    output_line(out, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        set_unsigned_number_substitution(out, "rule-index", i);
        set_unsigned_number_substitution(out, "number-of-slots",
         gen->grammar->rules[i].number_of_slots);
        output_line(out, "    case %%rule-index: return %%number-of-slots;");
    }
    output_line(out, "    default: return 0;");
    output_line(out, "    }");
    output_line(out, "}");
    output_line(out, "static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context) {");
    output_line(out, "    switch (rule) {");
    for (uint32_t i = 0; i < gen->grammar->number_of_rules; ++i) {
        struct rule *rule = &gen->grammar->rules[i];
        set_unsigned_number_substitution(out, "rule-index", i);
        set_unsigned_number_substitution(out, "left-slot",
         rule->left_slot_index);
        set_unsigned_number_substitution(out, "right-slot",
         rule->right_slot_index);
        set_unsigned_number_substitution(out, "operand-slot",
         rule->operand_slot_index);
        output_line(out, "    case %%rule-index:");
        output_line(out, "        *left = %%left-slot;");
        output_line(out, "        *right = %%right-slot;");
        output_line(out, "        *operand = %%operand-slot;");
        output_line(out, "        break;");
    }
    output_line(out, "    }");
    output_line(out, "}");
    output_line(out, "#endif");
    output_line(out, "");
    output_destroy(out);
}

static void generate_fields_for_token_rule(struct generator_output *out,
 struct rule *rule, const char *string)
{
    if (rule_is_named(rule, "identifier")) {
        set_literal_substitution(out, "type", "const char *");
        set_literal_substitution(out, "field", "identifier");
        output_string(out, string);
        set_literal_substitution(out, "type", "size_t ");
        set_literal_substitution(out, "field", "length");
        output_string(out, string);
    } else if (rule_is_named(rule, "number")) {
        set_literal_substitution(out, "type", "double ");
        set_literal_substitution(out, "field", "number");
        output_string(out, string);
    } else if (rule_is_named(rule, "string")) {
        set_literal_substitution(out, "type", "const char *");
        set_literal_substitution(out, "field", "string");
        output_string(out, string);
        set_literal_substitution(out, "type", "size_t ");
        set_literal_substitution(out, "field", "length");
        output_string(out, string);
    } else
        abort();
}

struct generated_token {
    struct token token;
    struct generated_token *prefix;
};

static void generate_keyword(struct generator_output *out, struct token keyword,
 size_t indentation)
{
    set_unsigned_number_substitution(out, "token-index", keyword.symbol);
    if (keyword.length > UINT32_MAX)
        abort();
    set_unsigned_number_substitution(out, "token-length",
     (uint32_t)keyword.length);
    output_indentation(out, indentation);
    if (keyword.type == TOKEN_END)
        output_line(out, "*end_token = true;");
    else
        output_line(out, "*end_token = false;");
    output_indentation(out, indentation);
    output_line(out, "*token = %%token-index;");
    output_indentation(out, indentation);
    output_line(out, "return %%token-length;");
}

static void generate_keyword_reader(struct generator *gen,
 struct generator_output *out) {
    output_line(out, "static size_t read_keyword_token(%%token-type *token, bool *end_token, const char *text, void *info) {");
    output_line(out, "    switch (text[0]) {");
    uint32_t n = gen->combined->number_of_keyword_tokens +
     gen->grammar->number_of_comment_tokens;
    struct generated_token *tokens = malloc(sizeof(struct generated_token) *
     (size_t)n);
    if (!tokens) {
        fputs("critical error: out of memory\n", stderr);
        exit(-1);
    }
    uint32_t i = 0;
    for (; i < gen->combined->number_of_keyword_tokens; ++i)
        tokens[i].token = gen->combined->tokens[i];
    for (uint32_t j = 0; j < gen->grammar->number_of_comment_tokens; ++j)
        tokens[i + j].token = gen->grammar->comment_tokens[j];
    qsort(tokens, n, sizeof(struct generated_token), compare_tokens);
    size_t shared_length = 0;
    struct generated_token *prefix = 0;
    for (uint32_t i = 0; i < n; ++i) {
        struct generated_token *token = &tokens[i];
        struct token keyword = token->token;
        struct generated_token *next = 0;
        size_t next_length = 0;
        if (i + 1 < n) {
            next = &tokens[i + 1];
            next_length = next->token.length;
        }
        size_t shared = 0;
        for (; shared < keyword.length && shared < next_length; shared++) {
            if (keyword.string[shared] != next->token.string[shared])
                break;
        }
        while (shared > shared_length) {
            set_unsigned_number_substitution(out, "character",
             keyword.string[shared_length]);
            output_indentation(out, shared_length + 1);
            output_line(out, "case %%character:");
            shared_length++;
            if (shared_length > UINT32_MAX)
                abort();
            set_unsigned_number_substitution(out, "index",
             (uint32_t)shared_length);
            output_indentation(out, shared_length + 1);
            output_line(out, "switch (text[%%index]) {");
        }
        token->prefix = prefix;
        if (shared == keyword.length) {
            prefix = token;
            continue;
        }
        set_unsigned_number_substitution(out, "character",
         keyword.string[shared_length]);
        output_indentation(out, shared_length + 1);
        output_line(out, "case %%character:");
        if (keyword.length <= shared_length + 1)
            generate_keyword(out, keyword, shared_length + 2);
        else {
            if (shared_length + 1 > UINT32_MAX)
                abort();
            set_unsigned_number_substitution(out, "offset",
             (uint32_t)(shared_length + 1));
            output_indentation(out, shared_length + 2);
            output_string(out, "if (");
            for (size_t j = shared_length + 1; j < keyword.length; ++j) {
                set_unsigned_number_substitution(out, "character",
                 keyword.string[j]);
                set_unsigned_number_substitution(out, "index", (uint32_t)j);
                output_string(out, "text[%%index] == %%character");
                if (j + 1 < keyword.length)
                    output_string(out, " && ");
            }
            if (keyword.length - shared_length - 1 > UINT32_MAX)
                abort();
            output_line(out, ") {");
            generate_keyword(out, keyword, shared_length + 3);
            output_indentation(out, shared_length + 2);
            output_line(out, "} else {");
            if (prefix)
                generate_keyword(out, prefix->token, shared_length + 3);
            else {
                output_indentation(out, shared_length + 3);
                output_line(out, "return 0;");
            }
            output_indentation(out, shared_length + 2);
            output_line(out, "}");
        }
        while (shared_length > shared) {
            output_indentation(out, shared_length + 1);
            output_line(out, "default:");
            if (prefix) {
                generate_keyword(out, prefix->token, shared_length + 2);
                if (prefix->token.length >= shared_length)
                    prefix = prefix->prefix;
            } else {
                output_indentation(out, shared_length + 2);
                output_line(out, "return 0;");
            }
            output_indentation(out, shared_length + 1);
            output_line(out, "}");
            shared_length--;
        }
    }
    output_line(out, "    default:");
    output_line(out, "        return 0;");
    output_line(out, "    }");
    output_line(out, "}");
}

static void generate_automaton(struct generator *gen,
 struct generator_output *out, struct automaton *a, uint32_t offset,
 enum automaton_type type)
{
    for (uint32_t i = 0; i < a->number_of_states; ++i) {
        struct state s = a->states[i];
        set_unsigned_number_substitution(out, "state-id", i + offset);
        output_line(out, "    case %%state-id:");
        output_line(out, "state_%%state-id: {");
        if (s.accepting && type == BRACKET_AUTOMATON) {
            set_unsigned_number_substitution(out, "state-transition-symbol",
             s.transition_symbol);
            output_line(out, "        if (cont->stack.depth == 0)");
            output_line(out, "            break;"); // TODO: Error handling.
            output_line(out, "        start_state = cont->stack.states[--cont->stack.depth];");
            output_line(out, "        run->tokens[token_index] = %%state-transition-symbol;");
            output_line(out, "        goto start;");
            output_line(out, "    }");
            continue;
        }
        output_line(out, "        if (token_index >= number_of_tokens) {");
        output_line(out, "            cont->state = %%state-id;");
        output_line(out, "            return;");
        output_line(out, "        }");
        output_line(out, "        %%token-type token = run->tokens[token_index];");
        output_line(out, "        run->states[token_index] = %%state-id;");
        output_line(out, "        token_index++;");
        output_line(out, "        switch (token) {");
        bool has_bracket_symbols = false;
        for (uint32_t j = 0; j < s.number_of_transitions; ++j) {
            struct transition t = s.transitions[j];
            if (t.symbol >= gen->combined->number_of_tokens) {
                // Symbols are either tokens or bracket symbols, so this must
                // be a bracket symbol.
                has_bracket_symbols = true;
            }
            set_unsigned_number_substitution(out, "token-symbol", t.symbol);
            set_unsigned_number_substitution(out, "token-target", t.target + offset);
            output_line(out, "        case %%token-symbol: goto state_%%token-target;");
        }
        output_string(out, "        default:");
        if (has_bracket_symbols) {
            output_line(out, "");
            output_line(out, "            if (cont->stack.depth >= cont->stack.capacity) {");
            output_line(out, "                if (!grow_state_stack(&cont->stack))");
            output_line(out, "                    break;"); // TODO: Error handling.
            output_line(out, "            }");
            output_line(out, "            cont->stack.states[cont->stack.depth++] = %%state-id;");
            output_line(out, "            token_index--;");
            output_line(out, "            goto state_%%first-bracket-state-id;");
        } else
            output_line(out, " break;"); // TODO: Error handling.
        output_line(out, "        }");
        output_line(out, "        break;");
        output_line(out, "    }");
    }
}

struct action_table_bucket_group {
    uint32_t index;
    uint32_t length;
};

struct action_table_bucket {
    struct action_table_bucket *next;
    // These include offsets for bracket states.
    state_id target_nfa_state;
    state_id dfa_state;
    state_id nfa_state;
    symbol_id dfa_symbol;
    // For bracket transitions; this is the state to push on the stack.
    state_id push_nfa_state;
    uint32_t action_index;
};

static int compare_action_table_bucket_groups(const void *aa, const void *bb)
{
    const struct action_table_bucket_group *a = aa;
    const struct action_table_bucket_group *b = bb;
    // Reverse-sort by length.
    if (a->length > b->length)
        return -1;
    if (a->length < b->length)
        return 1;
    return 0;
}

// 0xe5aa55e5 is just an arbitrary 32-bit prime number.
#define ACTION_TABLE_ENTRY_HASH(target_nfa_state, dfa_state, dfa_symbol) \
 ((((((0xe5aa55e5 ^ (target_nfa_state)) * 0xe5aa55e5) ^ (dfa_state)) * \
 0xe5aa55e5) ^ (dfa_symbol)) * 0xe5aa55e5)

static void generate_action_table(struct generator *gen,
 struct generator_output *out)
{
    struct deterministic_grammar *d = gen->deterministic;

    // Collect all the "groups" of action map entries with the same
    // target_nfa_state.  Sort the groups by size, longest to shortest.
    struct action_table_bucket *buckets =
     calloc(d->action_map.number_of_entries +
     d->bracket_action_map.number_of_entries,
     sizeof(struct action_table_bucket));
    struct action_table_bucket_group *groups = 0;
    state_id max_nfa_state = 0;
    uint32_t groups_allocated_bytes = 0;
    uint32_t number_of_groups = 0;
    for (int i = 0; i < 2; ++i) {
        struct action_map *map = i == 0 ? &d->action_map :
         &d->bracket_action_map;
        uint32_t offset = i == 0 ? 0 : d->action_map.number_of_entries;
        uint32_t nfa_state_offset = i == 0 ? 0 :
         gen->combined->automaton.number_of_states;
        for (uint32_t j = 0; j < map->number_of_entries;) {
            uint32_t length = 0;
            for (; j + length < map->number_of_entries; ++length) {
                struct action_table_bucket *b = &buckets[offset + j + length];
                struct action_map_entry e = map->entries[j + length];
                *b = (struct action_table_bucket){
                    .target_nfa_state = e.target_nfa_state + nfa_state_offset,
                    .dfa_state = e.dfa_state + (i==0 ? 0 :
                     d->automaton.number_of_states),
                    .nfa_state = e.nfa_state + nfa_state_offset,
                    .dfa_symbol = e.dfa_symbol,
                    .action_index = (uint32_t)(e.actions - d->actions),
                };
                if (e.dfa_symbol >= gen->combined->number_of_tokens) {
                    // This is a bracket transition.  Find the corresponding
                    // accepting state and store it in the table.
                    struct automaton bracket = gen->combined->bracket_automaton;
                    for (state_id i = 0; i < bracket.number_of_states; ++i) {
                        struct state s = bracket.states[i];
                        if (!s.accepting || s.transition_symbol != e.nfa_symbol)
                            continue;
                        b->push_nfa_state = b->nfa_state;
                        b->nfa_state = i +
                         gen->combined->automaton.number_of_states;
                        break;
                    }
                }
                if (b->target_nfa_state > max_nfa_state)
                    max_nfa_state = b->target_nfa_state;
                if (b->nfa_state > max_nfa_state)
                    max_nfa_state = b->nfa_state;
                if (map->entries[j].target_nfa_state !=
                 map->entries[j + length].target_nfa_state)
                    break;
            }
            groups = grow_array(groups, &groups_allocated_bytes,
             (number_of_groups + 1) * sizeof(struct action_table_bucket_group));
            groups[number_of_groups++] = (struct action_table_bucket_group){
                .index = offset + j,
                .length = length,
            };
            j += length;
        }
    }
    qsort(groups, number_of_groups, sizeof(struct action_table_bucket_group),
     compare_action_table_bucket_groups);

    // Size the table to a power of two.
    uint32_t table_size = 1;
    while (table_size <= d->action_map.number_of_entries +
     d->bracket_action_map.number_of_entries)
        table_size *= 2;
    uint32_t table_mask = table_size - 1;

    // This array maps old NFA states to new NFA states.
    state_id *nfa_states = malloc((max_nfa_state + 1) * sizeof(state_id));
    for (state_id i = 0; i < max_nfa_state + 1; ++i)
        nfa_states[i] = i;

    struct action_table_bucket **table_buckets = calloc(table_size,
     sizeof(struct action_table_bucket *));
    uint32_t *bucket_sizes = calloc(table_size, sizeof(uint32_t));
    uint32_t nfa_state = max_nfa_state + 1;
    uint32_t saved_nfa_state = 0;
    // Start at a bucket limit of 1 and increase it.
    uint32_t bucket_limit = 1;
    // How many times should we try to randomize indexes?
#define MAX_TRIES 100000
    uint32_t tries_left = MAX_TRIES;
    for (uint32_t i = 0; i < number_of_groups; ++i) {
        struct action_table_bucket_group group = groups[i];
        // TODO: remove
//        printf("group size: %u (%u, %u, %u)\n", group.length, nfa_state, tries_left, bucket_limit);
        while (true) {
            if (nfa_state == UINT32_MAX)
                abort();
            uint32_t j = 0;
            for (; j < group.length; ++j) {
                struct action_table_bucket *bucket = &buckets[group.index + j];
                uint32_t k = ACTION_TABLE_ENTRY_HASH(nfa_state,
                 bucket->dfa_state, bucket->dfa_symbol);
                k &= table_mask;
                bucket->next = table_buckets[k];
                table_buckets[k] = bucket;
                if (bucket_sizes[k]++ >= bucket_limit)
                    goto retry;
            }
            nfa_states[buckets[group.index].target_nfa_state] = nfa_state;
            nfa_state++;
            saved_nfa_state = nfa_state;
            break;
retry:
            // Roll back changes and try a new nfa_state.
            for (; j < group.length; --j) {
                struct action_table_bucket *bucket = &buckets[group.index + j];
                uint32_t k = ACTION_TABLE_ENTRY_HASH(nfa_state,
                 bucket->dfa_state, bucket->dfa_symbol);
                k &= table_mask;
                bucket_sizes[k]--;
                table_buckets[k] = table_buckets[k]->next;
            }
            nfa_state++;
            if (tries_left-- == 0) {
                // If we ran out of tries, give ourselves some more room and
                // keep going.
                bucket_limit += 1;
                tries_left = MAX_TRIES;
                nfa_state = saved_nfa_state;
            }
        }
    }
    const int actions_per_line = 30;
    output_line(out, "static const uint16_t actions[] = {");
    for (uint32_t i = 0; i < d->number_of_actions; ++i) {
        set_unsigned_number_substitution(out, "action", d->actions[i]);
        output_string(out, "%%action,");
        if ((i + 1) % actions_per_line == 0)
            output_line(out, "");
    }
    output_line(out, "};");
    output_line(out, "struct action_table_entry {");
    output_line(out, "    %%state-type target_nfa_state;");
    output_line(out, "    %%state-type dfa_state;");
    output_line(out, "    %%token-type dfa_symbol;");
    output_line(out, "    %%state-type nfa_state;");
    output_line(out, "    uint32_t actions;");
    output_line(out, "    %%state-type push_nfa_state;");
    output_line(out, "};");
#define ACTION_TABLE_ENTRY_FLAG_PUSH 1
#define ACTION_TABLE_ENTRY_FLAG_POP 2
    set_unsigned_number_substitution(out, "table-size", table_size);
    set_unsigned_number_substitution(out, "bucket-limit", bucket_limit);
    output_line(out, "static const struct action_table_entry action_table[%%table-size][%%bucket-limit] = {");
    const int entries_per_line = 6;
    int next_newline = entries_per_line;
    for (uint32_t i = 0; i < table_size; ++i) {
        output_string(out, "{");
        struct action_table_bucket *bucket = table_buckets[i];
        if (!bucket)
            output_string(out, "0");
        for (; bucket; bucket = bucket->next) {
            set_unsigned_number_substitution(out, "target-nfa-state",
             nfa_states[bucket->target_nfa_state]);
            set_unsigned_number_substitution(out, "dfa-state",
             bucket->dfa_state);
            set_unsigned_number_substitution(out, "dfa-symbol",
             bucket->dfa_symbol);
            set_unsigned_number_substitution(out, "nfa-state",
             nfa_states[bucket->nfa_state]);
            set_unsigned_number_substitution(out, "actions",
             bucket->action_index);
            output_string(out, "{%%target-nfa-state,%%dfa-state,%%dfa-symbol,%%nfa-state,%%actions");
            if (bucket->dfa_symbol >= gen->combined->number_of_tokens) {
                set_unsigned_number_substitution(out, "push-nfa-state",
                 nfa_states[bucket->push_nfa_state]);
                output_string(out, ",%%push-nfa-state");
            }
            output_string(out, "},");
            if (--next_newline == 0 && bucket->next) {
                output_line(out, "");
                next_newline = entries_per_line;
            }
        }
        output_string(out, "},");
        if (next_newline == 0) {
            output_line(out, "");
            next_newline = entries_per_line;
        }
    }
    output_line(out, "};");
    output_line(out, "");
    output_line(out, "static const struct action_table_entry *action_table_lookup(%%state-type nfa_state, %%state-type dfa_state, %%token-type token) {");
#define STRINGIFY(...) EVALUATE_MACROS_AND_STRINGIFY(__VA_ARGS__)
    set_literal_substitution(out, "action-table-entry-hash",
     STRINGIFY(ACTION_TABLE_ENTRY_HASH(nfa_state, dfa_state, token)));
    set_unsigned_number_substitution(out, "action-table-mask", table_mask);
    output_line(out, "    uint32_t index = %%action-table-entry-hash & %%action-table-mask;");
    output_line(out, "    uint32_t j = 0;");
    output_line(out, "    const struct action_table_entry *entry = 0;");
//    output_line(out, "    printf(\"Searching for: %u,%u,%u\\n\", nfa_state, dfa_state, token);");
    output_line(out, "    for (; j < %%bucket-limit; ++j) {");
    output_line(out, "        entry = &action_table[index][j];");
    output_line(out, "        if (entry->target_nfa_state == nfa_state && entry->dfa_state == dfa_state && entry->dfa_symbol == token)");
    output_line(out, "            break;");
    output_line(out, "    }");
//    output_line(out, "    printf(\"Found: %u,%u\\n\", entry->nfa_state, entry->actions);");
    output_line(out, "    if (j >= %%bucket-limit) {");
    // TODO: Handle error properly
    output_line(out, "        printf(\"Internal error!\\n\");");
    output_line(out, "        return 0;");
    output_line(out, "    }");
    output_line(out, "    return entry;");
    output_line(out, "}");
    output_line(out, "static void apply_actions(struct construct_state *state, uint32_t index, size_t start, size_t end) {");
    output_line(out, "    size_t offset = end;");
    output_line(out, "    for (uint32_t i = index; actions[i]; ++i) {");
    set_literal_substitution(out, "is-end-action", STRINGIFY(CONSTRUCT_IS_END_ACTION(actions[i])));
    output_line(out, "        if (%%is-end-action)");
    output_line(out, "            offset = start;");
    output_line(out, "        construct_action_apply(state, actions[i], offset);");
    output_line(out, "    }");
    output_line(out, "}");
    output_line(out, "static parsed_id build_parse_tree(struct bluebird_default_tokenizer *tokenizer, struct bluebird_token_run *run, struct bluebird_tree *tree) {");
    output_line(out, "    struct construct_state construct_state = { .info = tree };");
    output_line(out, "    struct state_stack stack = {0};");
    output_line(out, "    size_t whitespace = tokenizer->whitespace;");
    output_line(out, "    size_t offset = tokenizer->offset - whitespace;");
    if (gen->combined->root_rule_is_expression)
        output_line(out, "    construct_begin(&construct_state, offset, CONSTRUCT_EXPRESSION_ROOT);");
    else
        output_line(out, "    construct_begin(&construct_state, offset, CONSTRUCT_NORMAL_ROOT);");
    set_unsigned_number_substitution(out, "final-nfa-state",
     nfa_states[gen->combined->final_nfa_state]);
    output_line(out, "    %%state-type nfa_state = %%final-nfa-state;");
    output_line(out, "    while (run) {");
    output_line(out, "        uint16_t length_offset = run->lengths_size - 1;");
    output_line(out, "        uint16_t n = run->number_of_tokens;");
    output_line(out, "        for (uint16_t i = n - 1; i < n; i--) {");
    output_line(out, "            size_t end = offset;");
    output_line(out, "            size_t len = 0;");
    output_line(out, "            const struct action_table_entry *entry = action_table_lookup(nfa_state, run->states[i], run->tokens[i]);");
    output_line(out, "            if (!entry) {");
    // TODO: Handle error properly
    output_line(out, "                printf(\"Internal error!\\n\");");
    output_line(out, "                return 0;");
    output_line(out, "            }");
    set_unsigned_number_substitution(out, "number-of-tokens",
     gen->combined->number_of_tokens);
    output_line(out, "            if (entry->dfa_symbol < %%number-of-tokens)");
    output_line(out, "                len = decode_token_length(run, &length_offset, &offset);");
    output_line(out, "            else {");
    output_line(out, "                if (stack.depth >= stack.capacity) {");
    output_line(out, "                    if (!grow_state_stack(&stack))");
    output_line(out, "                        break;"); // TODO: Error handling?
    output_line(out, "                }");
    output_line(out, "                stack.states[stack.depth++] = entry->push_nfa_state;");
    output_line(out, "            }");
    output_line(out, "            apply_actions(&construct_state, entry->actions, end, end + whitespace);");
    set_unsigned_number_substitution(out, "bracket-start-state",
     gen->deterministic->bracket_automaton.start_state +
     gen->deterministic->automaton.number_of_states);
    output_line(out, "            if (entry->dfa_state == %%bracket-start-state) {");
    output_line(out, "                if (stack.depth == 0)");
    output_line(out, "                    break;"); // TODO: Error handling?
    output_line(out, "                nfa_state = stack.states[--stack.depth];");
    output_line(out, "            } else");
    output_line(out, "                nfa_state = entry->nfa_state;");
    output_line(out, "            whitespace = end - offset - len;");
    output_line(out, "        }");
    output_line(out, "        struct bluebird_token_run *old = run;");
    output_line(out, "        run = run->prev;");
    output_line(out, "        free(old);");
    output_line(out, "    }");
    output_line(out, "    const struct action_table_entry *entry = action_table_lookup(nfa_state, UINT32_MAX, UINT32_MAX);");
    output_line(out, "    if (!entry) {");
    // TODO: Handle error properly
    output_line(out, "        printf(\"Internal error!\\n\");");
    output_line(out, "        return 0;");
    output_line(out, "    }");
    output_line(out, "    apply_actions(&construct_state, entry->actions, offset, offset + whitespace);");
    // TODO: Free all remaining token runs here (or in the caller?).
    output_line(out, "    free(stack.states);");
    output_line(out, "    return construct_finish(&construct_state, offset);");
    output_line(out, "}");
}

static bool rule_is_named(struct rule *rule, const char *name)
{
    return rule->name_length == strlen(name) &&
     !memcmp(name, rule->name, rule->name_length);
}

static bool token_is(struct token *token, const char *name)
{
    return token->length == strlen(name) &&
     !memcmp(name, token->string, token->length);
}

static void output_indentation(struct generator_output *out, size_t indentation)
{
    for (int i = 0; i < indentation; ++i)
        output_string(out, "    ");
}

static int compare_tokens(const void *aa, const void *bb)
{
    const struct token *a = &((struct generated_token *)aa)->token;
    const struct token *b = &((struct generated_token *)bb)->token;
    size_t minlen = a->length < b->length ? a->length : b->length;
    int cmp = memcmp(a->string, b->string, minlen);
    if (cmp != 0)
        return cmp;
    if (a->length < b->length)
        return -1;
    if (a->length > b->length)
        return 1;
    return 0;
}
