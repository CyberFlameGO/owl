// This file was generated by the Owl parsing tool.
// Make sure to #define OWL_PARSER_IMPLEMENTATION somewhere so the parser
// is compiled properly.  Just two lines are enough -- a typical parser.c might
// look like:
//
//   #define OWL_PARSER_IMPLEMENTATION
//   #include "owl-parser.h"

#ifndef _OWL_PARSER_H_
#define _OWL_PARSER_H_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

// The owl_tree struct represents an entire parse tree.  Use the
// owl_tree_create_...() functions to create a tree, then call owl_tree_root()
// to get the root owl_ref.
struct owl_tree;

// Creates an owl_tree from a string.  The tree may directly reference pieces of
// the string -- you're responsible for keeping it around until
// owl_tree_destroy() is called.
struct owl_tree *owl_tree_create_from_string(const char *string);

// Creates an owl_tree by reading from a file.
struct owl_tree *owl_tree_create_from_file(FILE *file);

// Explicitly create a tree with particular options.
struct owl_tree_options {
    // Exactly one of string or file should be set.
    const char *string;
    FILE *file;
};
struct owl_tree *owl_tree_create_with_options(struct owl_tree_options options);

// Destroys an owl_tree, freeing its resources back to the system.
void owl_tree_destroy(struct owl_tree *);

// Prints a representation of the tree to standard output.
void owl_tree_print(struct owl_tree *);

// An owl_ref references a list of children in the parse tree.  Use the
// parsed_..._get() function corresponding to the element type to unpack the
// child into its appropriate parsed_... struct.
struct owl_ref {
    struct owl_tree *_tree;
    size_t _offset;
    uint32_t _type;
    bool empty;
};

// The owl_next function advances a ref to the next sibling element.
struct owl_ref owl_next(struct owl_ref);

// Tests two refs for equality.
bool owl_refs_equal(struct owl_ref a, struct owl_ref b);

// Returns the root owl_ref.
struct owl_ref owl_tree_root_ref(struct owl_tree *tree);

// As a shortcut, returns the parsed_grammar struct corresponding to the root ref.
struct parsed_grammar owl_tree_get_parsed_grammar(struct owl_tree *tree);

// The range of text corresponding to a tree element.
struct source_range {
    size_t start;
    size_t end;
};

enum owl_error {
    // No error -- everything's fine!
    ERROR_NONE,

    // The file passed to owl_tree_create_from_file was NULL.
    ERROR_INVALID_FILE,

    // The options passed to owl_tree_create_with_options weren't valid --
    // both file and string were specified at the same time or neither were.
    ERROR_INVALID_OPTIONS,

    // A piece of text couldn't be matched as a token.
    ERROR_INVALID_TOKEN,

    // The parser encountered an out-of-place token that doesn't fit the grammar.
    ERROR_UNEXPECTED_TOKEN,

    // The input is valid so far, but incomplete; more tokens could be added to
    // complete it.
    ERROR_MORE_INPUT_NEEDED,
};
// Returns an error code, or ERROR_NONE if there wasn't an error.
// The error_range parameter can be null.
enum owl_error owl_tree_get_error(struct owl_tree *tree, struct source_range *error_range);

enum parsed_type {
    PARSED_IDENT = 1,
    PARSED_CHOICE,
    PARSED_PARENS,
    PARSED_FLAT_OP,
    PARSED_LEFT_OP,
    PARSED_LITERAL,
    PARSED_INFIX_OP,
    PARSED_OPTIONAL,
    PARSED_RIGHT_OP,
    PARSED_BRACKETED,
    PARSED_PREFIX_OP,
    PARSED_POSTFIX_OP,
    PARSED_NONASSOC_OP,
    PARSED_ONE_OR_MORE,
    PARSED_ZERO_OR_MORE,
    PARSED_CONCATENATION,
};

struct parsed_grammar {
    struct source_range range;
    struct owl_ref rule;
    struct owl_ref comment_token;
    struct owl_ref custom_token;
};

struct parsed_rule {
    struct source_range range;
    struct owl_ref identifier;
    struct owl_ref body;
};

struct parsed_body {
    struct source_range range;
    struct owl_ref expr;
    struct owl_ref identifier;
    struct owl_ref operators;
};

struct parsed_operators {
    struct source_range range;
    struct owl_ref fixity;
    struct owl_ref operator;
};

struct parsed_fixity {
    struct source_range range;
    enum parsed_type type;
    struct owl_ref assoc;
};

struct parsed_assoc {
    struct source_range range;
    enum parsed_type type;
};

struct parsed_operator {
    struct source_range range;
    struct owl_ref expr;
    struct owl_ref identifier;
};

struct parsed_expr {
    struct source_range range;
    enum parsed_type type;
    struct owl_ref identifier;
    struct owl_ref exception;
    struct owl_ref rename;
    struct owl_ref string;
    struct owl_ref expr;
    struct owl_ref begin_token;
    struct owl_ref end_token;
    struct owl_ref operand;
};

struct parsed_comment_token {
    struct source_range range;
    struct owl_ref string;
    struct owl_ref comment_token_v1;
};

struct parsed_comment_token_v1 {
    struct source_range range;
    struct owl_ref string;
};

struct parsed_custom_token {
    struct source_range range;
    struct owl_ref identifier;
    struct owl_ref string;
};

struct parsed_identifier {
    struct source_range range;
    const char *identifier;
    size_t length;
};

struct parsed_number {
    struct source_range range;
    double number;
};

struct parsed_string {
    struct source_range range;
    const char *string;
    size_t length;
};

struct parsed_grammar parsed_grammar_get(struct owl_ref);
struct parsed_rule parsed_rule_get(struct owl_ref);
struct parsed_body parsed_body_get(struct owl_ref);
struct parsed_operators parsed_operators_get(struct owl_ref);
struct parsed_fixity parsed_fixity_get(struct owl_ref);
struct parsed_assoc parsed_assoc_get(struct owl_ref);
struct parsed_operator parsed_operator_get(struct owl_ref);
struct parsed_expr parsed_expr_get(struct owl_ref);
struct parsed_comment_token parsed_comment_token_get(struct owl_ref);
struct parsed_comment_token_v1 parsed_comment_token_v1_get(struct owl_ref);
struct parsed_custom_token parsed_custom_token_get(struct owl_ref);
struct parsed_identifier parsed_identifier_get(struct owl_ref);
struct parsed_number parsed_number_get(struct owl_ref);
struct parsed_string parsed_string_get(struct owl_ref);

#endif

#ifdef OWL_PARSER_IMPLEMENTATION
// Code implementing the parser.  This might get a bit messy!
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct owl_tree {
    const char *string;
    bool owns_string;
    uint8_t *parse_tree;
    size_t parse_tree_size;
    size_t next_offset;
    enum owl_error error;
    struct source_range error_range;
    size_t root_offset;
    size_t next_identifier_token_offset;
    size_t next_number_token_offset;
    size_t next_string_token_offset;
};
// Reserve 10 bytes for each entry (the maximum encoded size of a 64-bit value).
#define RESERVATION_AMOUNT 10
static inline uint64_t read_tree(size_t *offset, struct owl_tree *tree) {
    uint8_t *parse_tree = tree->parse_tree;
    size_t parse_tree_size = tree->parse_tree_size;
    size_t i = *offset;
    if (i + RESERVATION_AMOUNT >= parse_tree_size)
        return 0;
    uint64_t result = 0;
    int shift_amount = 0;
    while ((parse_tree[i] & 0x80) != 0 && shift_amount < 64) {
        result |= ((uint64_t)parse_tree[i] & 0x7f) << shift_amount;
        shift_amount += 7;
        i++;
    }
    result |= ((uint64_t)parse_tree[i] & 0x7f) << shift_amount;
    i++;
    *offset = i;
    return result;
}
static bool grow_tree(struct owl_tree *tree, size_t size)
{
    size_t n = tree->parse_tree_size;
    while (n < size || n < 4096)
        n = (n + 1) * 3 / 2;
    uint8_t *parse_tree = realloc(tree->parse_tree, n);
    if (!parse_tree)
        return false;
    tree->parse_tree_size = n;
    tree->parse_tree = parse_tree;
    return true;
}
static void write_tree(struct owl_tree *tree, uint64_t value)
{
    size_t reserved_size = tree->next_offset + RESERVATION_AMOUNT;
    if (tree->parse_tree_size <= reserved_size && !grow_tree(tree, reserved_size))
        abort();
    while (value >> 7 != 0) {
        tree->parse_tree[tree->next_offset++] = 0x80 | (value & 0x7f);
        value >>= 7;
    }
    tree->parse_tree[tree->next_offset++] = value & 0x7f;
}
struct parsed_grammar parsed_grammar_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 0) {
        return (struct parsed_grammar){
            .rule.empty = true,
            .comment_token.empty = true,
            .custom_token.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_grammar result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.rule._tree = ref._tree;
    result.rule._offset = read_tree(&offset, ref._tree);
    result.rule._type = 1;
    result.rule.empty = result.rule._offset == 0;
    result.comment_token._tree = ref._tree;
    result.comment_token._offset = read_tree(&offset, ref._tree);
    result.comment_token._type = 8;
    result.comment_token.empty = result.comment_token._offset == 0;
    result.custom_token._tree = ref._tree;
    result.custom_token._offset = read_tree(&offset, ref._tree);
    result.custom_token._type = 10;
    result.custom_token.empty = result.custom_token._offset == 0;
    return result;
}
struct parsed_rule parsed_rule_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 1) {
        return (struct parsed_rule){
            .identifier.empty = true,
            .body.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_rule result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 11;
    result.identifier.empty = result.identifier._offset == 0;
    result.body._tree = ref._tree;
    result.body._offset = read_tree(&offset, ref._tree);
    result.body._type = 2;
    result.body.empty = result.body._offset == 0;
    return result;
}
struct parsed_body parsed_body_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 2) {
        return (struct parsed_body){
            .expr.empty = true,
            .identifier.empty = true,
            .operators.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_body result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.expr._tree = ref._tree;
    result.expr._offset = read_tree(&offset, ref._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 11;
    result.identifier.empty = result.identifier._offset == 0;
    result.operators._tree = ref._tree;
    result.operators._offset = read_tree(&offset, ref._tree);
    result.operators._type = 3;
    result.operators.empty = result.operators._offset == 0;
    return result;
}
struct parsed_operators parsed_operators_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 3) {
        return (struct parsed_operators){
            .fixity.empty = true,
            .operator.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_operators result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.fixity._tree = ref._tree;
    result.fixity._offset = read_tree(&offset, ref._tree);
    result.fixity._type = 4;
    result.fixity.empty = result.fixity._offset == 0;
    result.operator._tree = ref._tree;
    result.operator._offset = read_tree(&offset, ref._tree);
    result.operator._type = 6;
    result.operator.empty = result.operator._offset == 0;
    return result;
}
struct parsed_fixity parsed_fixity_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 4) {
        return (struct parsed_fixity){
            .assoc.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_fixity result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = (enum parsed_type)read_tree(&offset, ref._tree),
    };
    result.assoc._tree = ref._tree;
    result.assoc._offset = read_tree(&offset, ref._tree);
    result.assoc._type = 5;
    result.assoc.empty = result.assoc._offset == 0;
    return result;
}
struct parsed_assoc parsed_assoc_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 5) {
        return (struct parsed_assoc){
        0
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_assoc result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = (enum parsed_type)read_tree(&offset, ref._tree),
    };
    return result;
}
struct parsed_operator parsed_operator_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 6) {
        return (struct parsed_operator){
            .expr.empty = true,
            .identifier.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_operator result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.expr._tree = ref._tree;
    result.expr._offset = read_tree(&offset, ref._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 11;
    result.identifier.empty = result.identifier._offset == 0;
    return result;
}
struct parsed_expr parsed_expr_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 7) {
        return (struct parsed_expr){
            .identifier.empty = true,
            .exception.empty = true,
            .rename.empty = true,
            .string.empty = true,
            .expr.empty = true,
            .begin_token.empty = true,
            .end_token.empty = true,
            .operand.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_expr result = {
        .range.start = start_location,
        .range.end = end_location,
        .type = (enum parsed_type)read_tree(&offset, ref._tree),
    };
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 11;
    result.identifier.empty = result.identifier._offset == 0;
    result.exception._tree = ref._tree;
    result.exception._offset = read_tree(&offset, ref._tree);
    result.exception._type = 11;
    result.exception.empty = result.exception._offset == 0;
    result.rename._tree = ref._tree;
    result.rename._offset = read_tree(&offset, ref._tree);
    result.rename._type = 11;
    result.rename.empty = result.rename._offset == 0;
    result.string._tree = ref._tree;
    result.string._offset = read_tree(&offset, ref._tree);
    result.string._type = 13;
    result.string.empty = result.string._offset == 0;
    result.expr._tree = ref._tree;
    result.expr._offset = read_tree(&offset, ref._tree);
    result.expr._type = 7;
    result.expr.empty = result.expr._offset == 0;
    result.begin_token._tree = ref._tree;
    result.begin_token._offset = read_tree(&offset, ref._tree);
    result.begin_token._type = 13;
    result.begin_token.empty = result.begin_token._offset == 0;
    result.end_token._tree = ref._tree;
    result.end_token._offset = read_tree(&offset, ref._tree);
    result.end_token._type = 13;
    result.end_token.empty = result.end_token._offset == 0;
    result.operand._tree = ref._tree;
    result.operand._offset = read_tree(&offset, ref._tree);
    result.operand._type = 7;
    result.operand.empty = result.operand._offset == 0;
    return result;
}
struct parsed_comment_token parsed_comment_token_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 8) {
        return (struct parsed_comment_token){
            .string.empty = true,
            .comment_token_v1.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_comment_token result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.string._tree = ref._tree;
    result.string._offset = read_tree(&offset, ref._tree);
    result.string._type = 13;
    result.string.empty = result.string._offset == 0;
    result.comment_token_v1._tree = ref._tree;
    result.comment_token_v1._offset = read_tree(&offset, ref._tree);
    result.comment_token_v1._type = 9;
    result.comment_token_v1.empty = result.comment_token_v1._offset == 0;
    return result;
}
struct parsed_comment_token_v1 parsed_comment_token_v1_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 9) {
        return (struct parsed_comment_token_v1){
            .string.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_comment_token_v1 result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.string._tree = ref._tree;
    result.string._offset = read_tree(&offset, ref._tree);
    result.string._type = 13;
    result.string.empty = result.string._offset == 0;
    return result;
}
struct parsed_custom_token parsed_custom_token_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 10) {
        return (struct parsed_custom_token){
            .identifier.empty = true,
            .string.empty = true,
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t start_location = read_tree(&offset, ref._tree);
    size_t end_location = start_location + read_tree(&offset, ref._tree);
    struct parsed_custom_token result = {
        .range.start = start_location,
        .range.end = end_location,
    };
    result.identifier._tree = ref._tree;
    result.identifier._offset = read_tree(&offset, ref._tree);
    result.identifier._type = 11;
    result.identifier.empty = result.identifier._offset == 0;
    result.string._tree = ref._tree;
    result.string._offset = read_tree(&offset, ref._tree);
    result.string._type = 13;
    result.string.empty = result.string._offset == 0;
    return result;
}
struct parsed_identifier parsed_identifier_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 11) {
        return (struct parsed_identifier){
        0
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t token_offset = read_tree(&offset, ref._tree);
    read_tree(&token_offset, ref._tree);
    size_t start_location = read_tree(&token_offset, ref._tree);
    size_t end_location = start_location + read_tree(&token_offset, ref._tree);
    struct parsed_identifier result = {
        .identifier = ref._tree->string + start_location,
        .length = end_location - start_location,
        .range.start = start_location,
        .range.end = end_location,
    };
    return result;
}
struct parsed_number parsed_number_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 12) {
        return (struct parsed_number){
        0
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t token_offset = read_tree(&offset, ref._tree);
    read_tree(&token_offset, ref._tree);
    size_t start_location = read_tree(&token_offset, ref._tree);
    size_t end_location = start_location + read_tree(&token_offset, ref._tree);
    struct parsed_number result = {
        .number = (union { double n; uint64_t v; }){ .v = read_tree(&token_offset, ref._tree) }.n,
        .range.start = start_location,
        .range.end = end_location,
    };
    return result;
}
struct parsed_string parsed_string_get(struct owl_ref ref) {
    if (ref.empty || ref._type != 13) {
        return (struct parsed_string){
        0
        };
    }
    size_t offset = ref._offset;
    read_tree(&offset, ref._tree); // Read and ignore the 'next offset' field.
    size_t token_offset = read_tree(&offset, ref._tree);
    read_tree(&token_offset, ref._tree);
    size_t start_location = read_tree(&token_offset, ref._tree);
    size_t end_location = start_location + read_tree(&token_offset, ref._tree);
    size_t string_offset = read_tree(&token_offset, ref._tree);
    const char *string = string_offset ?
     (const char *)ref._tree->parse_tree + string_offset : ref._tree->string + start_location + 1;
    size_t string_length = string_offset ?
     read_tree(&token_offset, ref._tree) : end_location - start_location - 2;
    struct parsed_string result = {
        .string = string,
        .length = string_length,
        .range.start = start_location,
        .range.end = end_location,
    };
    return result;
}
static size_t finish_node(uint32_t rule, uint32_t choice, size_t next_sibling, size_t *slots, size_t start_location, size_t end_location, void *info) {
    struct owl_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling ? offset - next_sibling : 0);
    write_tree(tree, start_location);
    write_tree(tree, end_location - start_location);
    switch (rule) {
    case 0: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        break;
    }
    case 1: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 2: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        break;
    }
    case 3: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 4: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_POSTFIX_OP);
            break;
        case 1:
            write_tree(tree, PARSED_PREFIX_OP);
            break;
        case 2:
            write_tree(tree, PARSED_INFIX_OP);
            break;
        }
        write_tree(tree, slots[0]);
        break;
    }
    case 5: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_FLAT_OP);
            break;
        case 1:
            write_tree(tree, PARSED_LEFT_OP);
            break;
        case 2:
            write_tree(tree, PARSED_RIGHT_OP);
            break;
        case 3:
            write_tree(tree, PARSED_NONASSOC_OP);
            break;
        }
        break;
    }
    case 6: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 7: {
        switch (choice) {
        case 0:
            write_tree(tree, PARSED_IDENT);
            break;
        case 1:
            write_tree(tree, PARSED_LITERAL);
            break;
        case 2:
            write_tree(tree, PARSED_PARENS);
            break;
        case 3:
            write_tree(tree, PARSED_BRACKETED);
            break;
        case 4:
            write_tree(tree, PARSED_ZERO_OR_MORE);
            break;
        case 5:
            write_tree(tree, PARSED_ONE_OR_MORE);
            break;
        case 6:
            write_tree(tree, PARSED_OPTIONAL);
            break;
        case 7:
            write_tree(tree, PARSED_CONCATENATION);
            break;
        case 8:
            write_tree(tree, PARSED_CHOICE);
            break;
        }
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        write_tree(tree, slots[2]);
        write_tree(tree, slots[3]);
        write_tree(tree, slots[4]);
        write_tree(tree, slots[5]);
        write_tree(tree, slots[6]);
        write_tree(tree, slots[7]);
        break;
    }
    case 8: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    case 9: {
        write_tree(tree, slots[0]);
        break;
    }
    case 10: {
        write_tree(tree, slots[0]);
        write_tree(tree, slots[1]);
        break;
    }
    default:
        break;
    }
    return offset;
}
static size_t finish_token(uint32_t rule, size_t next_sibling, void *info) {
    struct owl_tree *tree = info;
    size_t offset = tree->next_offset;
    write_tree(tree, next_sibling ? offset - next_sibling : 0);
    switch (rule) {
    case 11: {
        size_t offset = tree->next_identifier_token_offset;
        if (offset == 0)
            abort();
        write_tree(tree, offset);
        tree->next_identifier_token_offset = offset - read_tree(&offset, tree);
        break;
    }
    case 12: {
        size_t offset = tree->next_number_token_offset;
        if (offset == 0)
            abort();
        write_tree(tree, offset);
        tree->next_number_token_offset = offset - read_tree(&offset, tree);
        break;
    }
    case 13: {
        size_t offset = tree->next_string_token_offset;
        if (offset == 0)
            abort();
        write_tree(tree, offset);
        tree->next_string_token_offset = offset - read_tree(&offset, tree);
        break;
    }
    default:
        break;
    }
    return offset;
}
static void check_for_error(struct owl_tree *tree) {
    if (tree->error == ERROR_NONE)
        return;
    fprintf(stderr, "parse error: ");
    switch (tree->error) {
    case ERROR_INVALID_FILE:
        fprintf(stderr, "invalid file\n");
        break;
    case ERROR_INVALID_OPTIONS:
        fprintf(stderr, "invalid options\n");
        break;
    case ERROR_INVALID_TOKEN:
        fprintf(stderr, "invalid token '%.*s'\n", (int)(tree->error_range.end - tree->error_range.start), tree->string + tree->error_range.start);
        break;
    case ERROR_UNEXPECTED_TOKEN:
        fprintf(stderr, "unexpected token '%.*s'\n", (int)(tree->error_range.end - tree->error_range.start), tree->string + tree->error_range.start);
        break;
    case ERROR_MORE_INPUT_NEEDED:
        fprintf(stderr, "more input needed\n");
        break;
    default:
        break;
    }
    exit(-1);
}
static void parsed_grammar_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_rule_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_body_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_operators_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_fixity_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_assoc_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_operator_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_expr_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_comment_token_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_comment_token_v1_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_custom_token_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_identifier_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_string_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent);
static void parsed_grammar_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_grammar it = parsed_grammar_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("grammar");
        if (strcmp("grammar", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_rule_print(tree, it.rule, "rule", indent + 1);
        parsed_comment_token_print(tree, it.comment_token, "comment_token", indent + 1);
        parsed_custom_token_print(tree, it.custom_token, "custom_token", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_rule_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_rule it = parsed_rule_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("rule");
        if (strcmp("rule", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_body_print(tree, it.body, "body", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_body_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_body it = parsed_body_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("body");
        if (strcmp("body", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_operators_print(tree, it.operators, "operators", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_operators_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_operators it = parsed_operators_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operators");
        if (strcmp("operators", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_fixity_print(tree, it.fixity, "fixity", indent + 1);
        parsed_operator_print(tree, it.operator, "operator", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_fixity_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_fixity it = parsed_fixity_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("fixity");
        if (strcmp("fixity", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_POSTFIX_OP:
            printf(" : POSTFIX_OP");
            break;
        case PARSED_PREFIX_OP:
            printf(" : PREFIX_OP");
            break;
        case PARSED_INFIX_OP:
            printf(" : INFIX_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_assoc_print(tree, it.assoc, "assoc", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_assoc_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_assoc it = parsed_assoc_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("assoc");
        if (strcmp("assoc", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_FLAT_OP:
            printf(" : FLAT_OP");
            break;
        case PARSED_LEFT_OP:
            printf(" : LEFT_OP");
            break;
        case PARSED_RIGHT_OP:
            printf(" : RIGHT_OP");
            break;
        case PARSED_NONASSOC_OP:
            printf(" : NONASSOC_OP");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
static void parsed_operator_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_operator it = parsed_operator_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("operator");
        if (strcmp("operator", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_expr_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_expr it = parsed_expr_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("expr");
        if (strcmp("expr", slot_name))
            printf("@%s", slot_name);
        switch (it.type) {
        case PARSED_IDENT:
            printf(" : IDENT");
            break;
        case PARSED_LITERAL:
            printf(" : LITERAL");
            break;
        case PARSED_PARENS:
            printf(" : PARENS");
            break;
        case PARSED_BRACKETED:
            printf(" : BRACKETED");
            break;
        case PARSED_ZERO_OR_MORE:
            printf(" : ZERO_OR_MORE");
            break;
        case PARSED_ONE_OR_MORE:
            printf(" : ONE_OR_MORE");
            break;
        case PARSED_OPTIONAL:
            printf(" : OPTIONAL");
            break;
        case PARSED_CONCATENATION:
            printf(" : CONCATENATION");
            break;
        case PARSED_CHOICE:
            printf(" : CHOICE");
            break;
        default:
            break;
        }
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_identifier_print(tree, it.exception, "exception", indent + 1);
        parsed_identifier_print(tree, it.rename, "rename", indent + 1);
        parsed_string_print(tree, it.string, "string", indent + 1);
        parsed_expr_print(tree, it.expr, "expr", indent + 1);
        parsed_string_print(tree, it.begin_token, "begin_token", indent + 1);
        parsed_string_print(tree, it.end_token, "end_token", indent + 1);
        parsed_expr_print(tree, it.operand, "operand", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_comment_token_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_comment_token it = parsed_comment_token_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("comment_token");
        if (strcmp("comment_token", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_string_print(tree, it.string, "string", indent + 1);
        parsed_comment_token_v1_print(tree, it.comment_token_v1, "comment_token_v1", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_comment_token_v1_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_comment_token_v1 it = parsed_comment_token_v1_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("comment_token_v1");
        if (strcmp("comment_token_v1", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_string_print(tree, it.string, "string", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_custom_token_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_custom_token it = parsed_custom_token_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("custom_token");
        if (strcmp("custom_token", slot_name))
            printf("@%s", slot_name);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        parsed_identifier_print(tree, it.identifier, "identifier", indent + 1);
        parsed_string_print(tree, it.string, "string", indent + 1);
        ref = owl_next(ref);
    }
}
static void parsed_identifier_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_identifier it = parsed_identifier_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("identifier");
        if (strcmp("identifier", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.identifier);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
static void parsed_string_print(struct owl_tree *tree, struct owl_ref ref, const char *slot_name, int indent) {
    while (!ref.empty) {
        struct parsed_string it = parsed_string_get(ref);
        for (int i = 0; i < indent; ++i) printf("  ");
        printf("string");
        if (strcmp("string", slot_name))
            printf("@%s", slot_name);
        printf(" - %.*s", (int)it.length, it.string);
        printf(" (%zu - %zu)\n", it.range.start, it.range.end);
        ref = owl_next(ref);
    }
}
void owl_tree_print(struct owl_tree *tree) {
    check_for_error(tree);
    parsed_grammar_print(tree, owl_tree_root_ref(tree), "grammar", 0);
}
struct owl_ref owl_next(struct owl_ref ref) {
    if (ref.empty) return ref;
    size_t offset = ref._offset;
    size_t delta = read_tree(&ref._offset, ref._tree);
    return (struct owl_ref){
        ._tree = ref._tree,
        ._offset = offset - delta,
        ._type = ref._type,
        .empty = delta == 0,
    };
}
bool owl_refs_equal(struct owl_ref a, struct owl_ref b) {
    return a._tree == b._tree && a._offset == b._offset;
}
struct owl_ref owl_tree_root_ref(struct owl_tree *tree) {
    check_for_error(tree);
    return (struct owl_ref){
        ._tree = tree,
        ._offset = tree->root_offset,
        ._type = 0,
        .empty = tree->root_offset == 0,
    };
}
struct parsed_grammar owl_tree_get_parsed_grammar(struct owl_tree *tree) {
    check_for_error(tree);
    return parsed_grammar_get(owl_tree_root_ref(tree));
}
#define IGNORE_TOKEN_WRITE(...)
#define IGNORE_TOKEN_READ(...) (0)
#define CUSTOM_TOKEN_DATA(...)
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info);
static void write_identifier_token(size_t offset, size_t length, void *info) {
    struct owl_tree *tree = info;
    size_t token_offset = tree->next_offset;
    write_tree(tree, token_offset - tree->next_identifier_token_offset);
    write_tree(tree, offset);
    write_tree(tree, length);
    tree->next_identifier_token_offset = token_offset;
}
static void write_number_token(size_t offset, size_t length, double number, void *info) {
    struct owl_tree *tree = info;
    size_t token_offset = tree->next_offset;
    write_tree(tree, token_offset - tree->next_number_token_offset);
    write_tree(tree, offset);
    write_tree(tree, length);
    union { double n; uint64_t v; } u = { .n = number };
    write_tree(tree, u.v);
    tree->next_number_token_offset = token_offset;
}
static void write_string_token(size_t offset, size_t length, const char *string, size_t string_length, bool has_escapes, void *info) {
    struct owl_tree *tree = info;
    size_t string_offset = has_escapes ? (uint8_t *)string - tree->parse_tree : 0;
    size_t token_offset = tree->next_offset;
    write_tree(tree, token_offset - tree->next_string_token_offset);
    write_tree(tree, offset);
    write_tree(tree, length);
    if (string_offset) {
        write_tree(tree, string_offset);
        write_tree(tree, string_length);
    } else
        write_tree(tree, 0);
    tree->next_string_token_offset = token_offset;
}
static void *allocate_string_contents(size_t size, void *info) {
    struct owl_tree *tree = info;
    if (tree->next_offset + size > tree->parse_tree_size)
        grow_tree(tree, tree->next_offset + size);
    void *p = tree->parse_tree + tree->next_offset;
    tree->next_offset += size;
    return p;
}
struct owl_token_run {
    struct owl_token_run *prev;
    uint16_t number_of_tokens;
    uint16_t lengths_size;
    uint8_t lengths[4096 * 2];
    uint32_t tokens[4096];
    uint32_t states[4096];
};
struct owl_default_tokenizer {
    const char *text;
    size_t offset;
    size_t whitespace;
    uint32_t identifier_token;
    uint32_t number_token;
    uint32_t string_token;
    void *info;
};
static bool char_is_whitespace(char c) {
    switch (c) {
    case ' ':
    case '\t':
    case '\r':
    case '\n':
        return true;
    default:
        return false;
    }
}
static bool char_is_numeric(char c) {
    return c >= '0' && c <= '9';
}
static bool char_is_alphabetic(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}
static bool char_starts_identifier(char c) {
    return char_is_alphabetic(c) || c == '_';
}
static bool char_continues_identifier(char c, void *info) {
    if (true && c == '-') return true;
    return char_is_numeric(c) || char_starts_identifier(c);
}
static bool encode_length(struct owl_token_run *run, uint16_t *lengths_size, size_t length) {
    uint8_t mark = 0;
    while (*lengths_size < sizeof(run->lengths)) {
        run->lengths[*lengths_size] = mark | (length & 0x7f);
        mark = 0x80;
        length >>= 7;
        (*lengths_size)++;
        if (length == 0) return true;
    }
    return false;
}
static bool encode_token_length(struct owl_token_run *run, uint16_t *lengths_size, size_t length, size_t whitespace) {
    uint16_t size = *lengths_size;
    if (encode_length(run, lengths_size, length) && encode_length(run, lengths_size, whitespace)) return true;
    *lengths_size = size;
    return false;
}
static size_t decode_length(struct owl_token_run *run, uint16_t *length_offset) {
    size_t length = 0;
    while (*length_offset < sizeof(run->lengths)) {
        size_t l = run->lengths[(*length_offset)--];
        length <<= 7;
        length += l & 0x7f;
        if (!(l & 0x80)) return length;
    }
    abort();
}
static size_t decode_token_length(struct owl_token_run *run, uint16_t *length_offset, size_t *string_offset) {
    size_t whitespace = decode_length(run, length_offset);
    size_t length = decode_length(run, length_offset);
    *string_offset -= whitespace + length;
    return length;
}
static bool owl_default_tokenizer_advance(struct owl_default_tokenizer *tokenizer, struct owl_token_run **previous_run) {
    struct owl_token_run *run = malloc(sizeof(struct owl_token_run));
    if (!run) return false;
    uint16_t number_of_tokens = 0;
    uint16_t lengths_size = 0;
    const char *text = tokenizer->text;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset;
    while (number_of_tokens < 4096) {
        char c = text[offset];
        if (c == '\0') break;
        if (char_is_whitespace(c)) {
            whitespace++;
            offset++;
            continue;
        }
        uint32_t token = -1;
        CUSTOM_TOKEN_DATA(custom_data);
        bool is_token = false;
        bool end_token = false;
        bool custom_token = false;
        bool comment = false;
        bool has_escapes = false;
        size_t token_length = read_keyword_token(&token, &end_token, text + offset, tokenizer->info);
        if (token_length > 0) {
            is_token = true;
            if (token == 4294967295U) comment = true;
        }
        double number = 0;
        if (IGNORE_TOKEN_READ(&token, &token_length, text + offset, &custom_data, tokenizer->info)) {
            is_token = true;
            custom_token = true;
            end_token = false;
            comment = false;
        }
        else if (char_is_numeric(c) || (c == '.' && char_is_numeric(text[offset + 1]))) {
            const char *start = (const char *)text + offset;
            char *rest = 0;
            number = strtod(start, &rest);
            if (rest > start && rest - start > token_length) {
                token_length = rest - start;
                is_token = true;
                end_token = false;
                comment = false;
                token = 24;
            }
        }
        else if (c == '\'' || c == '"') {
            size_t string_offset = offset + 1;
            while (text[string_offset] != '\0') {
                if (text[string_offset] == c) {
                    token_length = string_offset + 1 - offset;
                    is_token = true;
                    end_token = false;
                    comment = false;
                    token = 25;
                    break;
                }
                if (text[string_offset] == '\\') {
                    has_escapes = true;
                    string_offset++;
                    if (text[string_offset] == '\0') break;
                }
                string_offset++;
            }
        }
        else if (char_starts_identifier(c)) {
            size_t identifier_offset = offset + 1;
            while (char_continues_identifier(text[identifier_offset], tokenizer->info)) identifier_offset++;
            if (identifier_offset - offset > token_length) {
                token_length = identifier_offset - offset;
                is_token = true;
                end_token = false;
                comment = false;
                token = 23;
            }
        }
        if (comment) {
            while (text[offset] != '\0' && text[offset] != '\n') {
                whitespace++;
                offset++;
            }
            continue;
        }
        else if (!is_token || token == 4294967295U) {
            tokenizer->offset = offset;
            tokenizer->whitespace = whitespace;
            free(run);
            return false;
        }
        if (end_token && number_of_tokens + 1 >= 4096) break;
        if (!encode_token_length(run, &lengths_size, token_length, whitespace)) break;
        if (token == 23) {
            write_identifier_token(offset, token_length, tokenizer->info);
        }
        else if (token == 24) {
            write_number_token(offset, token_length, number, tokenizer->info);
        }
        else if (token == 25) {
            size_t content_offset = offset + 1;
            size_t content_length = token_length - 2;
            const char *string = text + content_offset;
            size_t string_length = content_length;
            if (has_escapes) {
                for (size_t i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') {
                        string_length--;
                        i++;
                    }
                }
                char *unescaped = allocate_string_contents(string_length, tokenizer->info);
                size_t j = 0;
                for (size_t i = 0;
                i < content_length;
                ++i) {
                    if (text[content_offset + i] == '\\') i++;
                    unescaped[j++] = text[content_offset + i];
                }
                string = unescaped;
            }
            write_string_token(offset, token_length, string, string_length, has_escapes, tokenizer->info);
        }
        else if (custom_token) {
            IGNORE_TOKEN_WRITE(offset, token_length, token, custom_data, tokenizer->info);
        }
        run->tokens[number_of_tokens] = token;
        whitespace = 0;
        number_of_tokens++;
        offset += token_length;
        if (end_token) {
            assert(number_of_tokens < 4096);
            run->tokens[number_of_tokens] = 4294967295U;
            number_of_tokens++;
        }
    }
    if (number_of_tokens == 0) {
        tokenizer->offset = offset;
        tokenizer->whitespace = whitespace;
        free(run);
        return false;
    }
    tokenizer->offset = offset;
    tokenizer->whitespace = whitespace;
    run->prev = *previous_run;
    run->number_of_tokens = number_of_tokens;
    run->lengths_size = lengths_size;
    *previous_run = run;
    return true;
}
static void find_token_range(struct owl_default_tokenizer *tokenizer, struct owl_token_run *run, uint16_t index, size_t *start, size_t *end) {
    size_t offset = tokenizer->offset - tokenizer->whitespace;
    size_t last_offset = offset;
    size_t len = 0;
    uint16_t length_offset = run->lengths_size - 1;
    for (uint16_t j = index;
    j < run->number_of_tokens;
    ++j) {
        if (run->tokens[j] == 4294967295U) continue;
        last_offset = offset;
        len = decode_token_length(run, &length_offset, &offset);
    }
    *start = last_offset - len;
    *end = last_offset;
}
static void estimate_next_token_range(struct owl_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset;
    size_t i = tokenizer->offset + 1;
    while (tokenizer->text[i] != '\0' && !char_is_whitespace(tokenizer->text[i]) && !char_continues_identifier(tokenizer->text[i], tokenizer->info)) i++;
    *end = i;
}
static void find_end_range(struct owl_default_tokenizer *tokenizer, size_t *start, size_t *end) {
    *start = tokenizer->offset - tokenizer->whitespace - 1;
    *end = tokenizer->offset - tokenizer->whitespace;
    if (*start > *end) {
        *start = *end;
        *end += 1;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context);
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context);
static size_t number_of_slots_lookup(uint32_t rule, void *context);
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context);
enum construct_fixity_associativity {
CONSTRUCT_PREFIX, CONSTRUCT_POSTFIX, CONSTRUCT_INFIX_LEFT, CONSTRUCT_INFIX_RIGHT, CONSTRUCT_INFIX_FLAT, };
struct construct_node {
    struct construct_node *next;
    size_t number_of_slots;
    size_t *slots;
    uint32_t rule;
    uint16_t slot_index;
    uint16_t choice_index;
    enum construct_fixity_associativity fixity_associativity;
    int precedence;
    size_t start_location;
    size_t end_location;
};
struct construct_expression {
    struct construct_expression *parent;
    struct construct_node *first_operator;
    struct construct_node *first_value;
    uint32_t operand_slot_index;
    uint32_t left_slot_index;
    uint32_t right_slot_index;
    uint32_t rule;
    uint16_t slot_index;
};
enum construct_root_type {
CONSTRUCT_NORMAL_ROOT, CONSTRUCT_EXPRESSION_ROOT, };
struct construct_state {
    enum construct_root_type root_type;
    struct construct_node *under_construction;
    struct construct_expression *current_expression;
    struct construct_node *node_freelist;
    struct construct_expression *expression_freelist;
    void *info;
};
static struct construct_node *construct_node_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_node *node;
    size_t number_of_slots = number_of_slots_lookup(rule, s->info);
    if (s->node_freelist) {
        node = s->node_freelist;
        s->node_freelist = node->next;
        size_t *slots = node->slots;
        if (number_of_slots > node->number_of_slots) {
            slots = realloc(slots, number_of_slots * sizeof(size_t));
            if (!slots) abort();
        }
        memset(node, 0, sizeof(struct construct_node));
        memset(slots, 0, number_of_slots * sizeof(size_t));
        node->slots = slots;
    }
    else {
        node = calloc(1, sizeof(struct construct_node));
        if (!node) abort();
        node->slots = calloc(number_of_slots, sizeof(size_t));
        if (!node->slots) abort();
    }
    node->rule = rule;
    node->number_of_slots = number_of_slots;
    return node;
}
static struct construct_expression *construct_expression_alloc(struct construct_state *s, uint32_t rule) {
    struct construct_expression *expr;
    if (s->expression_freelist) {
        expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        memset(expr, 0, sizeof(struct construct_expression));
    }
    else {
        expr = calloc(1, sizeof(struct construct_expression));
        if (!expr) abort();
    }
    (left_right_operand_slots_lookup(rule, &(expr->left_slot_index), &(expr->right_slot_index), &(expr->operand_slot_index), s->info));
    expr->rule = rule;
    return expr;
}
static void construct_node_free(struct construct_state *state, struct construct_node *node) {
    node->next = state->node_freelist;
    state->node_freelist = node;
}
static void construct_expression_free(struct construct_state *state, struct construct_expression *expr) {
    expr->parent = state->expression_freelist;
    state->expression_freelist = expr;
}
static bool construct_expression_should_reduce(struct construct_state *s, struct construct_expression *expr, struct construct_node *node) {
    if (node->fixity_associativity == CONSTRUCT_POSTFIX) return false;
    struct construct_node *top = expr->first_operator;
    if (!top) return false;
    return node->precedence < top->precedence || (node->precedence == top->precedence && node->fixity_associativity == CONSTRUCT_INFIX_RIGHT);
}
static void construct_expression_reduce(struct construct_state *s, struct construct_expression *expr) {
    struct construct_node *op = expr->first_operator;
    if (op->fixity_associativity == CONSTRUCT_INFIX_FLAT) {
        struct construct_node *first_value = expr->first_value;
        struct construct_node *last_value = first_value;
        struct construct_node *last_operator = op;
        size_t operand = op->slots[expr->operand_slot_index];
        struct construct_node *combined_op = construct_node_alloc(s, op->rule);
        combined_op->choice_index = op->choice_index;
        combined_op->slot_index = op->slot_index;
        combined_op->fixity_associativity = op->fixity_associativity;
        combined_op->precedence = op->precedence;
        struct construct_node *reversed_values = 0;
        while (last_operator && last_operator->choice_index == op->choice_index) {
            struct construct_node *next_op = last_operator->next;
            construct_node_free(s, last_operator);
            last_operator = next_op;
            assert(last_value);
            struct construct_node *next_value = last_value->next;
            last_value->next = reversed_values;
            reversed_values = last_value;
            last_value = next_value;
        }
        combined_op->start_location = first_value->start_location;
        combined_op->end_location = last_value->end_location;
        assert(last_value);
        operand = (finish_node((last_value)->rule, (last_value)->choice_index, operand, (last_value)->slots, (last_value)->start_location, (last_value)->end_location, s->info));
        combined_op->next = last_value->next;
        construct_node_free(s, last_value);
        while (reversed_values) {
            operand = (finish_node((reversed_values)->rule, (reversed_values)->choice_index, operand, (reversed_values)->slots, (reversed_values)->start_location, (reversed_values)->end_location, s->info));
            struct construct_node *next_value = reversed_values->next;
            construct_node_free(s, reversed_values);
            reversed_values = next_value;
        }
        expr->first_operator = last_operator;
        expr->first_value = combined_op;
        combined_op->slots[expr->operand_slot_index] = operand;
    }
    else if (op->fixity_associativity == CONSTRUCT_INFIX_LEFT || op->fixity_associativity == CONSTRUCT_INFIX_RIGHT) {
        expr->first_operator = op->next;
        struct construct_node *left = expr->first_value;
        struct construct_node *right = left->next;
        op->next = right->next;
        expr->first_value = op;
        op->start_location = left->start_location;
        op->end_location = right->end_location;
        op->slots[expr->left_slot_index] = (finish_node((left)->rule, (left)->choice_index, op->slots[expr->left_slot_index], (left)->slots, (left)->start_location, (left)->end_location, s->info));
        op->slots[expr->right_slot_index] = (finish_node((right)->rule, (right)->choice_index, op->slots[expr->right_slot_index], (right)->slots, (right)->start_location, (right)->end_location, s->info));
        construct_node_free(s, left);
        construct_node_free(s, right);
    }
    else {
        expr->first_operator = op->next;
        struct construct_node *value = expr->first_value;
        op->next = value->next;
        expr->first_value = op;
        if (value->start_location < op->start_location) op->start_location = value->start_location;
        if (value->end_location > op->end_location) op->end_location = value->end_location;
        op->slots[expr->operand_slot_index] = (finish_node((value)->rule, (value)->choice_index, op->slots[expr->operand_slot_index], (value)->slots, (value)->start_location, (value)->end_location, s->info));
        construct_node_free(s, value);
    }
}
static void construct_begin(struct construct_state *s, size_t offset, enum construct_root_type type) {
    s->root_type = type;
    uint32_t r = 0;
    if (type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = construct_expression_alloc(s, r);
        expr->parent = s->current_expression;
        s->current_expression = expr;
    }
    else {
        struct construct_node *node = construct_node_alloc(s, r);
        node->next = s->under_construction;
        node->end_location = offset;
        s->under_construction = node;
    }
}
static size_t construct_finish(struct construct_state *s, size_t offset) {
    size_t finished = 0;
    if (s->root_type == CONSTRUCT_EXPRESSION_ROOT) {
        struct construct_expression *expr = s->current_expression;
        s->current_expression = expr->parent;
        while (expr->first_operator) construct_expression_reduce(s, expr);
        struct construct_node *node = expr->first_value;
        if (node) {
            finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            assert(node->next == 0);
            construct_node_free(s, node);
        }
        construct_expression_free(s, expr);
    }
    else {
        struct construct_node *node = s->under_construction;
        s->under_construction = node->next;
        node->start_location = offset;
        finished = (finish_node((node)->rule, (node)->choice_index, 0, (node)->slots, (node)->start_location, (node)->end_location, s->info));
        construct_node_free(s, node);
    }
    while (s->node_freelist) {
        struct construct_node *node = s->node_freelist;
        s->node_freelist = node->next;
        free(node->slots);
        free(node);
    }
    while (s->expression_freelist) {
        struct construct_expression *expr = s->expression_freelist;
        s->expression_freelist = expr->parent;
        free(expr);
    }
    return finished;
}
static void construct_action_apply(struct construct_state *s, uint16_t action, size_t offset) {
    switch ((((action) >> 12) & 0xf)) {
    case 8:
        {
            struct construct_node *node = construct_node_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            node->next = s->under_construction;
            node->slot_index = ((action) & 0xfff);
            node->end_location = offset;
            s->under_construction = node;
            break;
        }
    case 9:
        {
            struct construct_expression *expr = construct_expression_alloc(s, rule_lookup(s->under_construction->rule, ((action) & 0xfff), s->info));
            expr->parent = s->current_expression;
            s->current_expression = expr;
            expr->slot_index = ((action) & 0xfff);
            break;
        }
    case 1:
        {
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            size_t *finished;
            finished = &s->under_construction->slots[node->slot_index];
            *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
            construct_node_free(s, node);
            break;
        }
    case 2:
        {
            struct construct_expression *expr = s->current_expression;
            s->current_expression = expr->parent;
            while (expr->first_operator) construct_expression_reduce(s, expr);
            size_t *finished;
            finished = &s->under_construction->slots[expr->slot_index];
            struct construct_node *node = expr->first_value;
            if (node) {
                *finished = (finish_node((node)->rule, (node)->choice_index, *finished, (node)->slots, (node)->start_location, (node)->end_location, s->info));
                assert(node->next == 0);
                construct_node_free(s, node);
            }
            construct_expression_free(s, expr);
            break;
        }
    case 3:
        s->under_construction->choice_index = ((action) & 0xfff);
        break;
    case 4:
        {
            uint16_t slot = ((action) & 0xfff);
            size_t *finished = &s->under_construction->slots[slot];
            *finished = finish_token(rule_lookup(s->under_construction->rule, slot, s->info), *finished, s->info);
            break;
        }
    case 10:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 11:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = construct_node_alloc(s, expr->rule);
            node->choice_index = ((action) & 0xfff);
            node->end_location = offset;
            node->rule = expr->rule;
            enum construct_fixity_associativity fixity_associativity = 0;
            int precedence = 0;
            do {
                int local = 0;
                fixity_associativity_precedence_lookup(&local, &precedence, expr->rule, ((action) & 0xfff), s->info);
                fixity_associativity = local;
            }
            while (0);
            node->fixity_associativity = fixity_associativity;
            node->precedence = precedence;
            node->next = s->under_construction;
            s->under_construction = node;
            break;
        }
    case 5:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            node->next = expr->first_value;
            expr->first_value = node;
            break;
        }
    case 6:
        {
            struct construct_expression *expr = s->current_expression;
            struct construct_node *node = s->under_construction;
            node->start_location = offset;
            s->under_construction = node->next;
            while (construct_expression_should_reduce(s, expr, node)) construct_expression_reduce(s, expr);
            node->next = expr->first_operator;
            expr->first_operator = node;
            if (node->fixity_associativity == CONSTRUCT_PREFIX) construct_expression_reduce(s, expr);
            break;
        }
    }
}

struct fill_run_continuation;
struct fill_run_state {
    uint32_t state;
    uint32_t reachability_mask[1];
    struct fill_run_continuation *cont;
};
struct fill_run_continuation {
    struct fill_run_state *stack;
    size_t top_index;
    size_t capacity;
    int error;
};
static void bracket_entry_state(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index, uint32_t mask0);
static void (*state_funcs[97])(struct owl_token_run *, struct fill_run_state *, uint16_t);
static void state_func_75(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(0 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    default: top->cont->error = 1; return;
    }
}
static void state_func_4(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 5; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_16(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 19; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_32(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 35; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_55(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 58; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_17(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 18; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_19(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 20; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_10(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 21; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_33(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 34; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_87(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    if (top->cont->top_index == 0) {
        top->cont->error = 1;
        return;
    }
    top->cont->top_index--;
    top--;
    run->tokens[token_index] = 26;
    run->states[token_index] = top->state;
    state_funcs[top->state](run, top, token_index);
    return;
}
static void state_func_77(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    if (top->cont->top_index == 0) {
        top->cont->error = 1;
        return;
    }
    top->cont->top_index--;
    top--;
    run->tokens[token_index] = 27;
    run->states[token_index] = top->state;
    state_funcs[top->state](run, top, token_index);
    return;
}
static void state_func_35(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 36; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_48(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 53; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_56(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 57; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_58(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 59; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_3(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 60; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_2(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 25: top->state = 62; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_1(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 25: top->state = 63; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_92(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 95; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_93(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 94; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_95(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 96; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_78(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 81; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_79(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 80; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_81(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 82; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_66(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 25: top->state = 67; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_64(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(3 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 12: top->state = 65; return;
    case 14: top->state = 66; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_22(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 3: top->state = 37; return;
    case 4: top->state = 38; return;
    case 5: top->state = 39; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_39(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 6: top->state = 40; return;
    case 7: top->state = 41; return;
    case 8: top->state = 42; return;
    case 9: top->state = 43; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_63(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 20: top->state = 1; return;
    case 21: top->state = 2; return;
    case 22: top->state = 3; return;
    case 23: top->state = 4; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_14(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 6; return;
    case 25: top->state = 7; return;
    case 26: top->state = 8; return;
    case 27: top->state = 9; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_30(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 31; return;
    case 25: top->state = 24; return;
    case 26: top->state = 25; return;
    case 27: top->state = 26; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_42(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 44; return;
    case 25: top->state = 45; return;
    case 26: top->state = 46; return;
    case 27: top->state = 47; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_91(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 83; return;
    case 25: top->state = 84; return;
    case 26: top->state = 85; return;
    case 27: top->state = 86; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_67(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 23: top->state = 68; return;
    case 25: top->state = 69; return;
    case 26: top->state = 70; return;
    case 27: top->state = 71; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_61(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 20: top->state = 1; return;
    case 21: top->state = 2; return;
    case 22: top->state = 3; return;
    case 23: top->state = 4; return;
    case 25: top->state = 61; return;
    default: top->cont->error = 1; return;
    }
}
static void state_func_21(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 2: top->state = 22; return;
    case 20: top->state = 1; return;
    case 21: top->state = 2; return;
    case 22: top->state = 3; return;
    case 23: top->state = 23; return;
    case 25: top->state = 24; return;
    case 26: top->state = 25; return;
    case 27: top->state = 26; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_53(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 2: top->state = 22; return;
    case 20: top->state = 1; return;
    case 21: top->state = 2; return;
    case 22: top->state = 3; return;
    case 23: top->state = 54; return;
    case 25: top->state = 45; return;
    case 26: top->state = 46; return;
    case 27: top->state = 47; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_70(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 16: top->state = 72; return;
    case 17: top->state = 73; return;
    case 18: top->state = 74; return;
    case 19: top->state = 75; return;
    case 23: top->state = 68; return;
    case 25: top->state = 76; return;
    case 26: top->state = 70; return;
    case 27: top->state = 71; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_24(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 10; return;
    case 16: top->state = 27; return;
    case 17: top->state = 28; return;
    case 18: top->state = 29; return;
    case 19: top->state = 30; return;
    case 23: top->state = 31; return;
    case 25: top->state = 24; return;
    case 26: top->state = 25; return;
    case 27: top->state = 26; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_57(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 48; return;
    case 16: top->state = 49; return;
    case 17: top->state = 50; return;
    case 18: top->state = 51; return;
    case 19: top->state = 52; return;
    case 23: top->state = 44; return;
    case 25: top->state = 45; return;
    case 26: top->state = 46; return;
    case 27: top->state = 47; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_88(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 13: top->state = 87; return;
    case 16: top->state = 88; return;
    case 17: top->state = 89; return;
    case 18: top->state = 90; return;
    case 19: top->state = 91; return;
    case 23: top->state = 83; return;
    case 25: top->state = 84; return;
    case 26: top->state = 85; return;
    case 27: top->state = 86; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_76(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 15: top->state = 77; return;
    case 16: top->state = 72; return;
    case 17: top->state = 73; return;
    case 18: top->state = 74; return;
    case 19: top->state = 75; return;
    case 23: top->state = 68; return;
    case 25: top->state = 76; return;
    case 26: top->state = 70; return;
    case 27: top->state = 71; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_82(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(2 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 10: top->state = 78; return;
    case 11: top->state = 79; return;
    case 16: top->state = 72; return;
    case 17: top->state = 73; return;
    case 18: top->state = 74; return;
    case 19: top->state = 75; return;
    case 23: top->state = 68; return;
    case 25: top->state = 76; return;
    case 26: top->state = 70; return;
    case 27: top->state = 71; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_31(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 10; return;
    case 10: top->state = 32; return;
    case 11: top->state = 33; return;
    case 16: top->state = 27; return;
    case 17: top->state = 28; return;
    case 18: top->state = 29; return;
    case 19: top->state = 30; return;
    case 23: top->state = 31; return;
    case 25: top->state = 24; return;
    case 26: top->state = 25; return;
    case 27: top->state = 26; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_44(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 48; return;
    case 10: top->state = 55; return;
    case 11: top->state = 56; return;
    case 16: top->state = 49; return;
    case 17: top->state = 50; return;
    case 18: top->state = 51; return;
    case 19: top->state = 52; return;
    case 23: top->state = 44; return;
    case 25: top->state = 45; return;
    case 26: top->state = 46; return;
    case 27: top->state = 47; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_96(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    if (!(1 & top->reachability_mask[0])) {
        top->cont->error = -1;
        return;
    }
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 10: top->state = 92; return;
    case 11: top->state = 93; return;
    case 13: top->state = 87; return;
    case 16: top->state = 88; return;
    case 17: top->state = 89; return;
    case 18: top->state = 90; return;
    case 19: top->state = 91; return;
    case 23: top->state = 83; return;
    case 25: top->state = 84; return;
    case 26: top->state = 85; return;
    case 27: top->state = 86; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_23(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 5; return;
    case 1: top->state = 10; return;
    case 10: top->state = 32; return;
    case 11: top->state = 33; return;
    case 16: top->state = 27; return;
    case 17: top->state = 28; return;
    case 18: top->state = 29; return;
    case 19: top->state = 30; return;
    case 23: top->state = 31; return;
    case 25: top->state = 24; return;
    case 26: top->state = 25; return;
    case 27: top->state = 26; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_54(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 5; return;
    case 1: top->state = 48; return;
    case 10: top->state = 55; return;
    case 11: top->state = 56; return;
    case 16: top->state = 49; return;
    case 17: top->state = 50; return;
    case 18: top->state = 51; return;
    case 19: top->state = 52; return;
    case 23: top->state = 44; return;
    case 25: top->state = 45; return;
    case 26: top->state = 46; return;
    case 27: top->state = 47; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_11(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 10; return;
    case 16: top->state = 11; return;
    case 17: top->state = 12; return;
    case 18: top->state = 13; return;
    case 19: top->state = 14; return;
    case 20: top->state = 1; return;
    case 21: top->state = 2; return;
    case 22: top->state = 3; return;
    case 23: top->state = 15; return;
    case 25: top->state = 7; return;
    case 26: top->state = 8; return;
    case 27: top->state = 9; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_20(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 1: top->state = 10; return;
    case 10: top->state = 16; return;
    case 11: top->state = 17; return;
    case 16: top->state = 11; return;
    case 17: top->state = 12; return;
    case 18: top->state = 13; return;
    case 19: top->state = 14; return;
    case 20: top->state = 1; return;
    case 21: top->state = 2; return;
    case 22: top->state = 3; return;
    case 23: top->state = 15; return;
    case 25: top->state = 7; return;
    case 26: top->state = 8; return;
    case 27: top->state = 9; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void state_func_15(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index) {
    uint32_t token = run->tokens[token_index];
    switch (token) {
    case 0: top->state = 5; return;
    case 1: top->state = 10; return;
    case 10: top->state = 16; return;
    case 11: top->state = 17; return;
    case 16: top->state = 11; return;
    case 17: top->state = 12; return;
    case 18: top->state = 13; return;
    case 19: top->state = 14; return;
    case 20: top->state = 1; return;
    case 21: top->state = 2; return;
    case 22: top->state = 3; return;
    case 23: top->state = 15; return;
    case 25: top->state = 7; return;
    case 26: top->state = 8; return;
    case 27: top->state = 9; return;
    default:
        bracket_entry_state(run, top, token_index, 3);
        return;
    }
}
static void (*state_funcs[97])(struct owl_token_run *, struct fill_run_state *, uint16_t) = {
    state_func_63, state_func_1, state_func_2, state_func_3,
    state_func_4, state_func_14, state_func_20, state_func_11,
    state_func_11, state_func_11, state_func_10, state_func_11,
    state_func_11, state_func_11, state_func_14, state_func_15,
    state_func_16, state_func_17, state_func_11, state_func_19,
    state_func_20, state_func_21, state_func_22, state_func_23,
    state_func_24, state_func_24, state_func_24, state_func_24,
    state_func_24, state_func_24, state_func_30, state_func_31,
    state_func_32, state_func_33, state_func_24, state_func_35,
    state_func_31, state_func_42, state_func_42, state_func_39,
    state_func_42, state_func_42, state_func_42, state_func_42,
    state_func_44, state_func_57, state_func_57, state_func_57,
    state_func_48, state_func_57, state_func_57, state_func_57,
    state_func_42, state_func_53, state_func_54, state_func_55,
    state_func_56, state_func_57, state_func_58, state_func_44,
    state_func_61, state_func_61, state_func_63, state_func_63,
    state_func_64, state_func_91, state_func_66, state_func_67,
    state_func_82, state_func_76, state_func_70, state_func_70,
    state_func_70, state_func_70, state_func_70, state_func_75,
    state_func_76, state_func_77, state_func_78, state_func_79,
    state_func_70, state_func_81, state_func_82, state_func_96,
    state_func_88, state_func_88, state_func_88, state_func_87,
    state_func_88, state_func_88, state_func_88, state_func_91,
    state_func_92, state_func_93, state_func_88, state_func_95,
    state_func_96,};
static void bracket_entry_state(struct owl_token_run *run, struct fill_run_state *top, uint16_t token_index, uint32_t mask0) {
    struct fill_run_continuation *cont = top->cont;
    cont->top_index++;
    if (cont->top_index >= cont->capacity) {
        size_t new_capacity = (cont->capacity + 2) * 3 / 2;
        if (new_capacity <= cont->capacity)
            abort();
        struct fill_run_state *new_states = realloc(cont->stack, new_capacity * sizeof(struct fill_run_state));
        if (!new_states)
            abort();
        cont->stack = new_states;
        cont->capacity = new_capacity;
        top = &cont->stack[cont->top_index];
    } else
        top++;
    top->cont = cont;
    top->reachability_mask[0] = mask0;
    run->states[token_index] = 64;
    state_func_64(run, top, token_index);
    if (top->cont->error == -1)
        top->cont->error = 1;
}
static bool fill_run_states(struct owl_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index);
static size_t build_parse_tree(struct owl_default_tokenizer *, struct owl_token_run *, struct owl_tree *);

static struct owl_tree *owl_tree_create_empty(void) {
    return calloc(1, sizeof(struct owl_tree));
}

static void free_token_runs(struct owl_token_run **run) {
    while (*run) {
        struct owl_token_run *prev = (*run)->prev;
        free(*run);
        *run = prev;
    }
}
static void parse_string(struct owl_tree *tree, const char *string) {
    tree->string = string;
    tree->next_offset = 1;
    struct owl_default_tokenizer tokenizer = {
        .text = string,
        .info = tree,
    };
    struct owl_token_run *token_run = 0;
    struct fill_run_continuation c = {
        .capacity = 8,
        .top_index = 0,
    };
    c.stack = calloc(c.capacity, sizeof(struct fill_run_state));
    c.stack[0].state = 0;
    c.stack[0].cont = &c;
    uint16_t failing_index = 0;
    while (owl_default_tokenizer_advance(&tokenizer, &token_run)) {
        if (!fill_run_states(token_run, &c, &failing_index)) {
            free(c.stack);
            tree->error = ERROR_UNEXPECTED_TOKEN;
            find_token_range(&tokenizer, token_run, failing_index, &tree->error_range.start, &tree->error_range.end);
            free_token_runs(&token_run);
            return;
        }
    }
    struct fill_run_state top = c.stack[c.top_index];
    free(c.stack);
    if (string[tokenizer.offset] != '\0') {
        tree->error = ERROR_INVALID_TOKEN;
        estimate_next_token_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        free_token_runs(&token_run);
        return;
    }
    switch (top.state) {
    case 0:
    case 6:
    case 7:
    case 8:
    case 9:
    case 11:
    case 12:
    case 13:
    case 15:
    case 18:
    case 20:
    case 21:
    case 53:
    case 60:
    case 61:
    case 62:
    case 63:
        break;
    default:
        tree->error = ERROR_MORE_INPUT_NEEDED;
        find_end_range(&tokenizer, &tree->error_range.start, &tree->error_range.end);
        free_token_runs(&token_run);
        return;
    }
    tree->root_offset = build_parse_tree(&tokenizer, token_run, tree);
}
static struct owl_tree *owl_tree_create_with_error(enum owl_error e) {
    struct owl_tree *tree = owl_tree_create_empty();
    tree->error = e;
    return tree;
}
struct owl_tree *owl_tree_create_from_string(const char *string) {
    return owl_tree_create_with_options((struct owl_tree_options){ .string = string });
}
struct owl_tree *owl_tree_create_from_file(FILE *file) {
    if (!file)
        return owl_tree_create_with_error(ERROR_INVALID_FILE);
    return owl_tree_create_with_options((struct owl_tree_options){ .file = file });
}
struct owl_tree *owl_tree_create_with_options(struct owl_tree_options options) {
    if (!options.file == !options.string)
        return owl_tree_create_with_error(ERROR_INVALID_OPTIONS);
    if (options.file) {
        char *str = 0;
        size_t len = 32;
        size_t off = 0;
        while (true) {
            len = len * 3 / 2;
            char *s = realloc(str, len);
            if (!s) {
                free(str);
                return 0;
            }
            str = s;
            off += fread(str + off, 1, len - off, options.file);
            if (off < len) {
                str[off] = '\0';
                break;
            }
        }
        options.string = str;
    }
    struct owl_tree *tree = owl_tree_create_empty();
    if (options.file)
        tree->owns_string = true;
    parse_string(tree, options.string);
    return tree;
}
enum owl_error owl_tree_get_error(struct owl_tree *tree, struct source_range *error_range) {
    if (error_range)
        *error_range = tree->error_range;
    return tree->error;
}
void owl_tree_destroy(struct owl_tree *tree) {
    if (!tree)
        return;
    if (tree->owns_string)
        free((void *)tree->string);
    free(tree->parse_tree);
    free(tree);
}
static bool fill_run_states(struct owl_token_run *run, struct fill_run_continuation *cont, uint16_t *failing_index) {
    uint16_t token_index = 0;
    uint16_t number_of_tokens = run->number_of_tokens;
    while (token_index < number_of_tokens) {
        struct fill_run_state *top = &cont->stack[cont->top_index];
        run->states[token_index] = top->state;
        state_funcs[top->state](run, top, token_index);
        if (cont->error) {
            *failing_index = token_index - (cont->error > 0 ? 0 : 1);
            return false;
        }
        token_index++;
    }
    return true;
}
static const uint16_t actions[] = {
0,0,4096,0,4096,4096,0,4096,4096,32768,32769,16385,0,4096,4096,32768,32769,32770,32769,16385,0,4096,4096,32768,32769,36864,40960,16384,0,4096,
4096,32768,32769,36864,40960,16385,0,4096,4096,32768,32769,36864,40960,16386,0,4096,4096,32768,32769,36864,40961,16387,0,4096,4096,32768,32769,36864,40962,0,
4096,4096,32768,32769,36864,40963,0,4096,4096,32768,32769,36864,45060,0,4096,4096,32768,32769,36864,45061,0,4096,4096,32768,32769,36864,45062,0,4096,4096,
32769,16384,0,4096,4096,32769,32769,16384,0,4096,4096,32770,16384,0,4096,4096,32770,16385,0,4096,16385,0,4096,32768,32769,16385,0,4096,32768,32769,
32770,32769,16385,0,4096,32768,32769,36864,40960,16384,0,4096,32768,32769,36864,40960,16385,0,4096,32768,32769,36864,40960,16386,0,4096,32768,32769,36864,40961,
16387,0,4096,32768,32769,36864,40962,0,4096,32768,32769,36864,40963,0,4096,32768,32769,36864,45060,0,4096,32768,32769,36864,45061,0,4096,32768,32769,36864,
45062,0,4096,32769,16384,0,4096,32769,32769,16384,0,4096,32770,16384,0,4096,32770,16385,0,4096,32770,32769,16385,0,16384,0,16385,0,16389,0,
16390,0,20480,8192,0,20480,8192,4096,0,20480,8192,4096,32768,12288,0,20480,8192,4096,32768,12289,0,20480,8192,4096,32768,12290,32768,12288,0,20480,
8192,4096,32768,12290,32768,12289,0,20480,8192,4096,32768,12290,32768,12290,0,20480,8192,4096,32768,12290,32768,12291,0,20480,8192,4096,32769,16385,0,20480,
8192,16385,0,20480,8192,16389,0,20480,45063,24576,40960,16384,0,20480,45063,24576,40960,16385,0,20480,45063,24576,40960,16386,0,20480,45063,24576,40961,16387,
0,20480,45063,24576,40962,0,20480,45063,24576,40963,0,20480,45063,24576,45060,0,20480,45063,24576,45061,0,20480,45063,24576,45062,0,20480,45064,0,24576,
40960,16384,0,24576,40960,16385,0,24576,40960,16386,0,24576,40961,16387,0,24576,40962,0,24576,40963,0,24576,45060,0,24576,45061,0,24576,45062,0,
32768,32769,16385,0,32768,32769,32770,32769,16385,0,32768,32769,36864,40960,16384,0,32768,32769,36864,40960,16385,0,32768,32769,36864,40960,16386,0,32768,32769,
36864,40961,16387,0,32768,32769,36864,40962,0,32768,32769,36864,40963,0,32768,32769,36864,45060,0,32768,32769,36864,45061,0,32768,32769,36864,45062,0,32769,
16384,0,32769,32769,16384,0,32770,16384,0,32770,16385,0,36864,40960,16384,0,36864,40960,16385,0,36864,40960,16386,0,36864,40961,16387,0,36864,40962,
0,36864,40963,0,36864,45060,0,36864,45061,0,36864,45062,0,36868,40960,16384,0,36868,40960,16385,0,36868,40960,16386,0,36868,40961,16387,0,36868,
40962,0,36868,40963,0,36868,45060,0,36868,45061,0,36868,45062,0,};
static const uint8_t action_table[1024][3][7] = {
{{12,52,93,157,96,6,0,},{11,92,4,5,4,0,0,},{165,88,92,160,224,3,0,},},{{159,136,73,158,96,14,0,},{157,80,93,157,168,8,0,},},{{164,104,72,244,136,2,0,},},
{{8,132,106,26,252,110,64,},{162,152,92,47,196,11,0,},},{{44,228,6,39,4,0,0,},{158,112,101,157,168,10,0,},},{{161,32,69,130,225,9,0,},},{{6,76,66,7,188,9,0,},
{159,48,105,26,4,222,9,},},{{9,244,70,9,20,11,0,},},{{10,196,94,197,120,14,0,},{4,188,104,26,4,30,10,},{163,104,92,160,144,11,0,},},{{161,208,76,130,49,10,0,},},
{{9,220,102,197,168,10,0,},{4,172,104,26,4,30,10,},},{{8,148,66,7,44,15,0,},{5,164,108,37,28,14,10,},},{{33,52,40,19,4,0,0,},{197,176,74,9,12,10,0,},
{158,64,93,157,72,10,0,},},{{244,104,68,244,16,11,0,},{163,72,104,26,84,12,10,},},{{9,4,107,26,204,90,12,},{157,136,109,37,148,217,9,},},{{31,220,41,12,4,0,0,},
{162,48,104,26,84,12,10,},},{{130,193,92,161,72,10,0,},{160,160,68,244,224,9,0,},},{{7,68,94,6,76,10,0,},{244,72,68,244,16,11,0,},{163,40,104,26,84,12,10,},},
{{21,76,94,6,100,6,0,},{6,60,74,7,12,10,0,},},{{15,252,89,165,0,0,0,},{13,68,92,165,96,6,0,},{159,96,69,158,72,14,0,},},{{8,60,106,26,252,110,64,},
{158,144,101,157,168,10,0,},},{{8,76,102,6,220,14,0,},{165,64,100,160,136,4,0,},{158,40,109,37,228,218,9,},},{{164,48,68,244,80,2,0,},},{{130,225,64,130,249,10,0,},
{159,144,109,37,28,222,9,},},{{4,20,109,37,28,30,10,},{162,112,100,160,32,12,0,},},{{5,52,108,37,28,14,10,},{165,80,92,11,132,3,0,},{163,144,100,160,32,12,0,},},
{{163,64,64,244,160,12,0,},},{{6,100,66,7,188,9,0,},{159,176,109,37,28,222,9,},},{{26,180,54,10,4,0,0,},{12,148,93,157,96,6,0,},{165,96,64,244,32,5,0,},},
{{164,8,100,14,196,2,0,},{158,120,69,158,16,11,0,},},{{157,88,101,157,56,9,0,},},{{157,104,105,26,108,217,9,},},{{6,84,102,6,60,9,0,},{130,193,108,37,228,26,10,},},
{{7,52,70,7,20,11,0,},{161,248,104,26,108,25,10,},{161,192,100,161,56,9,0,},},{{18,212,92,161,96,6,0,},{130,209,108,37,228,26,10,},{161,200,108,37,148,25,10,},},
{{164,160,72,244,136,2,0,},},{{6,52,102,6,60,9,0,},{130,169,104,26,204,26,10,},{159,40,93,157,128,13,0,},},{{165,144,108,37,244,4,10,},},{{197,192,106,26,108,89,12,},},
{{163,144,92,160,144,11,0,},},{{130,217,64,130,249,10,0,},{162,160,108,37,124,12,10,},},{{130,17,65,130,249,10,0,},{165,224,101,27,28,6,0,},},{{10,156,106,26,252,94,12,},
{163,48,104,26,84,12,10,},},{{21,68,94,6,100,6,0,},{9,196,110,37,228,90,12,},{159,112,109,37,28,222,9,},},{{130,249,64,130,249,10,0,},{244,88,72,244,40,11,0,},},
{{8,36,66,7,44,15,0,},},{{26,196,54,10,4,0,0,},{244,72,72,244,40,11,0,},{158,152,73,158,40,11,0,},},{{22,220,94,197,96,6,0,},{244,64,72,244,40,11,0,},},
{{15,228,89,165,0,0,0,},{159,104,109,37,28,222,9,},},{{8,68,66,7,44,15,0,},{165,72,64,244,32,5,0,},},{{7,148,74,7,44,11,0,},{164,56,64,244,24,2,0,},},
{{11,196,4,4,4,0,0,},},{{159,152,69,158,72,14,0,},},{{162,104,92,160,144,11,0,},},{{25,124,5,159,0,0,0,},{157,216,69,158,224,9,0,},},{{244,40,108,37,228,10,10,},},
{{164,104,64,244,24,2,0,},},{{157,176,12,36,220,6,0,},},{{6,100,70,7,228,9,0,},{165,120,100,160,136,4,0,},},{{18,220,92,161,96,6,0,},{244,160,104,26,204,10,10,},
{157,112,69,158,224,9,0,},},{{6,76,74,7,12,10,0,},{4,228,68,130,73,14,0,},},{{6,60,70,7,228,9,0,},},{{29,36,41,18,4,0,0,},{158,200,65,158,248,10,0,},
{158,96,69,158,16,11,0,},},{{10,244,106,26,252,94,12,},{197,160,94,197,168,8,0,},{163,88,104,26,84,12,10,},},{{50,180,20,36,20,0,0,},{21,28,94,6,100,6,0,},},
{{8,148,74,7,92,15,0,},},{{10,204,66,9,44,15,0,},},{{10,212,74,9,92,15,0,},{197,176,70,9,228,9,0,},},{{244,144,92,160,72,10,0,},{157,136,101,157,56,9,0,},},
{{6,132,106,26,108,105,64,},{4,212,104,26,4,30,10,},{160,56,92,160,168,8,0,},},{{27,236,101,27,116,6,0,},{8,44,106,26,252,110,64,},{158,176,109,37,228,218,9,},},
{{7,68,70,7,20,11,0,},{197,208,102,197,56,9,0,},},{{9,204,70,9,20,11,0,},{4,236,64,130,49,14,0,},},{{15,172,88,165,0,0,0,},{8,132,66,7,44,15,0,},},
{{244,48,100,160,168,10,0,},},{{244,88,100,160,168,10,0,},{244,56,100,160,168,10,0,},},{{9,172,70,9,20,11,0,},},{{130,225,72,130,41,11,0,},{159,144,101,157,224,13,0,},},
{{158,48,93,157,72,10,0,},},{{161,232,72,130,9,10,0,},},{{7,140,94,48,108,10,0,},},{{24,44,102,8,148,6,0,},{6,100,74,7,12,10,0,},{159,176,101,157,224,13,0,},},
{0},{{161,232,104,26,108,25,10,},},{{157,88,109,37,148,217,9,},},{{9,156,106,26,204,90,12,},},{{130,185,104,26,204,26,10,},{244,144,68,244,16,11,0,},},{{5,100,92,160,128,13,0,},
{163,96,68,244,200,12,0,},{158,104,101,157,168,10,0,},},{{7,60,102,6,172,10,0,},{161,200,100,161,56,9,0,},},{{5,100,68,244,72,14,0,},{164,88,92,160,168,0,0,},},
{{21,140,94,48,116,6,0,},},{{163,64,68,244,200,12,0,},{158,72,101,157,168,10,0,},},{{165,64,64,244,32,5,0,},{163,96,72,244,240,12,0,},},{{21,52,94,6,100,6,0,},
{160,120,76,244,48,10,0,},},{{6,36,70,7,228,9,0,},{4,220,64,130,49,14,0,},{162,56,72,244,240,12,0,},},{{130,201,68,130,17,11,0,},{164,104,92,160,168,0,0,},},
{{38,132,93,25,60,6,0,},{10,4,95,197,120,14,0,},{5,148,104,26,4,14,10,},},{{9,196,102,197,168,10,0,},{159,72,105,26,4,222,9,},},{{162,88,72,244,240,12,0,},
{159,120,109,37,28,222,9,},},{{197,200,106,26,108,89,12,},},{{165,56,92,160,224,3,0,},{158,152,65,158,248,10,0,},},{{14,244,81,165,0,0,0,},{244,64,64,244,248,10,0,},},
{{24,52,102,8,148,6,0,},{19,92,92,160,96,6,0,},},{{14,164,80,165,0,0,0,},{12,140,93,157,96,6,0,},},{{7,148,66,7,252,10,0,},{130,209,68,130,17,11,0,},},
{{7,132,94,6,76,10,0,},{130,217,68,130,17,11,0,},},{{9,180,66,9,252,10,0,},{159,152,93,157,128,13,0,},},{{165,160,108,37,244,4,10,},},{{5,76,68,244,72,14,0,},
{163,136,92,34,244,11,0,},},{{164,24,92,15,28,3,0,},{159,80,101,157,224,13,0,},},{{157,96,73,158,8,10,0,},},{{10,156,94,197,120,14,0,},},{{165,120,108,37,244,4,10,},
{164,120,104,26,172,1,10,},},{{157,112,77,158,48,10,0,},},{{4,228,92,161,128,13,0,},{159,168,101,157,224,13,0,},},{{21,132,94,6,100,6,0,},},{{8,132,70,7,68,15,0,},
{158,200,73,158,40,11,0,},{157,152,109,37,148,217,9,},},{{7,44,106,26,204,106,64,},{5,124,104,26,4,14,10,},{161,208,92,161,168,8,0,},},{{21,44,94,6,100,6,0,},
{159,200,101,157,224,13,0,},},{{6,44,102,6,60,9,0,},{4,196,104,26,4,30,10,},{160,48,64,244,184,9,0,},},{{164,56,104,26,172,1,10,},},{{165,48,108,37,244,4,10,},},
{{7,84,74,7,44,11,0,},{244,120,64,244,248,10,0,},{164,40,104,26,172,1,10,},},{{4,36,105,26,4,30,10,},},{{163,56,68,244,200,12,0,},{157,216,109,37,148,217,9,},},
{{16,172,84,164,0,0,0,},{7,76,74,7,44,11,0,},{197,208,110,37,148,89,12,},},{{157,152,69,158,224,9,0,},},{{47,132,4,33,4,0,0,},{164,136,92,34,44,1,0,},},
{{163,144,64,244,160,12,0,},},{{244,88,108,37,228,10,10,},{197,240,110,37,148,89,12,},},{{9,172,94,197,72,10,0,},{159,96,65,158,48,14,0,},},{{159,144,93,157,128,13,0,},},
{{4,20,93,161,128,13,0,},{197,152,78,9,52,10,0,},},{{29,188,40,18,4,0,0,},{10,164,106,26,252,94,12,},{197,240,94,197,168,8,0,},},{{157,72,109,37,148,217,9,},},
{{6,132,66,7,188,9,0,},{160,96,72,244,8,10,0,},},{{10,204,106,26,252,94,12,},},{{197,176,110,37,148,89,12,},},{{32,100,45,12,4,0,0,},{197,168,110,37,148,89,12,},},
{{197,160,110,37,148,89,12,},{162,144,104,26,84,12,10,},},{0},{{9,164,70,9,20,11,0,},{158,104,109,37,228,218,9,},},{{7,36,66,7,252,10,0,},{161,200,92,161,168,8,0,},},
{{157,120,65,158,184,9,0,},},{{164,64,68,244,80,2,0,},},{{165,160,100,160,136,4,0,},{158,72,109,37,228,218,9,},},{0},{{22,252,94,44,116,6,0,},{159,88,105,26,4,222,9,},},
{{162,160,92,160,144,11,0,},{162,56,64,244,160,12,0,},},{0},{{5,164,104,26,4,14,10,},{244,112,100,160,168,10,0,},},{{157,40,105,26,108,217,9,},},{{19,108,92,160,96,6,0,},
{162,88,64,244,160,12,0,},{159,120,101,157,224,13,0,},},{0},{{165,56,68,244,80,5,0,},{157,56,37,50,252,7,0,},},{{9,164,94,197,72,10,0,},{157,176,101,157,56,9,0,},},
{{11,124,4,5,4,0,0,},{130,233,104,26,204,26,10,},{244,144,108,37,228,10,10,},},{{130,33,105,26,204,26,10,},{158,136,93,157,72,10,0,},},{{10,172,66,9,44,15,0,},
{197,232,94,40,12,9,0,},},{{5,60,64,244,48,14,0,},{164,88,68,244,80,2,0,},},{{9,180,74,9,44,11,0,},{4,228,100,161,224,13,0,},{160,88,104,26,108,9,10,},},
{{14,148,80,165,0,0,0,},{8,84,106,26,252,110,64,},{165,88,104,26,196,4,10,},},{{5,76,92,160,128,13,0,},{165,104,108,37,244,4,10,},{161,224,72,130,9,10,0,},},
{{244,40,92,160,72,10,0,},},{{160,120,104,26,108,9,10,},{157,96,65,158,184,9,0,},},{0},{{10,212,110,37,20,95,12,},{163,120,108,37,124,12,10,},},{{13,164,92,165,96,6,0,},
{7,60,106,26,204,106,64,},{5,108,104,26,4,14,10,},},{{130,225,92,161,72,10,0,},{159,168,109,37,28,222,9,},},{{130,233,92,161,72,10,0,},},{{14,76,80,165,0,0,0,},
{8,132,94,6,124,14,0,},{165,136,92,34,84,4,0,},},{{130,249,92,161,72,10,0,},{159,216,73,158,96,14,0,},},{{39,4,43,22,4,0,0,},{159,200,109,37,28,222,9,},},
{{6,44,110,37,148,105,64,},{130,201,92,161,72,10,0,},},{{10,164,70,9,68,15,0,},},{{244,104,108,37,228,10,10,},{163,72,64,244,160,12,0,},},{{7,84,66,7,252,10,0,},
{244,120,72,244,40,11,0,},{161,16,73,130,9,10,0,},},{{19,100,92,160,96,6,0,},{130,9,93,30,140,10,0,},{130,193,104,26,204,26,10,},},{{197,192,74,9,12,10,0,},
{163,56,92,160,144,11,0,},},{{9,12,106,26,204,90,12,},{244,72,108,37,228,10,10,},},{{13,252,93,165,96,6,0,},{163,104,108,37,124,12,10,},{157,152,77,158,48,10,0,},},
{{159,96,93,157,128,13,0,},},{{14,172,80,165,0,0,0,},{158,144,93,157,72,10,0,},},{{10,180,106,26,252,94,12,},{10,12,102,197,216,14,0,},{160,96,104,26,108,9,10,},},
{{164,48,92,160,168,0,0,},{162,72,72,244,240,12,0,},},{{160,64,64,244,184,9,0,},},{{4,20,69,130,73,14,0,},{160,88,64,244,184,9,0,},},{{5,68,92,160,128,13,0,},
{160,64,72,244,8,10,0,},},{{165,8,100,14,180,5,0,},{157,72,101,157,56,9,0,},},{{162,96,72,244,240,12,0,},{159,160,93,157,128,13,0,},},{{19,156,92,47,116,6,0,},
{165,96,104,26,196,4,10,},},{{158,120,109,37,228,218,9,},},{{22,164,94,197,96,6,0,},{130,201,104,26,204,26,10,},},{0},{{6,68,102,6,60,9,0,},{130,217,104,26,204,26,10,},},
{{5,100,108,37,28,14,10,},{161,248,64,130,185,9,0,},},{{7,36,74,7,44,11,0,},{197,200,102,197,56,9,0,},},{{24,76,102,8,148,6,0,},{164,232,101,27,68,3,0,},
{157,120,73,158,8,10,0,},},{{197,152,70,9,228,9,0,},},{{161,216,64,130,185,9,0,},},{{10,156,66,9,44,15,0,},},{0},{{48,116,6,41,4,0,0,},{159,112,105,26,4,222,9,},},
{{244,96,72,244,40,11,0,},{163,48,92,160,144,11,0,},},{{16,228,85,164,0,0,0,},{244,112,108,37,228,10,10,},},{{4,212,72,130,97,14,0,},{157,144,109,37,148,217,9,},},
{{130,249,104,26,204,26,10,},{159,120,93,157,128,13,0,},},{{6,148,106,26,108,105,64,},{165,40,104,26,196,4,10,},{158,168,101,157,168,10,0,},},{{197,216,94,197,168,8,0,},
{160,48,92,160,168,8,0,},},{{164,56,92,160,168,0,0,},{157,176,109,37,148,217,9,},},{{160,72,104,26,108,9,10,},},{{8,68,106,26,252,110,64,},{165,72,104,26,196,4,10,},
{158,136,101,157,168,10,0,},},{{10,172,74,9,92,15,0,},},{{5,60,72,244,96,14,0,},{157,216,73,158,8,10,0,},},{{7,76,102,6,172,10,0,},{160,104,104,26,108,9,10,},},
{{157,200,73,158,8,10,0,},},{{165,104,100,160,136,4,0,},{161,224,64,130,185,9,0,},},{{22,172,94,197,96,6,0,},{159,136,105,26,4,222,9,},},{{164,104,104,26,172,1,10,},
{157,200,93,157,168,8,0,},},{{7,100,70,7,20,11,0,},{158,112,73,158,40,11,0,},},{{5,92,108,37,28,14,10,},{163,120,100,160,32,12,0,},},{{157,112,93,157,168,8,0,},},
{{4,228,108,37,28,30,10,},},{{8,52,66,7,44,15,0,},{6,60,110,37,148,105,64,},},{{6,132,94,6,172,8,0,},{158,96,93,157,72,10,0,},},{{164,72,68,244,80,2,0,},
{159,216,65,158,48,14,0,},},{{197,176,66,9,188,9,0,},},{{197,168,74,9,12,10,0,},},{{197,176,106,26,108,89,12,},{161,16,105,26,108,25,10,},},{{244,104,100,160,168,10,0,},
{163,72,72,244,240,12,0,},},{{40,4,47,22,4,0,0,},{162,48,92,160,144,11,0,},{160,144,100,160,56,9,0,},},{{160,160,104,26,108,9,10,},},{{197,192,66,9,188,9,0,},
{165,232,101,27,28,6,0,},},{{244,48,104,26,204,10,10,},{197,208,94,197,168,8,0,},},{{9,204,110,37,228,90,12,},},{{8,60,70,7,68,15,0,},{165,48,68,244,80,5,0,},},
{{161,184,76,130,49,10,0,},},{{10,12,110,37,20,95,12,},{163,160,108,37,124,12,10,},},{{9,172,110,37,228,90,12,},{164,48,100,160,104,1,0,},},{{4,188,100,161,224,13,0,},
{130,233,68,130,17,11,0,},},{{25,140,5,159,0,0,0,},{15,68,88,165,0,0,0,},},{0},{0},{{6,28,94,6,172,8,0,},{157,192,93,32,12,9,0,},},{{8,36,102,6,220,14,0,},
{6,36,94,6,172,8,0,},},{{165,112,92,160,224,3,0,},{158,120,101,157,168,10,0,},},{{6,52,94,6,172,8,0,},{157,104,93,157,168,8,0,},},{{6,84,74,7,12,10,0,},},
{{34,164,44,19,4,0,0,},{6,68,110,37,148,105,64,},{4,252,104,26,4,30,10,},},{{7,52,102,6,172,10,0,},{161,248,72,130,9,10,0,},{158,104,93,157,72,10,0,},},
{{22,212,94,197,96,6,0,},{161,200,76,130,49,10,0,},},{{165,64,92,160,224,3,0,},{160,136,92,34,12,9,0,},},{{8,100,102,6,220,14,0,},{158,192,93,32,140,10,0,},},
{{10,236,94,40,188,14,0,},{161,216,72,130,9,10,0,},{160,96,64,244,184,9,0,},},{{22,244,94,197,96,6,0,},},{{13,228,93,165,96,6,0,},{162,248,127,162,0,32,10,},},
{{12,212,93,49,116,6,0,},{158,48,101,157,168,10,0,},},{{10,4,107,26,252,94,12,},{5,148,92,160,128,13,0,},{244,96,64,244,248,10,0,},},{{197,0,107,26,108,89,12,},},
{{162,40,100,160,32,12,0,},},{0},{{158,168,109,37,228,218,9,},},{{11,108,4,5,4,0,0,},{9,212,66,9,252,10,0,},},{{21,100,94,6,100,6,0,},{164,56,68,244,80,2,0,},
{159,104,65,158,48,14,0,},},{{162,72,104,26,84,12,10,},},{{19,164,92,160,96,6,0,},{158,136,109,37,228,218,9,},},{{5,44,108,37,28,14,10,},{165,160,104,26,196,4,10,},},
{{159,152,105,26,4,222,9,},},{{162,104,104,26,84,12,10,},},{0},{{7,28,110,37,228,106,64,},{5,76,108,37,28,14,10,},{165,104,92,160,224,3,0,},},{{18,188,92,161,96,6,0,},
{157,80,101,157,56,9,0,},},{{12,84,93,157,96,6,0,},{158,176,101,157,168,10,0,},},{{12,92,93,157,96,6,0,},{158,112,65,158,248,10,0,},},{{12,68,93,157,96,6,0,},
{161,32,105,26,108,25,10,},},{{12,76,93,157,96,6,0,},{244,160,72,244,40,11,0,},{157,112,101,157,56,9,0,},},{{159,168,93,157,128,13,0,},{157,144,105,26,108,217,9,},},
{{6,60,102,6,60,9,0,},{158,216,69,158,16,11,0,},},{{197,8,110,37,148,89,12,},{160,48,68,244,224,9,0,},},{{11,228,4,4,4,0,0,},{164,72,92,160,168,0,0,},
{163,56,72,244,240,12,0,},},{{165,48,104,26,196,4,10,},},{{8,148,106,26,252,110,64,},{6,44,94,6,172,8,0,},{164,40,100,160,104,1,0,},},{{158,64,101,157,168,10,0,},},
{{157,136,73,158,8,10,0,},},{{4,212,92,161,128,13,0,},{160,56,104,26,108,9,10,},},{{6,84,66,7,188,9,0,},},{{8,44,74,7,92,15,0,},{163,56,108,37,124,12,10,},},
{{7,68,102,6,172,10,0,},{197,208,70,9,228,9,0,},},{{9,204,102,197,168,10,0,},{157,152,93,157,168,8,0,},},{{43,20,102,45,132,6,0,},{10,156,102,197,216,14,0,},},
{{8,76,74,7,92,15,0,},{165,64,72,244,128,5,0,},},{{16,60,84,164,0,0,0,},{244,88,68,244,16,11,0,},},{{22,196,94,197,96,6,0,},{9,172,102,197,168,10,0,},
{164,48,108,37,228,1,10,},},{{130,225,104,26,204,26,10,},{159,144,69,158,72,14,0,},},{{5,52,64,244,48,14,0,},{163,144,72,244,240,12,0,},},{{4,220,100,161,224,13,0,},},
{{10,212,102,197,216,14,0,},{162,128,93,25,100,11,0,},},{{6,100,106,26,108,105,64,},{159,176,69,158,72,14,0,},},{{197,160,106,26,108,89,12,},},{{30,252,44,18,4,0,0,},
{4,252,68,130,73,14,0,},},{{9,156,94,197,72,10,0,},{8,148,94,6,124,14,0,},{164,96,68,244,80,2,0,},},{{4,236,68,130,73,14,0,},{160,112,104,26,108,9,10,},},
{{14,172,81,165,0,0,0,},{130,185,72,130,41,11,0,},},{{8,140,94,48,156,14,0,},{158,104,69,158,16,11,0,},},{{161,200,68,130,225,9,0,},},{{6,52,66,7,188,9,0,},
{4,36,65,130,49,14,0,},{4,204,68,130,73,14,0,},},{{33,164,40,19,4,0,0,},{165,144,64,244,32,5,0,},},{{9,4,111,37,228,90,12,},{163,64,100,160,32,12,0,},},
{{25,108,5,159,0,0,0,},{165,248,127,162,16,32,10,},},{{13,52,92,165,96,6,0,},{9,244,110,37,228,90,12,},{160,32,0,13,188,6,0,},},{{16,148,84,164,0,0,0,},
{130,17,109,37,228,26,10,},},{{16,124,84,164,0,0,0,},{5,148,68,244,72,14,0,},},{{8,52,94,6,124,14,0,},},{{162,40,108,37,124,12,10,},{157,144,93,157,168,8,0,},},
{{6,36,102,6,60,9,0,},{162,88,104,26,84,12,10,},},{{5,124,64,244,48,14,0,},{158,48,105,26,204,218,9,},},{{9,212,74,9,44,11,0,},},{{8,28,94,6,124,14,0,},
{159,104,73,158,96,14,0,},},{{130,233,64,130,249,10,0,},{164,88,64,244,24,2,0,},},{{164,64,72,244,136,2,0,},{162,96,64,244,160,12,0,},},{{18,36,93,161,96,6,0,},
{5,44,100,160,224,13,0,},},{{162,120,68,244,200,12,0,},{160,88,92,160,168,8,0,},},{{19,60,92,160,96,6,0,},{244,48,68,244,16,11,0,},},{{8,84,66,7,44,15,0,},
{165,88,64,244,32,5,0,},},{{7,28,102,6,172,10,0,},{5,76,100,160,224,13,0,},},{{157,80,109,37,148,217,9,},},{{160,120,0,13,188,6,0,},},{{165,120,64,244,32,5,0,},
{158,216,93,157,72,10,0,},},{{244,56,72,244,40,11,0,},{161,240,104,26,108,25,10,},},{{244,160,64,244,248,10,0,},{157,112,109,37,148,217,9,},},{{164,120,64,244,24,2,0,},
{161,208,64,130,185,9,0,},},{{10,196,66,9,44,15,0,},{161,192,76,130,49,10,0,},{158,200,101,157,168,10,0,},},{{5,124,92,160,128,13,0,},{197,8,102,197,56,9,0,},
{161,208,104,26,108,25,10,},},{{10,164,74,9,92,15,0,},},{{159,200,69,158,72,14,0,},},{{6,148,74,7,12,10,0,},{4,196,72,130,97,14,0,},},{{8,28,106,26,252,110,64,},
{7,60,70,7,20,11,0,},{158,64,109,37,228,218,9,},},{{9,4,71,9,20,11,0,},{5,100,100,160,224,13,0,},{157,136,65,158,184,9,0,},},{{6,132,70,7,228,9,0,},
{4,212,68,130,73,14,0,},{130,209,92,161,72,10,0,},},{{4,36,73,130,97,14,0,},{130,193,64,130,249,10,0,},},{{8,44,66,7,44,15,0,},{163,56,100,160,32,12,0,},
{158,176,69,158,16,11,0,},},{{7,68,110,37,228,106,64,},{163,128,93,25,100,11,0,},{160,120,108,37,148,9,10,},},{0},{{11,36,5,4,4,0,0,},{4,172,108,37,28,30,10,},
{130,241,104,26,204,26,10,},},{{163,64,72,244,240,12,0,},{158,144,69,158,16,11,0,},},{{10,12,94,197,120,14,0,},{163,160,92,160,144,11,0,},{160,88,76,244,48,10,0,},},
{{8,76,106,26,252,110,64,},},{{19,52,92,160,96,6,0,},},{{10,164,94,197,120,14,0,},{197,240,106,26,108,89,12,},{160,48,108,37,148,9,10,},},{{16,172,85,164,0,0,0,},
{5,68,68,244,72,14,0,},},{{13,172,93,165,96,6,0,},{4,20,101,161,224,13,0,},},{{159,176,93,157,128,13,0,},},{{130,209,100,161,168,10,0,},{161,184,92,161,168,8,0,},},
{{130,217,100,161,168,10,0,},{164,160,64,244,24,2,0,},},{{9,156,70,9,20,11,0,},{164,96,92,160,168,0,0,},{157,104,77,158,48,10,0,},},{{162,144,72,244,240,12,0,},
{160,144,64,244,184,9,0,},},{{6,68,94,6,172,8,0,},{130,185,64,130,249,10,0,},},{{10,204,110,37,20,95,12,},{163,96,108,37,124,12,10,},{161,80,92,11,108,8,0,},},
{{13,236,93,165,96,6,0,},{164,112,100,160,104,1,0,},},{{4,204,92,161,128,13,0,},{164,64,104,26,172,1,10,},},{{197,152,94,197,168,8,0,},{165,144,72,244,128,5,0,},},
{{163,64,108,37,124,12,10,},{159,112,101,157,224,13,0,},},{{24,84,102,8,148,6,0,},},{{130,217,92,161,72,10,0,},{162,56,108,37,124,12,10,},},{{130,17,101,161,168,10,0,},
{244,72,64,244,248,10,0,},},{{10,156,70,9,68,15,0,},{244,152,92,47,108,10,0,},{163,48,68,244,200,12,0,},},{{5,164,72,244,96,14,0,},},{{9,196,94,197,72,10,0,},
{157,144,69,158,224,9,0,},},{{159,120,69,158,72,14,0,},},{{158,152,101,157,168,10,0,},{157,56,25,50,60,7,0,},},{{15,244,89,165,0,0,0,},{244,64,108,37,228,10,10,},},
{{157,176,69,158,224,9,0,},},{{130,233,72,130,41,11,0,},{157,216,77,158,48,10,0,},},{{6,76,110,37,148,105,64,},{130,33,73,130,41,11,0,},},{{6,84,110,37,148,105,64,},
{157,200,77,158,48,10,0,},},{{160,88,68,244,224,9,0,},{157,64,109,37,148,217,9,},},{0},{{8,84,74,7,92,15,0,},{165,88,72,244,128,5,0,},},{{7,100,66,7,252,10,0,},
{161,224,104,26,108,25,10,},},{{160,120,68,244,224,9,0,},{157,96,109,37,148,217,9,},},{0},{{5,92,72,244,96,14,0,},{165,120,72,244,128,5,0,},},{{8,52,70,7,68,15,0,},
{5,92,68,244,72,14,0,},},{{6,28,110,37,148,105,64,},{5,76,72,244,96,14,0,},},{{10,204,74,9,92,15,0,},{164,120,72,244,136,2,0,},},{{10,196,74,9,92,15,0,},
{158,96,105,26,204,218,9,},},{{5,124,68,244,72,14,0,},{158,80,109,37,228,218,9,},},{{164,72,108,37,228,1,10,},{159,216,105,26,4,222,9,},},{{164,88,72,244,136,2,0,},},
{{6,148,66,7,188,9,0,},{4,196,64,130,49,14,0,},},{0},{{9,4,95,197,72,10,0,},{244,120,100,160,168,10,0,},},{{162,48,68,244,200,12,0,},{159,64,105,26,4,222,9,},},
{{130,193,72,130,41,11,0,},{244,56,108,37,228,10,10,},},{{158,176,93,157,72,10,0,},},{{157,48,101,157,56,9,0,},},{{159,96,105,26,4,222,9,},},{{8,60,94,6,124,14,0,},
{4,172,100,161,224,13,0,},{165,48,92,160,224,3,0,},},{{34,52,44,19,4,0,0,},{161,184,100,161,56,9,0,},},{{10,180,74,9,92,15,0,},{163,160,68,244,200,12,0,},},
{{13,92,92,165,96,6,0,},{11,220,4,4,4,0,0,},},{0},{{13,76,92,165,96,6,0,},{7,28,94,6,76,10,0,},},{{6,36,66,7,188,9,0,},},{{14,124,80,165,0,0,0,},
{13,124,92,165,96,6,0,},{7,44,94,6,76,10,0,},},{{7,36,94,6,76,10,0,},{162,96,104,26,84,12,10,},},{{7,60,94,6,76,10,0,},{161,232,76,130,49,10,0,},},
{{10,220,110,37,20,95,12,},{7,52,94,6,76,10,0,},{163,112,108,37,124,12,10,},},{{157,104,69,158,224,9,0,},},{{162,144,64,244,160,12,0,},},{{6,68,70,7,228,9,0,},
{4,252,64,130,49,14,0,},{162,112,92,160,144,11,0,},},{{16,92,84,164,0,0,0,},{7,36,102,6,172,10,0,},{162,120,92,160,144,11,0,},},{{164,112,108,37,228,1,10,},
{162,64,92,160,144,11,0,},},{{130,169,92,161,72,10,0,},{159,40,105,26,4,222,9,},},{{164,16,100,16,236,2,0,},{158,88,105,26,204,218,9,},},{{37,100,62,24,4,0,0,},
{12,204,93,157,96,6,0,},{159,152,73,158,96,14,0,},},{{18,196,92,161,96,6,0,},},{{162,56,100,160,32,12,0,},},{0},{{10,4,67,9,44,15,0,},{244,96,104,26,204,10,10,},},
{{14,252,81,165,0,0,0,},{5,164,64,244,48,14,0,},},{{160,48,104,26,108,9,10,},{157,144,77,158,48,10,0,},},{{8,36,94,6,124,14,0,},{165,40,92,160,224,3,0,},
{161,184,68,130,225,9,0,},},{{10,172,102,197,216,14,0,},},{{15,164,88,165,0,0,0,},{244,64,100,160,168,10,0,},},{{16,108,84,164,0,0,0,},{157,176,77,158,48,10,0,},},
{{162,72,64,244,160,12,0,},{160,72,72,244,8,10,0,},},{{7,148,94,6,76,10,0,},},{{16,68,84,164,0,0,0,},},{{9,180,110,37,228,90,12,},{4,28,93,42,164,13,0,},
{157,64,101,157,56,9,0,},},{{162,104,64,244,160,12,0,},{160,104,72,244,8,10,0,},},{0},{{8,100,70,7,68,15,0,},{5,52,72,244,96,14,0,},{165,104,68,244,80,5,0,},},
{{157,96,101,157,56,9,0,},},{{11,76,4,5,4,0,0,},},{{158,112,105,26,204,218,9,},},{{10,212,70,9,68,15,0,},{163,120,68,244,200,12,0,},{158,216,65,158,248,10,0,},},
{{7,60,66,7,252,10,0,},{5,108,64,244,48,14,0,},{160,48,72,244,8,10,0,},},{{4,244,100,161,224,13,0,},},{{161,192,92,161,168,8,0,},},{{10,244,70,9,68,15,0,},
{163,88,68,244,200,12,0,},{158,80,101,157,168,10,0,},},{{18,204,92,161,96,6,0,},{164,72,100,160,104,1,0,},},{{15,52,88,165,0,0,0,},{9,236,94,40,140,10,0,},
{159,80,105,26,4,222,9,},},{{161,16,69,130,225,9,0,},},{{16,100,84,164,0,0,0,},{6,84,70,7,228,9,0,},},{{7,84,102,6,172,10,0,},{244,120,108,37,228,10,10,},},
{{160,144,68,244,224,9,0,},{160,56,64,244,184,9,0,},},{{160,160,72,244,8,10,0,},},{{19,44,92,160,96,6,0,},},{{157,48,109,37,148,217,9,},},{{162,80,92,11,68,11,0,},
{157,168,109,37,148,217,9,},},{{4,172,92,161,128,13,0,},{165,48,100,160,136,4,0,},},{{161,184,108,37,148,25,10,},},{{10,180,66,9,44,15,0,},{244,72,100,160,168,10,0,},
{164,248,127,162,32,32,10,},},{{160,64,108,37,148,9,10,},},{{7,132,70,7,20,11,0,},{162,112,104,26,84,12,10,},},{{197,168,102,197,56,9,0,},},{{9,180,94,197,72,10,0,},
{197,160,102,197,56,9,0,},},{{157,72,93,157,168,8,0,},},{{4,228,72,130,97,14,0,},},{{165,112,104,26,196,4,10,},{161,232,68,130,225,9,0,},},{{10,220,102,197,216,14,0,},
{163,112,100,160,32,12,0,},},{{24,148,102,8,148,6,0,},{164,96,108,37,228,1,10,},},{{6,84,106,26,108,105,64,},{4,236,108,37,28,30,10,},},{{4,252,72,130,97,14,0,},},
{{5,116,108,37,28,14,10,},},{{157,120,101,157,56,9,0,},},{{7,100,102,6,172,10,0,},{6,52,106,26,108,105,64,},{130,169,100,161,168,10,0,},},{{11,60,4,5,4,0,0,},
{197,152,110,37,148,89,12,},},{{158,72,93,157,72,10,0,},},{{5,92,100,160,224,13,0,},},{{14,100,80,165,0,0,0,},},{{12,116,93,157,96,6,0,},{6,20,102,45,140,8,0,},
{165,24,92,15,252,5,0,},},{{10,4,75,9,92,15,0,},{6,36,106,26,108,105,64,},},{{10,4,71,9,68,15,0,},{7,44,102,6,172,10,0,},{197,0,75,9,12,10,0,},},
{{162,88,92,160,144,11,0,},},{{197,200,70,9,228,9,0,},},{{8,52,106,26,252,110,64,},{165,56,104,26,196,4,10,},},{{16,244,85,164,0,0,0,},{157,160,105,26,108,217,9,},},
{{9,164,110,37,228,90,12,},{163,104,64,244,160,12,0,},{162,104,68,244,200,12,0,},},{{8,132,102,6,220,14,0,},{160,72,64,244,184,9,0,},},{{10,172,110,37,20,95,12,},
{244,48,72,244,40,11,0,},},{{5,60,100,160,224,13,0,},{244,56,64,244,248,10,0,},},{{15,124,88,165,0,0,0,},{162,120,108,37,124,12,10,},{157,64,93,157,168,8,0,},},
{{160,104,64,244,184,9,0,},},{{12,156,93,157,96,6,0,},{4,188,92,161,128,13,0,},},{{13,108,92,165,96,6,0,},{130,225,100,161,168,10,0,},{159,136,69,158,72,14,0,},},
{{14,228,81,165,0,0,0,},{164,144,64,244,24,2,0,},},{{9,212,106,26,204,90,12,},{197,0,50,46,164,6,0,},},{{158,216,101,157,168,10,0,},},{{163,120,92,160,144,11,0,},
{161,32,73,130,9,10,0,},},{{159,48,109,37,28,222,9,},},{{4,244,108,37,28,30,10,},{162,16,100,16,52,13,0,},},{0},{{197,160,74,9,12,10,0,},{158,80,93,157,72,10,0,},},
{{159,64,101,157,224,13,0,},},{{7,52,66,7,252,10,0,},{159,200,93,157,128,13,0,},},{{12,124,93,157,96,6,0,},{197,176,78,9,52,10,0,},{161,16,77,130,49,10,0,},},
{{244,104,72,244,40,11,0,},{163,72,100,160,32,12,0,},},{{7,84,94,6,76,10,0,},{157,136,105,26,108,217,9,},},{{21,60,94,6,100,6,0,},{160,144,76,244,48,10,0,},
{160,56,72,244,8,10,0,},},{{160,160,64,244,184,9,0,},},{{163,40,100,160,32,12,0,},{161,168,108,37,148,25,10,},},{{9,204,74,9,44,11,0,},{159,112,93,157,128,13,0,},},
{{9,220,110,37,228,90,12,},{8,68,102,6,220,14,0,},{157,168,101,157,56,9,0,},},{{8,60,110,37,20,111,64,},{158,160,105,26,204,218,9,},},{{165,64,104,26,196,4,10,},
{158,144,109,37,228,218,9,},},{{9,172,74,9,44,11,0,},{164,48,64,244,24,2,0,},},{{162,64,108,37,124,12,10,},{160,64,100,160,56,9,0,},},{{4,20,105,26,4,30,10,},
{163,48,100,160,32,12,0,},},{{197,240,66,9,188,9,0,},{160,40,104,26,108,9,10,},},{{5,68,108,37,28,14,10,},},{{15,100,88,165,0,0,0,},{164,160,68,244,80,2,0,},},
{{165,96,68,244,80,5,0,},},{{158,120,73,158,40,11,0,},},{{10,220,94,197,120,14,0,},{163,112,92,160,144,11,0,},},{{164,96,100,160,104,1,0,},{159,160,105,26,4,222,9,},},
{{4,236,100,161,224,13,0,},},{{7,52,74,7,44,11,0,},{5,100,72,244,96,14,0,},{161,248,100,161,56,9,0,},},{{11,164,4,5,4,0,0,},{161,200,104,26,108,25,10,},},
{{157,120,109,37,148,217,9,},},{{244,88,92,160,72,10,0,},{159,192,93,32,196,13,0,},},{{244,64,92,160,72,10,0,},},{{244,72,92,160,72,10,0,},},{{4,220,72,130,97,14,0,},
{164,80,92,11,60,0,0,},},{{7,132,110,37,228,106,64,},{162,160,104,26,84,12,10,},},{{244,96,92,160,72,10,0,},},{{10,156,110,37,20,95,12,},{5,148,100,160,224,13,0,},
{163,48,108,37,124,12,10,},},{{244,112,92,160,72,10,0,},{197,0,67,9,188,9,0,},},{{130,249,68,130,17,11,0,},},{{197,200,94,197,168,8,0,},},{{4,12,93,30,196,13,0,},},
{{16,164,84,164,0,0,0,},{7,76,110,37,228,106,64,},{6,76,106,26,108,105,64,},},{{9,164,102,197,168,10,0,},{164,56,108,37,228,1,10,},{157,176,93,157,168,8,0,},},
{{158,136,65,158,248,10,0,},},{{7,84,110,37,228,106,64,},},{{7,132,106,26,204,106,64,},{5,60,108,37,28,14,10,},},{{162,120,100,160,32,12,0,},{159,152,65,158,48,14,0,},},
{0},{{161,224,92,161,168,8,0,},},{0},{{164,104,68,244,80,2,0,},{160,120,92,160,168,8,0,},},{{6,28,106,26,108,105,64,},{130,33,101,161,168,10,0,},},{{161,32,109,37,148,25,10,},},
{{5,92,92,160,128,13,0,},{244,56,104,26,204,10,10,},{161,32,65,130,185,9,0,},},{{197,168,66,9,188,9,0,},{159,48,101,157,224,13,0,},},{{164,128,93,25,108,0,0,},},
{{8,132,74,7,92,15,0,},{158,96,65,158,248,10,0,},},{{197,160,66,9,188,9,0,},{161,208,72,130,9,10,0,},},{{25,100,5,159,0,0,0,},},{{8,148,70,7,68,15,0,},},
{0},{{25,204,5,159,0,0,0,},{163,72,108,37,124,12,10,},},{{9,4,103,197,168,10,0,},{244,120,92,160,72,10,0,},},{{6,132,102,6,60,9,0,},{4,212,100,161,224,13,0,},
{162,48,108,37,124,12,10,},},{{197,192,94,197,168,8,0,},{158,176,105,26,204,218,9,},},{{163,40,108,37,124,12,10,},{161,168,100,161,56,9,0,},},{{9,204,66,9,252,10,0,},
{164,144,104,26,172,1,10,},},{{157,168,93,157,168,8,0,},},{{25,180,5,159,0,0,0,},},{{158,40,105,26,204,218,9,},},{{9,172,66,9,252,10,0,},{164,48,72,244,136,2,0,},},
{{130,225,68,130,17,11,0,},{159,144,105,26,4,222,9,},},{{7,44,66,7,252,10,0,},{6,44,70,7,228,9,0,},},{{7,100,106,26,204,106,64,},{5,52,104,26,4,14,10,},
{197,240,74,9,12,10,0,},},{{5,68,100,160,224,13,0,},},{{160,96,92,160,168,8,0,},{159,176,105,26,4,222,9,},},{{165,96,92,160,224,3,0,},{158,144,105,26,204,218,9,},},
{{158,120,65,158,248,10,0,},},{{163,96,92,160,144,11,0,},{157,88,105,26,108,217,9,},},{{9,156,102,197,168,10,0,},{157,104,109,37,148,217,9,},},{{130,185,108,37,228,26,10,},
{162,64,64,244,160,12,0,},},{{5,100,64,244,48,14,0,},{161,248,108,37,148,25,10,},},{{163,64,92,160,144,11,0,},},{{13,172,92,165,96,6,0,},{163,88,92,160,144,11,0,},},
{{21,36,94,6,100,6,0,},{163,80,92,11,68,11,0,},{162,8,100,14,28,13,0,},},{{165,144,104,26,196,4,10,},{164,144,92,160,168,0,0,},},{{5,164,68,244,72,14,0,},
{161,216,104,26,108,25,10,},},{{9,244,66,9,252,10,0,},{159,88,93,157,128,13,0,},},{{26,204,54,10,4,0,0,},{4,220,68,130,73,14,0,},},{{130,17,69,130,17,11,0,},},
{{161,184,72,130,9,10,0,},},{{9,196,106,26,204,90,12,},{164,160,92,160,168,0,0,},{159,72,101,157,224,13,0,},},{{164,40,108,37,228,1,10,},{159,120,105,26,4,222,9,},},
{{160,144,108,37,148,9,10,},},{{7,76,106,26,204,106,64,},{158,152,69,158,16,11,0,},},{{163,144,104,26,84,12,10,},},{{130,233,100,161,168,10,0,},{197,240,70,9,228,9,0,},},
{{165,72,68,244,80,5,0,},{158,136,73,158,40,11,0,},},{{22,204,94,197,96,6,0,},{7,148,70,7,20,11,0,},},{{197,152,102,197,56,9,0,},{163,152,92,47,196,11,0,},},
{{9,180,70,9,20,11,0,},{160,88,100,160,56,9,0,},},{0},{{5,76,64,244,48,14,0,},{162,88,100,160,32,12,0,},},{{244,40,104,26,204,10,10,},},{{160,120,100,160,56,9,0,},
{157,96,77,158,48,10,0,},},{{160,48,76,244,48,10,0,},},{{40,156,46,22,4,0,0,},{165,120,104,26,196,4,10,},{160,56,76,244,48,10,0,},},{{244,160,108,37,228,10,10,},
{157,112,65,158,184,9,0,},},{{164,120,100,160,104,1,0,},{160,176,1,13,188,6,0,},},{{31,100,41,12,4,0,0,},{6,60,66,7,188,9,0,},},{{10,196,106,26,252,94,12,},
{163,104,104,26,84,12,10,},{158,96,73,158,40,11,0,},},{{10,244,110,37,20,95,12,},{197,8,94,197,168,8,0,},{163,88,108,37,124,12,10,},},{{164,88,100,160,104,1,0,},
{159,80,93,157,128,13,0,},},{0},{{197,176,94,197,168,8,0,},{161,16,93,161,168,8,0,},},{0},{{244,120,68,244,16,11,0,},},{{6,132,110,37,148,105,64,},{162,48,100,160,32,12,0,},
{160,144,92,160,168,8,0,},},{{8,44,102,6,220,14,0,},{163,56,64,244,160,12,0,},{159,112,69,158,72,14,0,},},{{10,244,94,197,120,14,0,},{7,68,66,7,252,10,0,},},
{{10,252,94,44,156,14,0,},{157,152,65,158,184,9,0,},},{{4,212,108,37,28,30,10,},{159,96,73,158,96,14,0,},},{{10,204,94,197,120,14,0,},{4,220,108,37,28,30,10,},},
{{31,180,41,12,4,0,0,},{10,212,94,197,120,14,0,},{7,132,66,7,252,10,0,},},{{4,204,108,37,28,30,10,},},{{4,188,72,130,97,14,0,},{244,104,64,244,248,10,0,},},
{{29,252,40,18,4,0,0,},{11,20,5,4,4,0,0,},},{{10,164,102,197,216,14,0,},{163,8,100,14,28,13,0,},},{{157,72,105,26,108,217,9,},},{{24,132,102,8,148,6,0,},
{162,96,92,160,144,11,0,},},{{35,36,46,21,4,0,0,},},{{42,4,5,29,4,0,0,},{163,232,101,27,108,13,0,},{161,232,108,37,148,25,10,},},{0},{{9,156,110,37,228,90,12,},
{157,104,101,157,56,9,0,},},{{130,185,100,161,168,10,0,},},{{163,96,64,244,160,12,0,},},{{7,36,70,7,20,11,0,},},{{157,120,93,157,168,8,0,},},{{5,92,104,26,4,14,10,},
{164,64,64,244,24,2,0,},},{{197,168,94,197,168,8,0,},{161,8,93,30,12,9,0,},},{{8,60,102,6,220,14,0,},{130,33,65,130,249,10,0,},},{{9,244,74,9,44,11,0,},
{6,36,110,37,148,105,64,},},{{162,56,68,244,200,12,0,},{160,152,92,47,220,8,0,},},{{130,17,93,161,72,10,0,},{130,201,64,130,249,10,0,},},{{5,108,72,244,96,14,0,},},
{{164,160,100,160,104,1,0,},{159,72,109,37,28,222,9,},},{{162,88,68,244,200,12,0,},},{{163,104,68,244,200,12,0,},{160,184,0,13,188,6,0,},},{{158,152,93,157,72,10,0,},
{157,56,33,50,188,7,0,},},{{5,156,92,47,164,13,0,},{244,64,68,244,16,11,0,},},{{33,124,40,19,4,0,0,},{11,212,4,4,4,0,0,},{130,233,108,37,228,26,10,},},
{{5,140,92,34,196,13,0,},{165,72,92,160,224,3,0,},},{{10,172,70,9,68,15,0,},{158,40,101,157,168,10,0,},},{{5,60,92,160,128,13,0,},},{{160,88,108,37,148,9,10,},},
{{165,88,100,160,136,4,0,},{164,144,68,244,80,2,0,},},{{8,100,106,26,252,110,64,},{165,104,104,26,196,4,10,},{161,224,76,130,49,10,0,},},{{159,136,93,157,128,13,0,},},
{{13,148,92,165,96,6,0,},{157,200,65,158,184,9,0,},{157,96,69,158,224,9,0,},},{{157,176,16,36,12,7,0,},},{{10,212,106,26,252,94,12,},{163,120,104,26,84,12,10,},},
{{244,160,100,160,168,10,0,},{157,112,73,158,8,10,0,},},{{6,76,94,6,172,8,0,},{197,208,78,9,52,10,0,},{159,168,105,26,4,222,9,},},{{197,200,78,9,52,10,0,},},
{{197,192,78,9,52,10,0,},},{{10,244,102,197,216,14,0,},{5,124,108,37,28,14,10,},{163,88,100,160,32,12,0,},},{{21,148,94,6,100,6,0,},{159,200,105,26,4,222,9,},},
{{6,148,110,37,148,105,64,},{4,196,108,37,28,30,10,},},{{39,156,42,22,4,0,0,},{197,176,102,197,56,9,0,},{161,16,101,161,56,9,0,},},{{163,72,92,160,144,11,0,},},
{{16,236,85,164,0,0,0,},{7,84,70,7,20,11,0,},{244,144,72,244,40,11,0,},},{{4,36,109,37,28,30,10,},{130,193,100,161,168,10,0,},},{{158,200,69,158,16,11,0,},},
{{16,4,84,164,0,0,0,},{7,68,74,7,44,11,0,},{197,208,106,26,108,89,12,},},{{11,148,4,5,4,0,0,},{157,152,73,158,8,10,0,},},{{38,84,92,11,108,3,0,},},
{{8,76,94,6,124,14,0,},{164,56,100,160,104,1,0,},{161,184,64,130,185,9,0,},},{{244,88,104,26,204,10,10,},},{{164,152,92,47,236,0,0,},{160,40,100,160,56,9,0,},},
{{162,64,68,244,200,12,0,},{160,64,76,244,48,10,0,},},{{6,68,66,7,188,9,0,},{4,20,65,130,49,14,0,},},{{10,164,110,37,20,95,12,},{159,72,93,157,128,13,0,},},
{{165,160,68,244,80,5,0,},{160,144,72,244,8,10,0,},},{{162,96,68,244,200,12,0,},{160,96,76,244,48,10,0,},},{{11,68,4,5,4,0,0,},{165,96,108,37,244,4,10,},},
{{161,232,100,161,56,9,0,},{159,104,93,157,128,13,0,},},{{32,220,45,12,4,0,0,},{22,12,94,197,96,6,0,},},{{162,224,101,27,108,13,0,},{162,144,108,37,124,12,10,},},
{{4,252,100,161,224,13,0,},{162,232,101,27,108,13,0,},},{{244,48,92,160,72,10,0,},{158,104,105,26,204,218,9,},},{0},{{10,196,102,197,216,14,0,},{157,120,69,158,224,9,0,},},
{{14,68,80,165,0,0,0,},{10,204,102,197,216,14,0,},{197,152,66,9,188,9,0,},},{{26,212,54,10,4,0,0,},{161,216,92,161,168,8,0,},{158,72,105,26,204,218,9,},},
{0},{{18,244,92,161,96,6,0,},{7,148,106,26,204,106,64,},{159,88,109,37,28,222,9,},},{{130,217,108,37,228,26,10,},{162,56,92,160,144,11,0,},},{{130,201,72,130,41,11,0,},},
{{5,164,100,160,224,13,0,},{244,112,104,26,204,10,10,},},{{157,40,109,37,148,217,9,},},{{34,124,44,19,4,0,0,},{130,249,108,37,228,26,10,},{164,40,92,160,168,0,0,},},
{{7,68,106,26,204,106,64,},{157,200,69,158,224,9,0,},},{{8,52,74,7,92,15,0,},{165,56,72,244,128,5,0,},},{{49,188,5,31,4,0,0,},{7,84,106,26,204,106,64,},},
{{162,72,100,160,32,12,0,},{160,72,108,37,148,9,10,},},{{7,100,74,7,44,11,0,},{130,33,109,37,228,26,10,},},{0},{{5,60,68,244,72,14,0,},},{{162,104,100,160,32,12,0,},
{160,104,108,37,148,9,10,},},{{8,84,110,37,20,111,64,},{197,248,94,44,220,8,0,},{165,88,108,37,244,4,10,},},{{161,224,68,130,225,9,0,},},{{159,136,101,157,224,13,0,},},
{{164,104,108,37,228,1,10,},{157,96,93,157,168,8,0,},},{{197,168,70,9,228,9,0,},},{{244,56,92,160,72,10,0,},{197,160,70,9,228,9,0,},},{{45,4,58,46,4,0,0,},
{5,108,108,37,28,14,10,},},{{6,76,102,6,60,9,0,},{4,228,104,26,4,30,10,},},{0},{{11,52,4,5,4,0,0,},{158,200,93,157,72,10,0,},},{{164,72,72,244,136,2,0,},},
{{160,40,92,160,168,8,0,},},{{6,148,102,6,60,9,0,},{6,44,106,26,108,105,64,},{165,152,92,47,28,4,0,},},{{244,40,100,160,168,10,0,},{161,16,109,37,148,25,10,},},
{{244,104,104,26,204,10,10,},{163,72,68,244,200,12,0,},},{{130,209,72,130,41,11,0,},{160,56,100,160,56,9,0,},},{{4,36,101,161,224,13,0,},{164,144,108,37,228,1,10,},},
{{197,192,70,9,228,9,0,},},{{27,28,92,15,100,6,0,},{244,72,104,26,204,10,10,},},{{46,252,125,46,4,32,10,},{9,204,106,26,204,90,12,},},{{130,33,93,161,72,10,0,},},
{{6,36,74,7,12,10,0,},{158,40,93,157,72,10,0,},},{{36,172,9,38,20,0,0,},{7,44,70,7,20,11,0,},{5,124,100,160,224,13,0,},},{{6,52,74,7,12,10,0,},
{5,116,100,160,224,13,0,},},{{160,64,68,244,224,9,0,},},{{4,20,73,130,97,14,0,},{164,88,108,37,228,1,10,},},{{16,52,84,164,0,0,0,},{164,64,108,37,228,1,10,},
{162,96,100,160,32,12,0,},},{{130,25,93,42,108,10,0,},{158,152,109,37,228,218,9,},},{{6,100,94,6,172,8,0,},{160,96,68,244,224,9,0,},},{{165,96,100,160,136,4,0,},},
{{158,120,105,26,204,218,9,},},{{164,96,72,244,136,2,0,},{162,72,68,244,200,12,0,},},{{162,144,100,160,32,12,0,},},{{6,68,106,26,108,105,64,},{158,200,109,37,228,218,9,},},
{{5,100,104,26,4,14,10,},{158,208,93,49,108,10,0,},},{{161,200,72,130,9,10,0,},{158,216,109,37,228,218,9,},},{{164,112,92,160,168,0,0,},{157,120,77,158,48,10,0,},},
{{165,144,92,160,224,3,0,},},{{197,168,78,9,52,10,0,},{161,216,68,130,225,9,0,},},{{161,192,108,37,148,25,10,},},{{24,36,102,8,148,6,0,},{159,88,101,157,224,13,0,},},
{{6,140,94,48,220,8,0,},{197,216,106,26,108,89,12,},{162,160,72,244,240,12,0,},},{{10,4,103,197,216,14,0,},{10,180,110,37,20,95,12,},},{{30,188,44,18,4,0,0,},
{165,160,92,160,224,3,0,},},{{157,40,101,157,56,9,0,},},{{21,84,94,6,100,6,0,},{130,249,100,161,168,10,0,},},{{15,148,88,165,0,0,0,},{8,36,110,37,20,111,64,},
{165,40,108,37,244,4,10,},},{{9,212,70,9,20,11,0,},},{{24,100,102,8,148,6,0,},{157,176,105,26,108,217,9,},},{{162,72,108,37,124,12,10,},{160,72,100,160,56,9,0,},},
{{8,68,110,37,20,111,64,},{165,72,108,37,244,4,10,},},{{7,148,110,37,228,106,64,},{5,44,104,26,4,14,10,},},{{8,68,70,7,68,15,0,},{7,132,74,7,44,11,0,},},
{{162,104,108,37,124,12,10,},{160,104,100,160,56,9,0,},},{{36,172,8,38,20,0,0,},},{{35,148,46,21,4,0,0,},{7,28,106,26,204,106,64,},{5,76,104,26,4,14,10,},},
{{159,136,109,37,28,222,9,},},{{164,104,100,160,104,1,0,},},{{22,180,94,197,96,6,0,},{158,216,73,158,40,11,0,},},{{22,156,94,197,96,6,0,},{244,56,68,244,16,11,0,},
{161,240,100,161,56,9,0,},},{{5,108,100,160,224,13,0,},{157,216,93,157,168,8,0,},},{{164,120,92,160,168,0,0,},{163,16,100,16,52,13,0,},},{{6,84,94,6,172,8,0,},
{6,60,106,26,108,105,64,},},{{197,8,106,26,108,89,12,},{161,208,100,161,56,9,0,},},{{15,4,88,165,0,0,0,},{164,72,64,244,24,2,0,},{159,216,69,158,72,14,0,},},
{0},{{8,148,102,6,220,14,0,},{6,148,94,6,172,8,0,},{4,196,92,161,128,13,0,},},{{6,124,94,35,12,9,0,},{165,16,100,16,212,5,0,},},{{22,4,95,197,96,6,0,},
{159,112,65,158,48,14,0,},},{{160,144,104,26,108,9,10,},{160,56,108,37,148,9,10,},},{{160,160,108,37,148,9,10,},},{{163,56,104,26,84,12,10,},{158,176,73,158,40,11,0,},},
{{26,244,54,10,4,0,0,},{4,220,104,26,4,30,10,},},{{157,48,93,157,168,8,0,},},{{8,60,66,7,44,15,0,},{165,48,64,244,32,5,0,},},{{9,180,102,197,168,10,0,},
{158,144,73,158,40,11,0,},},{{10,180,102,197,216,14,0,},{10,12,106,26,252,94,12,},{163,160,104,26,84,12,10,},},{{4,228,64,130,49,14,0,},{164,48,104,26,172,1,10,},},
{{160,64,92,160,168,8,0,},{159,144,73,158,96,14,0,},},{{5,52,68,244,72,14,0,},{197,240,102,197,56,9,0,},},{{12,180,93,157,96,6,0,},},{{5,148,108,37,28,14,10,},},
{{6,100,102,6,60,9,0,},{159,176,73,158,96,14,0,},},{{9,244,102,197,168,10,0,},},{0},{{7,100,110,37,228,106,64,},{164,96,64,244,24,2,0,},{157,208,93,49,220,8,0,},},
{{4,236,72,130,97,14,0,},{160,112,100,160,56,9,0,},},{{162,24,92,15,84,13,0,},},{{244,48,108,37,228,10,10,},{161,248,76,130,49,10,0,},},{{5,116,92,160,128,13,0,},
{161,200,64,130,185,9,0,},},{{14,108,80,165,0,0,0,},{4,204,72,130,97,14,0,},},{{8,36,106,26,252,110,64,},{165,144,68,244,80,5,0,},{158,88,93,157,72,10,0,},},
{{7,44,110,37,228,106,64,},{161,216,76,130,49,10,0,},},{{7,36,110,37,228,106,64,},},{{41,36,42,21,4,0,0,},{7,60,110,37,228,106,64,},},{{7,52,110,37,228,106,64,},
{130,17,105,26,204,26,10,},},{{10,4,111,37,20,95,12,},{244,96,68,244,16,11,0,},},{{13,244,93,165,96,6,0,},{197,0,103,197,56,9,0,},{163,104,72,244,240,12,0,},},
{{9,196,74,9,44,11,0,},{157,40,93,157,168,8,0,},},{{12,44,93,157,96,6,0,},{162,88,108,37,124,12,10,},{159,120,73,158,96,14,0,},},{{165,40,100,160,136,4,0,},
{158,168,105,26,204,218,9,},},{0},{{9,164,74,9,44,11,0,},{159,104,69,158,72,14,0,},},{{4,188,68,130,73,14,0,},{160,72,92,160,168,8,0,},},{{19,76,92,160,96,6,0,},
{165,72,100,160,136,4,0,},{158,136,105,26,204,218,9,},},{{10,172,94,197,120,14,0,},{164,144,72,244,136,2,0,},},{{14,236,81,165,0,0,0,},{162,120,72,244,240,12,0,},
{159,152,109,37,28,222,9,},},{{19,148,92,160,96,6,0,},{162,160,64,244,160,12,0,},},{0},{{161,192,68,130,225,9,0,},},{{25,156,5,159,0,0,0,},{18,20,93,161,96,6,0,},},
{{25,148,5,159,0,0,0,},{164,160,104,26,172,1,10,},},{{165,120,92,160,224,3,0,},{158,112,69,158,16,11,0,},},{{18,172,92,161,96,6,0,},{130,169,108,37,228,26,10,},
{161,240,108,37,148,25,10,},},{{37,44,62,24,4,0,0,},{5,108,92,160,128,13,0,},{157,216,101,157,56,9,0,},},{{164,120,68,244,80,2,0,},{159,48,93,157,128,13,0,},},
{{4,244,92,161,128,13,0,},},{{8,124,94,35,188,14,0,},{161,208,108,37,148,25,10,},},{{8,100,94,6,124,14,0,},{159,216,93,157,128,13,0,},},{{160,40,108,37,148,9,10,},
{159,200,65,158,48,14,0,},},{{8,148,110,37,20,111,64,},{8,84,94,6,124,14,0,},},{{8,28,110,37,20,111,64,},{158,64,105,26,204,218,9,},},{{9,4,75,9,44,11,0,},
{8,68,94,6,124,14,0,},{157,136,77,158,48,10,0,},},{{162,48,72,244,240,12,0,},{157,144,101,157,56,9,0,},},{{18,228,92,161,96,6,0,},{160,160,100,160,56,9,0,},},
{{18,236,92,161,96,6,0,},{8,44,70,7,68,15,0,},{158,176,65,158,248,10,0,},},{{197,208,66,9,188,9,0,},{161,168,92,161,168,8,0,},},{{159,96,101,157,224,13,0,},},
{{8,60,74,7,92,15,0,},{165,48,72,244,128,5,0,},},{{8,76,70,7,68,15,0,},{158,144,65,158,248,10,0,},},{{10,180,94,197,120,14,0,},{244,88,64,244,248,10,0,},
{163,24,92,15,84,13,0,},},{{11,100,4,5,4,0,0,},{7,76,66,7,252,10,0,},{6,76,70,7,228,9,0,},},{{130,225,108,37,228,26,10,},{159,144,65,158,48,14,0,},},
{{163,144,68,244,200,12,0,},},{{11,204,4,4,4,0,0,},{5,68,72,244,96,14,0,},},{{18,28,93,42,116,6,0,},},{{6,100,110,37,148,105,64,},{159,176,65,158,48,14,0,},},
{0},{0},{{9,156,66,9,252,10,0,},{157,104,73,158,8,10,0,},},{{160,112,108,37,148,9,10,},},{{4,252,92,161,128,13,0,},{130,185,68,130,17,11,0,},},{{158,104,65,158,248,10,0,},},
{{159,208,93,49,164,13,0,},},{{6,52,70,7,228,9,0,},{4,204,64,130,49,14,0,},},{{7,148,102,6,172,10,0,},},{{165,160,72,244,128,5,0,},},{{244,136,92,34,140,10,0,},},
{{9,244,106,26,204,90,12,},},{0},{{10,156,74,9,92,15,0,},{5,148,64,244,48,14,0,},{163,48,72,244,240,12,0,},},{{197,0,95,197,168,8,0,},},{{30,36,45,18,4,0,0,},
{9,196,66,9,252,10,0,},{162,40,104,26,84,12,10,},},{{159,120,65,158,48,14,0,},},{{7,76,70,7,20,11,0,},{197,216,102,197,56,9,0,},{158,48,109,37,228,218,9,},},
{{15,92,88,165,0,0,0,},{157,160,93,157,168,8,0,},},{{9,164,66,9,252,10,0,},{164,56,72,244,136,2,0,},},{{26,156,54,10,4,0,0,},{162,72,92,160,144,11,0,},},
{{130,33,69,130,17,11,0,},},{{16,252,85,164,0,0,0,},},{{162,120,64,244,160,12,0,},{159,152,101,157,224,13,0,},},{{161,32,101,161,56,9,0,},},{{8,84,70,7,68,15,0,},
{165,88,68,244,80,5,0,},},{{8,100,74,7,92,15,0,},{165,104,72,244,128,5,0,},{161,224,108,37,148,25,10,},},{{157,80,105,26,108,217,9,},},{{4,252,108,37,28,30,10,},},
{{165,120,68,244,80,5,0,},{158,112,93,157,72,10,0,},},{{5,92,64,244,48,14,0,},{163,120,72,244,240,12,0,},{161,32,93,161,168,8,0,},},{{11,188,4,4,4,0,0,},
{244,160,68,244,16,11,0,},{157,112,105,26,108,217,9,},},{0},{{8,132,110,37,20,111,64,},{161,192,72,130,9,10,0,},{158,96,101,157,168,10,0,},},{{10,244,74,9,92,15,0,},
{163,88,72,244,240,12,0,},{158,80,105,26,204,218,9,},},{{161,248,92,161,168,8,0,},},{{15,172,89,165,0,0,0,},{4,188,108,37,28,30,10,},{159,200,73,158,96,14,0,},},
{{6,44,66,7,188,9,0,},{161,232,92,161,168,8,0,},},{{244,104,92,160,72,10,0,},},{{13,60,92,165,96,6,0,},{9,4,67,9,252,10,0,},{157,136,69,158,224,9,0,},},
{{6,132,74,7,12,10,0,},{162,48,64,244,160,12,0,},{159,64,109,37,28,222,9,},},{{130,193,68,130,17,11,0,},{160,160,92,160,168,8,0,},},{{8,44,94,6,124,14,0,},
{197,192,110,37,148,89,12,},{163,160,100,160,32,12,0,},},{{197,208,74,9,12,10,0,},{163,40,92,160,144,11,0,},},{{7,44,74,7,44,11,0,},{159,96,109,37,28,222,9,},},
{{12,164,93,157,96,6,0,},{130,241,108,37,228,26,10,},},{{8,28,102,6,220,14,0,},{7,60,74,7,44,11,0,},},{{164,88,104,26,172,1,10,},},{0},{{163,104,100,160,32,12,0,},
{158,152,105,26,204,218,9,},},{{10,164,66,9,44,15,0,},{163,96,100,160,32,12,0,},},{{5,68,64,244,48,14,0,},},{{162,64,72,244,240,12,0,},},{{8,84,102,6,220,14,0,},
{160,96,108,37,148,9,10,},},{{165,112,100,160,136,4,0,},{158,120,93,157,72,10,0,},},{{158,200,105,26,204,218,9,},},{{9,156,74,9,44,11,0,},{157,104,65,158,184,9,0,},},
{{26,164,54,10,4,0,0,},{158,216,105,26,204,218,9,},},{{130,185,92,161,72,10,0,},{197,0,111,37,148,89,12,},},{{163,96,104,26,84,12,10,},{158,104,73,158,40,11,0,},},
{{9,196,70,9,20,11,0,},{164,112,104,26,172,1,10,},},{{161,192,104,26,108,25,10,},{159,40,101,157,224,13,0,},},{{158,88,109,37,228,218,9,},},{{165,160,64,244,32,5,0,},
{163,64,104,26,84,12,10,},},{{15,236,89,165,0,0,0,},{162,136,92,34,244,11,0,},},{{197,200,110,37,148,89,12,},{162,56,104,26,84,12,10,},},{{130,201,100,161,168,10,0,},
{163,224,101,27,108,13,0,},},{{5,148,72,244,96,14,0,},{163,48,64,244,160,12,0,},},{{197,240,78,9,52,10,0,},{159,104,105,26,4,222,9,},},{{160,48,100,160,56,9,0,},
{157,144,65,158,184,9,0,},},{{12,172,93,157,96,6,0,},{197,200,74,9,12,10,0,},},{{197,216,110,37,148,89,12,},{157,56,29,50,124,7,0,},},{{9,212,94,197,72,10,0,},},
{{157,176,65,158,184,9,0,},},{{4,212,64,130,49,14,0,},{160,72,76,244,48,10,0,},},{{8,76,66,7,44,15,0,},},{{162,40,92,160,144,11,0,},},{{9,12,110,37,228,90,12,},
{164,144,100,160,104,1,0,},{157,64,105,26,108,217,9,},},{{165,56,64,244,32,5,0,},{160,104,76,244,48,10,0,},},{{11,252,4,4,4,0,0,},},{{8,100,66,7,44,15,0,},
{165,104,64,244,32,5,0,},{161,224,100,161,56,9,0,},},{{157,200,109,37,148,217,9,},{157,96,105,26,108,217,9,},},{{26,172,54,10,4,0,0,},{157,216,65,158,184,9,0,},},
{{14,92,80,165,0,0,0,},{7,76,94,6,76,10,0,},},{{10,212,66,9,44,15,0,},{163,120,64,244,160,12,0,},{161,240,92,161,168,8,0,},},{{244,160,92,160,72,10,0,},},
{{13,4,92,165,96,6,0,},{6,60,94,6,172,8,0,},},{{161,192,64,130,185,9,0,},{158,96,109,37,228,218,9,},},{{10,244,66,9,44,15,0,},{5,124,72,244,96,14,0,},
{163,88,64,244,160,12,0,},},{{164,72,104,26,172,1,10,},{159,216,109,37,28,222,9,},},{{159,80,109,37,28,222,9,},},{{6,148,70,7,228,9,0,},{6,44,74,7,12,10,0,},
{4,196,68,130,73,14,0,},},{0},{{10,196,70,9,68,15,0,},{244,144,100,160,168,10,0,},{157,136,93,157,168,8,0,},},{{10,204,70,9,68,15,0,},{130,209,104,26,204,26,10,},
{160,56,68,244,224,9,0,},},{{4,36,69,130,73,14,0,},{4,196,100,161,224,13,0,},},{{14,52,80,165,0,0,0,},{4,204,100,161,224,13,0,},{197,192,102,197,56,9,0,},},
{{9,204,94,197,72,10,0,},{159,112,73,158,96,14,0,},{157,152,101,157,56,9,0,},},{{9,172,106,26,204,90,12,},{157,168,105,26,108,217,9,},},{{130,241,100,161,168,10,0,},
{158,160,93,157,72,10,0,},},{{161,184,104,26,108,25,10,},},{{163,160,64,244,160,12,0,},},{{160,64,104,26,108,9,10,},},{0},{{7,100,94,6,76,10,0,},{5,52,92,160,128,13,0,},},
{{161,248,68,130,225,9,0,},},{{24,28,102,43,148,6,0,},{13,100,92,165,96,6,0,},},{{162,96,108,37,124,12,10,},{160,96,100,160,56,9,0,},},{{15,76,88,165,0,0,0,},
{165,112,108,37,244,4,10,},{161,232,64,130,185,9,0,},},{{10,220,106,26,252,94,12,},{163,112,104,26,84,12,10,},},{{24,60,102,8,148,6,0,},{164,96,104,26,172,1,10,},
{159,160,101,157,224,13,0,},},{{162,144,68,244,200,12,0,},{160,112,92,160,168,8,0,},},{{15,108,88,165,0,0,0,},{6,68,74,7,12,10,0,},},{{5,68,104,26,4,14,10,},},
{{8,44,110,37,20,111,64,},{244,144,64,244,248,10,0,},},{{164,64,100,160,104,1,0,},{159,40,109,37,28,222,9,},},{{197,152,106,26,108,89,12,},{158,88,101,157,168,10,0,},},
{{12,100,93,157,96,6,0,},{7,52,106,26,204,106,64,},{161,216,100,161,56,9,0,},},{{15,60,88,165,0,0,0,},{157,128,93,25,60,8,0,},},{{162,104,72,244,240,12,0,},},
{{12,220,93,157,96,6,0,},{130,201,108,37,228,26,10,},{165,64,68,244,80,5,0,},},{{8,100,110,37,20,111,64,},{244,96,108,37,228,10,10,},{160,120,64,244,184,9,0,},},
{{5,164,92,160,128,13,0,},{197,0,79,9,52,10,0,},},{{157,144,73,158,8,10,0,},},{{197,200,66,9,188,9,0,},{158,168,93,157,72,10,0,},},{{8,52,102,6,220,14,0,},
{4,188,64,130,49,14,0,},{165,56,100,160,136,4,0,},},{{9,212,102,197,168,10,0,},{157,160,109,37,148,217,9,},},{{9,220,94,197,72,10,0,},{157,176,73,158,8,10,0,},},
{{160,72,68,244,224,9,0,},},{{7,124,94,35,140,10,0,},{5,44,92,160,128,13,0,},{162,160,68,244,200,12,0,},},{{7,132,102,6,172,10,0,},},{{9,180,106,26,204,90,12,},
{9,12,102,197,168,10,0,},{160,88,72,244,8,10,0,},},{{130,209,64,130,249,10,0,},{160,104,68,244,224,9,0,},},{{19,124,92,160,96,6,0,},{164,160,108,37,228,1,10,},},
{{19,116,92,160,96,6,0,},{159,136,65,158,48,14,0,},},{{160,120,72,244,8,10,0,},{157,200,101,157,56,9,0,},},{{19,68,92,160,96,6,0,},},{{158,112,109,37,228,218,9,},},
{{161,32,77,130,49,10,0,},},{{41,148,42,21,4,0,0,},{5,108,68,244,72,14,0,},{158,160,109,37,228,218,9,},},{{4,244,104,26,4,30,10,},{164,120,108,37,228,1,10,},},
{{162,64,100,160,32,12,0,},},{{12,108,93,157,96,6,0,},{197,160,78,9,52,10,0,},{161,208,68,130,225,9,0,},},{{24,68,102,8,148,6,0,},{164,224,101,27,68,3,0,},
{159,216,101,157,224,13,0,},},{{157,152,105,26,108,217,9,},},{{161,16,65,130,185,9,0,},},{{25,116,5,159,0,0,0,},{18,252,92,161,96,6,0,},},{{9,252,94,44,108,10,0,},
{244,120,104,26,204,10,10,},},{{6,28,102,6,60,9,0,},{159,64,93,157,128,13,0,},},{{25,220,5,159,0,0,0,},{4,36,93,161,128,13,0,},{160,160,76,244,48,10,0,},},
{{14,4,80,165,0,0,0,},{161,168,104,26,108,25,10,},},{{157,48,105,26,108,217,9,},},{{9,220,106,26,204,90,12,},{157,216,105,26,108,217,9,},},{{11,236,4,4,4,0,0,},
{130,241,92,161,72,10,0,},{158,160,101,157,168,10,0,},},{{8,76,110,37,20,111,64,},{165,64,108,37,244,4,10,},{157,200,105,26,108,217,9,},},{{32,180,45,12,4,0,0,},
{10,180,70,9,68,15,0,},{163,160,72,244,240,12,0,},},{{162,64,104,26,84,12,10,},},{{163,248,127,162,8,32,10,},{162,112,108,37,124,12,10,},},{{5,52,100,160,224,13,0,},
{165,128,93,25,172,3,0,},{163,144,108,37,124,12,10,},},{0},{{197,152,74,9,12,10,0,},},{{165,96,72,244,128,5,0,},},{{244,64,104,26,204,10,10,},},{{10,196,110,37,20,95,12,},
{157,88,93,157,168,8,0,},},{{16,76,84,164,0,0,0,},{4,220,92,161,128,13,0,},{159,160,109,37,28,222,9,},},{{4,236,104,26,4,30,10,},{162,144,92,160,144,11,0,},},
{{244,48,64,244,248,10,0,},{197,168,106,26,108,89,12,},},{{7,36,106,26,204,106,64,},{5,116,104,26,4,14,10,},},{{157,120,105,26,108,217,9,},},{{6,52,110,37,148,105,64,},
{4,204,104,26,4,30,10,},{164,64,92,160,168,0,0,},},{{4,236,92,161,128,13,0,},{165,144,100,160,136,4,0,},},{{161,216,108,37,148,25,10,},},{{9,244,94,197,72,10,0,},},
{{26,4,55,10,4,0,0,},{130,217,72,130,41,11,0,},{162,160,100,160,32,12,0,},},{{130,17,73,130,41,11,0,},},{{14,60,80,165,0,0,0,},{244,96,100,160,168,10,0,},
{161,24,93,42,220,8,0,},},{{197,0,71,9,228,9,0,},},{{130,249,72,130,41,11,0,},},{{8,36,74,7,92,15,0,},},{{8,52,110,37,20,111,64,},{165,56,108,37,244,4,10,},},
{{9,212,110,37,228,90,12,},{157,160,101,157,56,9,0,},},{{9,164,106,26,204,90,12,},{159,104,101,157,224,13,0,},},{{8,68,74,7,92,15,0,},{165,72,72,244,128,5,0,},
{158,136,69,158,16,11,0,},},{{10,172,106,26,252,94,12,},{8,36,70,7,68,15,0,},},{{5,60,104,26,4,14,10,},{244,144,104,26,204,10,10,},},{{9,12,94,197,72,10,0,},
{162,120,104,26,84,12,10,},},{{27,228,101,27,116,6,0,},{160,104,92,160,168,8,0,},},};

struct action_table_key {
    uint8_t bytes[3];
};
static inline struct action_table_key encode_key(uint32_t target_nfa_state, uint32_t dfa_state, uint32_t dfa_symbol) {
    struct action_table_key key = {0};
    key.bytes[0] |= (target_nfa_state >> 0) & 255;
    key.bytes[1] |= (target_nfa_state >> 8) & 7;
    key.bytes[1] |= (dfa_state << 3) & 255;
    key.bytes[2] |= (dfa_state >> 5) & 3;
    key.bytes[2] |= (dfa_symbol << 2) & 127;
    return key;
}
struct action_table_entry {
    uint32_t nfa_state;
    uint32_t actions;
    uint32_t push_nfa_state;
};
static struct action_table_entry decode_entry(const uint8_t *bytes) {
    struct action_table_entry entry = {0};
    entry.nfa_state |= ((uint32_t)bytes[3] & 255) << 0;
    entry.nfa_state |= ((uint32_t)bytes[4] & 7) << 8;
    entry.actions |= ((uint32_t)bytes[4] & 255) >> 3;
    entry.actions |= ((uint32_t)bytes[5] & 15) << 5;
    entry.push_nfa_state |= ((uint32_t)bytes[5] & 255) >> 4;
    entry.push_nfa_state |= ((uint32_t)bytes[6] & 127) << 4;
    return entry;
}
static struct action_table_entry action_table_lookup(uint32_t nfa_state, uint32_t dfa_state, uint32_t token) {
    uint32_t index1 = ((((((0xe5aa55e5 ^ (nfa_state)) * 0xe5aa55e5) ^ (dfa_state)) * 0xe5aa55e5) ^ (token)) * 0xe5aa55e5) & 1023;
    uint32_t index2 = ((((((0xf2579761 ^ (nfa_state)) * 0xf2579761) ^ (dfa_state)) * 0xf2579761) ^ (token)) * 0xf2579761) & 1023;
    struct action_table_key key = encode_key(nfa_state, dfa_state, token);
    uint32_t j = 0;
    const uint8_t *entry = 0;
    for (; j < 3; ++j) {
        entry = action_table[index1][j];
        if (!memcmp(key.bytes, entry, sizeof(key.bytes)))
            break;
        entry = action_table[index2][j];
        if (!memcmp(key.bytes, entry, sizeof(key.bytes)))
            break;
    }
    if (j >= 3)
        abort();
    return decode_entry(entry);
}
static void apply_actions(struct construct_state *state, uint32_t index, size_t start, size_t end) {
    size_t offset = end;
    for (uint32_t i = index; actions[i]; ++i) {
        if (((((actions[i]) >> 12) & 0xf) & 8))
            offset = start;
        construct_action_apply(state, actions[i], offset);
    }
}
static size_t build_parse_tree(struct owl_default_tokenizer *tokenizer, struct owl_token_run *run, struct owl_tree *tree) {
    struct construct_state construct_state = { .info = tree };
    uint32_t *state_stack = 0;
    uint32_t stack_depth = 0;
    size_t stack_capacity = 0;
    size_t whitespace = tokenizer->whitespace;
    size_t offset = tokenizer->offset - whitespace;
    construct_begin(&construct_state, offset, CONSTRUCT_NORMAL_ROOT);
    uint32_t nfa_state = 163;
    while (run) {
        uint16_t length_offset = run->lengths_size - 1;
        uint16_t n = run->number_of_tokens;
        for (uint16_t i = n - 1; i < n; i--) {
            size_t end = offset;
            size_t len = 0;
            struct action_table_entry entry = action_table_lookup(nfa_state, run->states[i], run->tokens[i]);
            if (run->tokens[i] < 26)
                len = decode_token_length(run, &length_offset, &offset);
            else {
                if (stack_depth >= stack_capacity) {
                    size_t new_capacity = (stack_capacity + 2) * 3 / 2;
                    if (new_capacity <= stack_capacity)
                        abort();
                    uint32_t *new_stack = realloc(state_stack, new_capacity * sizeof(uint32_t));
                    if (!new_stack)
                        abort();
                    state_stack = new_stack;
                    stack_capacity = new_capacity;
                }
                state_stack[stack_depth++] = entry.push_nfa_state;
            }
            apply_actions(&construct_state, entry.actions, end, end + whitespace);
            if (run->states[i] == 64) {
                if (stack_depth == 0)
                    abort();
                nfa_state = state_stack[--stack_depth];
            } else
                nfa_state = entry.nfa_state;
            whitespace = end - offset - len;
        }
        struct owl_token_run *old = run;
        run = run->prev;
        free(old);
    }
    struct action_table_entry entry = action_table_lookup(nfa_state, UINT32_MAX, UINT32_MAX);
    apply_actions(&construct_state, entry.actions, offset, offset + whitespace);
    free(state_stack);
    free_token_runs(&run);
    return construct_finish(&construct_state, offset);
}
static size_t read_keyword_token(uint32_t *token, bool *end_token, const char *text, void *info) {
    switch (text[0]) {
    case 35:
        *end_token = false;
        *token = 4294967295U;
        return 1;
    case 40:
        *end_token = false;
        *token = 12;
        return 1;
    case 41:
        *end_token = true;
        *token = 13;
        return 1;
    case 42:
        *end_token = false;
        *token = 16;
        return 1;
    case 43:
        *end_token = false;
        *token = 17;
        return 1;
    case 46:
        switch (text[1]) {
        case 108:
            if (text[2] == 105 && text[3] == 110 && text[4] == 101 && text[5] == 45 && text[6] == 99 && text[7] == 111 && text[8] == 109 && text[9] == 109 && text[10] == 101 && text[11] == 110 && text[12] == 116 && text[13] == 45 && text[14] == 116 && text[15] == 111 && text[16] == 107 && text[17] == 101 && text[18] == 110) {
                *end_token = false;
                *token = 20;
                return 19;
            } else {
                return 0;
            }
        case 111:
            if (text[2] == 112 && text[3] == 101 && text[4] == 114 && text[5] == 97 && text[6] == 116 && text[7] == 111 && text[8] == 114 && text[9] == 115) {
                *end_token = false;
                *token = 2;
                return 10;
            } else {
                return 0;
            }
        case 116:
            if (text[2] == 111 && text[3] == 107 && text[4] == 101 && text[5] == 110) {
                *end_token = false;
                *token = 22;
                return 6;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 58:
        *end_token = false;
        *token = 1;
        return 1;
    case 61:
        *end_token = false;
        *token = 0;
        return 1;
    case 63:
        *end_token = false;
        *token = 18;
        return 1;
    case 64:
        *end_token = false;
        *token = 11;
        return 1;
    case 91:
        *end_token = false;
        *token = 14;
        return 1;
    case 92:
        *end_token = false;
        *token = 10;
        return 1;
    case 93:
        *end_token = true;
        *token = 15;
        return 1;
    case 102:
        if (text[1] == 108 && text[2] == 97 && text[3] == 116) {
            *end_token = false;
            *token = 6;
            return 4;
        } else {
            return 0;
        }
    case 105:
        if (text[1] == 110 && text[2] == 102 && text[3] == 105 && text[4] == 120) {
            *end_token = false;
            *token = 5;
            return 5;
        } else {
            return 0;
        }
    case 108:
        switch (text[1]) {
        case 101:
            if (text[2] == 102 && text[3] == 116) {
                *end_token = false;
                *token = 7;
                return 4;
            } else {
                return 0;
            }
        case 105:
            if (text[2] == 110 && text[3] == 101 && text[4] == 45 && text[5] == 99 && text[6] == 111 && text[7] == 109 && text[8] == 109 && text[9] == 101 && text[10] == 110 && text[11] == 116 && text[12] == 45 && text[13] == 116 && text[14] == 111 && text[15] == 107 && text[16] == 101 && text[17] == 110) {
                *end_token = false;
                *token = 21;
                return 18;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 110:
        if (text[1] == 111 && text[2] == 110 && text[3] == 97 && text[4] == 115 && text[5] == 115 && text[6] == 111 && text[7] == 99) {
            *end_token = false;
            *token = 9;
            return 8;
        } else {
            return 0;
        }
    case 112:
        switch (text[1]) {
        case 111:
            if (text[2] == 115 && text[3] == 116 && text[4] == 102 && text[5] == 105 && text[6] == 120) {
                *end_token = false;
                *token = 3;
                return 7;
            } else {
                return 0;
            }
        case 114:
            if (text[2] == 101 && text[3] == 102 && text[4] == 105 && text[5] == 120) {
                *end_token = false;
                *token = 4;
                return 6;
            } else {
                return 0;
            }
        default:
            return 0;
        }
    case 114:
        if (text[1] == 105 && text[2] == 103 && text[3] == 104 && text[4] == 116) {
            *end_token = false;
            *token = 8;
            return 5;
        } else {
            return 0;
        }
    case 124:
        *end_token = false;
        *token = 19;
        return 1;
    default:
        return 0;
    }
}
static uint32_t rule_lookup(uint32_t parent, uint32_t slot, void *context) {
    switch (parent) {
    case 0:
        switch (slot) {
        case 0: return 1;
        case 1: return 8;
        case 2: return 10;
        default: break;
        }
        break;
    case 1:
        switch (slot) {
        case 0: return 11;
        case 1: return 2;
        default: break;
        }
        break;
    case 2:
        switch (slot) {
        case 0: return 7;
        case 1: return 11;
        case 2: return 3;
        default: break;
        }
        break;
    case 3:
        switch (slot) {
        case 0: return 4;
        case 1: return 6;
        default: break;
        }
        break;
    case 4:
        switch (slot) {
        case 0: return 5;
        default: break;
        }
        break;
    case 6:
        switch (slot) {
        case 0: return 7;
        case 1: return 11;
        default: break;
        }
        break;
    case 7:
        switch (slot) {
        case 0: return 11;
        case 1: return 11;
        case 2: return 11;
        case 3: return 13;
        case 4: return 7;
        case 5: return 13;
        case 6: return 13;
        case 7: return 7;
        default: break;
        }
        break;
    case 8:
        switch (slot) {
        case 0: return 13;
        case 1: return 9;
        default: break;
        }
        break;
    case 9:
        switch (slot) {
        case 0: return 13;
        default: break;
        }
        break;
    case 10:
        switch (slot) {
        case 0: return 11;
        case 1: return 13;
        default: break;
        }
        break;
    default: break;
    }
    return UINT32_MAX;
}
static void fixity_associativity_precedence_lookup(int *fixity_associativity, int *precedence, uint32_t rule, uint32_t choice, void *context) {
    switch (rule) {
    case 7:
        switch (choice) {
        case 4:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 5:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 6:
            *precedence = -1;
            *fixity_associativity = CONSTRUCT_POSTFIX;
            return;
        case 7:
            *precedence = -2;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        case 8:
            *precedence = -3;
            *fixity_associativity = CONSTRUCT_INFIX_FLAT;
            return;
        default: return;
        }
    default: return;
    }
}
static size_t number_of_slots_lookup(uint32_t rule, void *context) {
    switch (rule) {
    case 0: return 3;
    case 1: return 2;
    case 2: return 3;
    case 3: return 2;
    case 4: return 1;
    case 5: return 0;
    case 6: return 2;
    case 7: return 8;
    case 8: return 2;
    case 9: return 1;
    case 10: return 2;
    case 11: return 0;
    case 12: return 0;
    case 13: return 0;
    default: return 0;
    }
}
static void left_right_operand_slots_lookup(uint32_t rule, uint32_t *left, uint32_t *right, uint32_t *operand, void *context) {
    switch (rule) {
    case 0:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 1:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 2:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 3:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 4:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 5:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 6:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 7:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 7;
        break;
    case 8:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 9:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 10:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 11:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 12:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    case 13:
        *left = 4294967295U;
        *right = 4294967295U;
        *operand = 4294967295U;
        break;
    }
}
#endif

